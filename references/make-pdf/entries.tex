\DOC{++}

\TYPE {\small\verb%(++) : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e%}\egroup

\SYNOPSIS
Sequentially compose two parsers.

\DESCRIBE
If {\small\verb%p1%} and {\small\verb%p2%} are two parsers, {\small\verb%p1 ++ p2%} is a new parser that parses as
much of the input as possible using {\small\verb%p1%} and then as much of what remains using
{\small\verb%p2%}, returning the pair of parse results and the unparsed input.

\FAILURE
Never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, >>, |||, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{|||}

\TYPE {\small\verb%(|||) : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b%}\egroup

\SYNOPSIS
Produce alternative composition of two parsers.

\DESCRIBE
If {\small\verb%p1%} and {\small\verb%p2%} are two parsers, {\small\verb%p1 ||| p2%} is a new parser that first tries
to parse the input using {\small\verb%p1%}, and if that fails with exception {\small\verb%Noparse%},
tries {\small\verb%p2%} instead. The output is whatever parse result was achieved together
with the unparsed input.

\FAILURE
Never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, >>, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{>>}

\TYPE {\small\verb%(>>) : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c%}\egroup

\SYNOPSIS
Apply function to parser result.

\DESCRIBE
If {\small\verb%p%} is a parser and {\small\verb%f%} a function from the parse result type, {\small\verb%p >> f%}
gives a new parser that `pipes the original parser output through f', i.e.
applies {\small\verb%f%} to the result of the parse.

\FAILURE
Never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{|=>}

\TYPE {\small\verb%(|=>) : 'a -> 'b -> ('a, 'b) func%}\egroup

\SYNOPSIS
Gives a one-point finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The call {\small\verb%x |=> y%} gives a finite partial function that maps {\small\verb%x%} to {\small\verb%y%}
and is undefined for all arguments other than {\small\verb%x%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = (1 |=> 2);;
  val f : (int, int) func = <func>

  # apply f 1;;
  val it : int = 2

  # apply f 2;;
  Exception: Failure "apply".
\end{verbatim}
}

\SEEALSO
|->, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{--}

\TYPE {\small\verb%(--) : int -> int -> int list%}\egroup

\SYNOPSIS
Gives a finite list of integers between the given bounds.

\DESCRIBE
The call {\small\verb%m--n%} returns the list of consecutive numbers from {\small\verb%m%} to {\small\verb%n%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # 1--10;;
  val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
  # 5--5;;
  val it : int list = [5]
  # (-1)--1;;
  val it : int list = [-1; 0; 1]
  # 2--1;;
  val it : int list = []
\end{verbatim}
}

\ENDDOC
\DOC{|->}

\TYPE {\small\verb%(|->) : 'a -> 'b -> ('a, 'b) func -> ('a, 'b) func%}\egroup

\SYNOPSIS
Modify a finite partial function at one point.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc.  If {\small\verb%f%} is a finite partial function then {\small\verb%(x |-> y) f%} gives a modified
version that maps {\small\verb%x%} to {\small\verb%y%} (whether or not {\small\verb%f%} was defined on {\small\verb%x%} before and
regardless of the old value) but is otherwise the same.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = (1 |-> 2) undefined;;
  val f : (int, int) func = <func>
  # let g = (1 |-> 3) f;;
  val g : (int, int) func = <func>
  # apply f 1;;
  val it : int = 2
  # apply g 1;;
  val it : int = 3
\end{verbatim}
}

\SEEALSO
|=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{a}

\TYPE {\small\verb%a : 'a -> 'a list -> 'a * 'a list%}\egroup

\SYNOPSIS
Parser that requires a specific item.

\DESCRIBE
The call {\small\verb%a x%} gives a parser that parses a single item that is exactly {\small\verb%x%},
raising {\small\verb%Noparse%} if the first item is something different.

\FAILURE
The call {\small\verb%a x%} never fails, though the resulting parser may raise {\small\verb%Noparse%}.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{ABBREV{\_}TAC}

\TYPE {\small\verb%ABBREV_TAC : term -> (string * thm) list * term -> goalstate%}\egroup

\SYNOPSIS
Tactic to introduce an abbreviation.

\DESCRIBE
The tactic {\small\verb%ABBREV_TAC `x = t`%} abbreviates any instances of the term {\small\verb%t%} in
the goal (assumptions or conclusion) with {\small\verb%x%}, and adds a new assumption {\small\verb%t =
x%}. (Reversed so that rules like {\small\verb%ASM_REWRITE_TAC%} will not immediately expand
it again.) The LHS may be of the form {\small\verb%f x%} in which case abstraction will
happen first.

\FAILURE
Fails unless the left-hand side is a variable or a variable applied to a list
of variable arguments.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(12345 + 12345) + f(12345 + 12345) = f(12345 + 12345)`;;
  Warning: Free variables in goal: f
  val it : goalstack = 1 subgoal (1 total)

  `(12345 + 12345) + f (12345 + 12345) = f (12345 + 12345)`

  # e(ABBREV_TAC `n = 12345 + 12345`);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`12345 + 12345 = n`]

  `n + f n = f n`
\end{verbatim}
}

\USES
Convenient for abbreviating large and unwieldy expressions as a sort of `local
definition'.

\SEEALSO
EXPAND_TAC.

\ENDDOC
\DOC{ABS}

\TYPE {\small\verb%ABS : term -> thm -> thm%}\egroup

\SYNOPSIS
Abstracts both sides of an equation.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
         A |- t1 = t2
   ------------------------  ABS `x`            [Where x is not free in A]
    A |- (\x.t1) = (\x.t2)
\end{verbatim}
}

\FAILURE
If the theorem is not an equation, or if the variable {\small\verb%x%} is free in the
assumptions {\small\verb%A%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ABS `m:num` (REFL `m:num`);;
  val it : thm = |- (\m. m) = (\m. m)
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
ETA_CONV.

\ENDDOC
\DOC{ABS{\_}CONV}

\TYPE {\small\verb%ABS_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the body of an abstraction.

\DESCRIBE
If {\small\verb%c%} is a conversion that maps a term {\small\verb%`t`%} to the theorem {\small\verb%|- t = t'%}, then
the conversion {\small\verb%ABS_CONV c%} maps abstractions of the form {\small\verb%`\x. t`%} to theorems
of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\x. t) = (\x. t')
\end{verbatim}
}
\noindent That is, {\small\verb%ABS_CONV c `\x. t`%} applies {\small\verb%c%} to the body of the
abstraction {\small\verb%`\x. t`%}.

\FAILURE
{\small\verb%ABS_CONV c tm%} fails if {\small\verb%tm%} is not an abstraction or if {\small\verb%tm%} has the form
{\small\verb%`\x. t`%} but the conversion {\small\verb%c%} fails when applied to the term {\small\verb%t%}, or if the
theorem returned has assumptions in which the abstracted variable {\small\verb%x%} is free.
The function returned by {\small\verb%ABS_CONV c%} may also fail if the ML function
{\small\verb%c:term->thm%} is not, in fact, a conversion (i.e. a function that maps a term
{\small\verb%t%} to a theorem {\small\verb%|- t = t'%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ABS_CONV SYM_CONV `\x. 1 = x`;;
  val it : thm = |- (\x. 1 = x) = (\x. x = 1)
\end{verbatim}
}

\SEEALSO
GABS_CONV, RAND_CONV, RATOR_CONV, SUB_CONV.

\ENDDOC
\DOC{ABS{\_}TAC}

\TYPE {\small\verb%ABS_TAC : tactic%}\egroup

\SYNOPSIS
Strips an abstraction from each side of an equational goal.

\DESCRIBE
{\small\verb%ABS_TAC%} reduces a goal of the form {\small\verb%A ?- (\x. s[x]) = (\y. t[y])%}
by stripping away the abstractions to give a new goal {\small\verb%A ?- s[x'] = t[x']%}
where {\small\verb%x'%} is a variant of {\small\verb%x%}, the bound variable on the left-hand side,
chosen not to be free in the current goal's assumptions or conclusion.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- (\x. s[x]) = (\y. t[y])
   ================================  ABS_TAC
        A ?- s[x'] = t[x']
\end{verbatim}
}

\FAILURE
Fails unless the goal is equational, with both sides being abstractions.

\SEEALSO
AP_TERM_TAC, AP_THM_TAC, BINOP_TAC, MK_COMB_TAC.

\ENDDOC
\DOC{AC}

\TYPE {\small\verb%AC : thm -> term -> thm%}\egroup

\SYNOPSIS
Proves equality of terms using associative, commutative, and optionally
idempotence laws.

\DESCRIBE
Suppose {\small\verb%_%} is a function, which is assumed to be infix in the following
syntax, and {\small\verb%acth%} is a theorem expressing associativity and commutativity in
the particular canonical form:
{\par\samepage\setseps\small
\begin{verbatim}
   acth = |- m _ n = n _ m /\
             (m _ n) _ p = m _ n _ p /\
             m _ n _ p = n _ m _ p
\end{verbatim}
}
\noindent Then {\small\verb%AC acth%} will prove equations whose left and right sides can be
made identical using these associative and commutative laws. If the input
theorem also has idempotence property in this canonical form:
{\par\samepage\setseps\small
\begin{verbatim}
  |- (p _ q = q _ p) /\
     ((p _ q) _ r = p _ q _ r) /\
     (p _ q _ r = q _ p _ r) /\
     (p _ p = p) /\
     (p _ p _ q = p _ q)
\end{verbatim}
}
then idempotence will also be applied.

\FAILURE
Fails if the terms are not proved equivalent under the appropriate laws. This
may happen because the input theorem does not have the correct canonical form.
The latter problem will not in itself cause failure until it is applied to the
term.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # AC ADD_AC `1 + 2 + 3 = 2 + 1 + 3`;;
  val it : thm = |- 1 + 2 + 3 = 2 + 1 + 3
  # AC CONJ_ACI `p /\ (q /\ p) <=> (p /\ q) /\ (p /\ q)`;;
  val it : thm = |- p /\ q /\ p <=> (p /\ q) /\ p /\ q
\end{verbatim}
}

\COMMENTS
Note that pre-proved theorems in the correct canonical form for {\small\verb%AC%} are
already present for many standard operators, e.g. {\small\verb%ADD_AC%}, {\small\verb%MULT_AC%},
{\small\verb%INT_ADD_AC%}, {\small\verb%INT_MUL_AC%}, {\small\verb%REAL_ADD_AC%}, {\small\verb%REAL_MUL_AC%}, {\small\verb%CONJ_ACI%},
{\small\verb%DISJ_ACI%} and {\small\verb%INSERT_AC%}. The underlying algorithm is not particularly
delicate, and normalization under the associative/commutative/idempotent laws
can be achieved by direct rewriting with the same canonical theorems. For some
cases, specially optimized rules are available such as {\small\verb%CONJ_ACI_RULE%} and
{\small\verb%DISJ_ACI_RULE%}.

\SEEALSO
ASSOC_CONV, CONJ_ACI_RULE, DISJ_ACI_RULE, SYM_CONV.

\ENDDOC
\DOC{ACCEPT{\_}TAC}

\TYPE {\small\verb%ACCEPT_TAC : thm_tactic%}\egroup

\SYNOPSIS
Solves a goal if supplied with the desired theorem (up to alpha-conversion).

\DESCRIBE
{\small\verb%ACCEPT_TAC%} maps a given theorem {\small\verb%th%} to a tactic that solves any goal whose
conclusion is alpha-convertible to the conclusion of {\small\verb%th%}.

\FAILURE
{\small\verb%ACCEPT_TAC th (A ?- g)%} fails if the term {\small\verb%g%} is not alpha-convertible to the
conclusion of the supplied theorem {\small\verb%th%}.

\EXAMPLE
The theorem {\small\verb%BOOL_CASES_AX = |- !t. (t <=> T) \/ (t <=> F)%} can be used to
solve the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x. (x <=> T) \/ (x <=> F)`;;
\end{verbatim}
}
\noindent by
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ACCEPT_TAC BOOL_CASES_AX);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Used for completing proofs by supplying an existing theorem, such as an axiom,
or a lemma already proved. Often this can simply be done by rewriting, but
there are times when greater delicacy is wanted.

\SEEALSO
MATCH_ACCEPT_TAC.

\ENDDOC
\DOC{aconv}

\TYPE {\small\verb%aconv : term -> term -> bool%}\egroup

\SYNOPSIS
Tests for alpha-convertibility of terms.

\DESCRIBE
When applied to two terms, {\small\verb%aconv%} returns {\small\verb%true%} if they are
alpha-convertible, and {\small\verb%false%} otherwise.

\FAILURE
Never fails.

\EXAMPLE
A simple case of alpha-convertibility is the renaming of a single quantified
variable:
{\par\samepage\setseps\small
\begin{verbatim}
  # aconv `?x. x <=> T` `?y. y <=> T`;;
  val it : bool = true
\end{verbatim}
}
but other cases can be more involved:
{\par\samepage\setseps\small
\begin{verbatim}
# aconv `\x y z. x + y + z` `\y x z. y + x + z`;;
val it : bool = true
\end{verbatim}
}

\COMMENTS
The code for alpha-conversion first checks for simple equality with pointer
equality shortcutting, and can therefore often returns {\small\verb%true%} without a full
traversal.

In principle, most of the HOL Light deductive apparatus should work modulo
alpha-conversion. With the exception of {\small\verb%BETA%}, all the primitive inference
rules do, as does {\small\verb%BETA_CONV%}, which properly generalizes {\small\verb%BETA%}.

\SEEALSO
ALPHA, ALPHA_CONV, alphaorder.

\ENDDOC
\DOC{ADD{\_}ASSUM}

\TYPE {\small\verb%ADD_ASSUM : term -> thm -> thm%}\egroup

\SYNOPSIS
Adds an assumption to a theorem.

\DESCRIBE
When applied to a boolean term {\small\verb%s%} and a theorem {\small\verb%A |- t%}, the inference
rule {\small\verb%ADD_ASSUM%} returns the theorem {\small\verb%A u {s} |- t%}.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t
   --------------  ADD_ASSUM `s`
    A u {s} |- t
\end{verbatim}
}
\noindent {\small\verb%ADD_ASSUM%} performs straightforward set union with the new
assumption; it checks for identical assumptions, but not for alpha-equivalent
ones. The position at which the new assumption is inserted into the assumption
list should not be relied on.

\FAILURE
Fails unless the given term has type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD_ASSUM `q:bool` (ASSUME `p:bool`);;
  val it : thm = p, q |- p
\end{verbatim}
}

\SEEALSO
ASSUME, UNDISCH.

\ENDDOC
\DOC{allpairs}

\TYPE {\small\verb%allpairs : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list%}\egroup

\SYNOPSIS
Compute list of all results from applying function to pairs from two lists.

\DESCRIBE
The call {\small\verb%allpairs f [x1;...;xm] [y1;...;yn]%} returns the list of results
{\small\verb%[f x1 y1; f x1 y2; ... ; f x1 yn; f x2 y1; ...; f xm yn]%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # allpairs (fun x y -> (x,y)) [1;2;3] [4;5];;
  val it : (int * int) list = [(1, 4); (1, 5); (2, 4); (2, 5); (3, 4); (3, 5)]
\end{verbatim}
}

\SEEALSO
map2, zip.

\ENDDOC
\DOC{ALL{\_}CONV}

\TYPE {\small\verb%ALL_CONV : conv%}\egroup

\SYNOPSIS
Conversion that always succeeds and leaves a term unchanged.

\DESCRIBE
When applied to a term {\small\verb%`t`%}, the conversion {\small\verb%ALL_CONV%} returns the
theorem {\small\verb%|- t = t%}. It is just {\small\verb%REFL%} explicitly regarded as a conversion.

\FAILURE
Never fails.

\USES
Identity element for {\small\verb%THENC%}.

\SEEALSO
NO_CONV, REFL.

\ENDDOC
\DOC{ALL{\_}TAC}

\TYPE {\small\verb%ALL_TAC : tactic%}\egroup

\SYNOPSIS
Passes on a goal unchanged.

\DESCRIBE
{\small\verb%ALL_TAC%} applied to a goal {\small\verb%g%} simply produces the subgoal list {\small\verb%[g]%}. It is
the identity for the {\small\verb%THEN%} tactical.

\FAILURE
Never fails.

\EXAMPLE
Suppose we want to solve the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `~(n MOD 2 = 0) <=> n MOD 2 = 1`;;
  ...
\end{verbatim}
}
We could just solve it with {\small\verb%e ARITH_TAC%}, but suppose we want to introduce a
little lemma that {\small\verb%n MOD 2 < 2%}, proving that by {\small\verb%ARITH_TAC%}. We could do
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SUBGOAL_THEN `n MOD 2 < 2` ASSUME_TAC THENL
       [ARITH_TAC;
        ...rest of proof...]);;
\end{verbatim}
}
However if we split off many lemmas, we get a deeply nested proof structure
that's a bit confusing. In cases where the proofs of the lemmas are trivial
one-liners like this we might just want to keep the proof basically linear with
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SUBGOL_THEN `n MOD 2 < 2` ASSUME_TAC THENL [ARITH_TAC; ALL_TAC] THEN
      ...rest of proof...);;
\end{verbatim}
}

\USES
Keeping proof structures linear, as in the above example, or convenient
algebraic combinations in complicated tactic structures.

\SEEALSO
NO_TAC, REPEAT, THENL.

\ENDDOC
\DOC{ALL{\_}THEN}

\TYPE {\small\verb%ALL_THEN : thm_tactical%}\egroup

\SYNOPSIS
Passes a theorem unchanged to a theorem-tactic.

\DESCRIBE
For any theorem-tactic {\small\verb%ttac%} and theorem {\small\verb%th%}, the application {\small\verb%ALL_THEN ttac
th%} results simply in {\small\verb%ttac th%}, that is, the theorem is passed unchanged to
the theorem-tactic. {\small\verb%ALL_THEN%} is the identity theorem-tactical.

\FAILURE
The application of {\small\verb%ALL_THEN%} to a theorem-tactic never fails. The resulting
theorem-tactic fails under exactly the same conditions as the original one

\USES
Writing compound tactics or tacticals, e.g. terminating list iterations
of theorem-tacticals.

\SEEALSO
ALL_TAC, FAIL_TAC, NO_TAC, NO_THEN, THEN_TCL, ORELSE_TCL.

\ENDDOC
\DOC{alpha}

\TYPE {\small\verb%alpha : term -> term -> term%}\egroup

\SYNOPSIS
Changes the name of a bound variable.

\DESCRIBE
The call {\small\verb%alpha `v'` `\v. t[v]`%} returns the second argument with the top bound
variable changed to {\small\verb%v'%}, and other variables renamed if necessary.

\FAILURE
Fails if the first term is not a variable, or if the second is not an
abstraction, if the corresponding types are not the same, or if the desired new
variable is already free in the abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # alpha `y:num` `\x y. x + y + 2`;;
  val it : term = `\y y'. y + y' + 2`

  # alpha `y:num` `\x. x + y + 1`;;
  Exception: Failure "alpha: Invalid new variable".
\end{verbatim}
}

\SEEALSO
ALPHA, aconv.

\ENDDOC
\DOC{alphaorder}

\TYPE {\small\verb%alphaorder : term -> term -> int%}\egroup

\SYNOPSIS
Total ordering on terms respecting alpha-equivalence.

\DESCRIBE
The function {\small\verb%alphaorder%} implements a total order on terms, using {\small\verb%-1%}, {\small\verb%0%} or
{\small\verb%+1%} to indicate that the first term argument is respectively `less than',
`equal to' or `greater than' the second term argument. The ordering is largely
arbitrary, but it is transitive and (in contrast to the inbuilt OCaml
polymorphic ordering) respects alpha-equivalence, i.e. returns {\small\verb%0%} if and only
if the two terms are alpha-convertible.

\FAILURE
Never fails.

\EXAMPLE
Any two terms can be compared, and swapping the arguments negates the result:
{\par\samepage\setseps\small
\begin{verbatim}
  # alphaorder `x + 1` `p ==> q`;;
  val it : int = -1

  # alphaorder `p ==> q` `x + 1`;;
  val it : int = 1
\end{verbatim}
}
\noindent while alpha-equivalent terms, and only alpha-convertible terms, are
`equal':
{\par\samepage\setseps\small
\begin{verbatim}
  # alphaorder `!x. ?y. x + 1 < y` `!y. ?z. y + 1 < z`;;
  val it : int = 0

  # alphaorder `!x. ?y. x + 1 < y` `!x. ?y. x + 1 < y + 1`;;
  val it : int = -1
\end{verbatim}
}

\SEEALSO
aconv.

\ENDDOC
\DOC{ALPHA{\_}CONV}

\TYPE {\small\verb%ALPHA_CONV : term -> term -> thm%}\egroup

\SYNOPSIS
Renames the bound variable of a lambda-abstraction.

\DESCRIBE
If {\small\verb%`y`%} is a variable of type {\small\verb%ty%} and {\small\verb%`\x. t`%} is an abstraction in which
the bound variable {\small\verb%x%} also has type {\small\verb%ty%} and {\small\verb%y%} does not occur free in {\small\verb%t%},
then {\small\verb%ALPHA_CONV `y` `\x. t`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\x. t) = (\y. t[y/x])
\end{verbatim}
}

\FAILURE
Fails if the first argument is not a variable, the second is not an
abstraction, if the types of the new variable and the bound variable in the
abstraction differ, or if the new variable is already free in the body of the
abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ALPHA_CONV `y:num` `\x. x + 1`;;
  val it : thm = |- (\x. x + 1) = (\y. y + 1)

  # ALPHA_CONV `y:num` `\x. x + y`;;
  Exception: Failure "alpha: Invalid new variable".
\end{verbatim}
}

\SEEALSO
ALPHA, GEN_ALPHA_CONV.

\ENDDOC
\DOC{ALPHA}

\TYPE {\small\verb%ALPHA : term -> term -> thm%}\egroup

\SYNOPSIS
Proves equality of alpha-equivalent terms.

\DESCRIBE
When applied to a pair of terms {\small\verb%t1%} and {\small\verb%t1'%} which are
alpha-equivalent, {\small\verb%ALPHA%} returns the theorem {\small\verb%|- t1 = t1'%}.
{\par\samepage\setseps\small
\begin{verbatim}

   -------------  ALPHA `t1` `t1'`
    |- t1 = t1'
\end{verbatim}
}
\FAILURE
Fails unless the terms provided are alpha-equivalent.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ALPHA `!x:num. x = x` `!y:num. y = y`;;
  val it : thm = |- (!x. x = x) <=> (!y. y = y)

  # ALPHA `\w. w + z` `\z'. z' + z`;;
  val it : thm = |- (\w. w + z) = (\z'. z' + z)
\end{verbatim}
}

\SEEALSO
aconv, ALPHA_CONV, GEN_ALPHA_CONV.

\ENDDOC
\DOC{ANTE{\_}RES{\_}THEN}

\TYPE {\small\verb%ANTE_RES_THEN : thm_tactical%}\egroup

\SYNOPSIS
Resolves implicative assumptions with an antecedent.

\DESCRIBE
Given a theorem-tactic {\small\verb%ttac%} and a theorem {\small\verb%A |- t%}, the function
{\small\verb%ANTE_RES_THEN%} produces a tactic that attempts to match {\small\verb%t%} to the antecedent
of each implication
{\par\samepage\setseps\small
\begin{verbatim}
   Ai |- !x1...xn. ui ==> vi
\end{verbatim}
}
\noindent (where {\small\verb%Ai%} is just {\small\verb%!x1...xn. ui ==> vi%}) that occurs among the
assumptions of a goal. If the antecedent {\small\verb%ui%} of any implication matches {\small\verb%t%},
then an instance of {\small\verb%Ai u A |- vi%} is obtained by specialization of the
variables {\small\verb%x1%}, ..., {\small\verb%xn%} and type instantiation, followed by an application of
modus ponens.  Because all implicative assumptions are tried, this may result
in several modus-ponens consequences of the supplied theorem and the
assumptions.  Tactics are produced using {\small\verb%ttac%} from all these theorems, and
these tactics are applied in sequence to the goal.  That is,
{\par\samepage\setseps\small
\begin{verbatim}
   ANTE_RES_THEN ttac (A |- t) g
\end{verbatim}
}
\noindent has the effect of:
{\par\samepage\setseps\small
\begin{verbatim}
   MAP_EVERY ttac [A1 u A |- v1; ...; Am u A |- vm] g
\end{verbatim}
}
\noindent where the theorems {\small\verb%Ai u A |- vi%} are all the consequences that can
be drawn by a (single) matching modus-ponens inference from the implications
that occur among the assumptions of the goal {\small\verb%g%} and the supplied theorem
{\small\verb%A |- t%}.

\FAILURE
{\small\verb%ANTE_RES_THEN ttac (A |- t)%} fails when applied to a goal {\small\verb%g%} if any of the
tactics produced by {\small\verb%ttac (Ai u A |- vi)%}, where {\small\verb%Ai u A |- vi%} is the {\small\verb%i%}th
resolvent obtained from the theorem {\small\verb%A |- t%} and the assumptions of {\small\verb%g%}, fails
when applied in sequence to {\small\verb%g%}.

\SEEALSO
IMP_RES_THEN, MATCH_MP, MATCH_MP_TAC.

\ENDDOC
\DOC{ANTS{\_}TAC}

\TYPE {\small\verb%ANTS_TAC : tactic%}\egroup

\SYNOPSIS
Split off antecedent of antecedent of goal as a new subgoal.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
   A ?- (p ==> q) ==> r
  ======================= ANTS_TAC
   A ?- p   A ?- q ==> r
\end{verbatim}
}

\FAILURE
Fails unless the goal is of the specified form.

\USES
Convenient for focusing on assumptions of an implicational theorem that one
wants to use.

\SEEALSO
MP_TAC.

\ENDDOC
\DOC{apply}

\TYPE {\small\verb%apply : ('a, 'b) func -> 'a -> 'b%}\egroup

\SYNOPSIS
Applies a finite partial function, failing on undefined points.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If {\small\verb%f%} is a finite partial function and {\small\verb%x%} an argument, {\small\verb%apply f x%} tries
to apply {\small\verb%f%} to {\small\verb%x%} and fails if it is undefined.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # apply undefined 1;;
  Exception: Failure "apply".
  # apply (1 |=> 2) 1;;
  val it : int = 2
\end{verbatim}
}

\SEEALSO
|->, |=>, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{applyd}

\TYPE {\small\verb%applyd : ('a, 'b) func -> ('a -> 'b) -> 'a -> 'b%}\egroup

\SYNOPSIS
Applies a finite partial function, with a backup function for undefined points.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If {\small\verb%f%} is a finite partial function, {\small\verb%g%} a conventional function and {\small\verb%x%}
an argument, {\small\verb%tryapply f g x%} tries to apply {\small\verb%f%} to {\small\verb%x%} as with {\small\verb%apply f x%},
but instead returns {\small\verb%g x%} is {\small\verb%f%} is undefined on {\small\verb%x%}.

\FAILURE
Can only fail if the backup function fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # applyd undefined (fun x -> x) 1;;
  val it : int = 1
  # applyd (1 |=> 2) (fun x -> x) 1;;
  val it : int = 2
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{apply{\_}prover}

\TYPE {\small\verb%apply_prover : prover -> term -> thm%}\egroup

\SYNOPSIS
Apply a prover to a term.

\DESCRIBE
The HOL Light simplifier (e.g. as invoked by {\small\verb%SIMP_TAC%}) allows provers of type
{\small\verb%prover%} to be installed into simpsets, to automatically dispose of
side-conditions. These may maintain a state dynamically and augment it as more
theorems become available (e.g. a theorem {\small\verb%p |- p%} becomes available when
simplifying the consequent of an implication {\small\verb%`p ==> q`%}). In order to allow
maximal flexibility in the data structure used to maintain state, provers are
set up in an `object-oriented' style, where the context is part of the prover
function itself. A call {\small\verb%apply_prover p `tm`%} applies the prover with its
current context to attempt to prove the term {\small\verb%tm%}.

\FAILURE
The call {\small\verb%apply_prover p%} never fails, but it may fail to prove the term.

\USES
Mainly intended for users customizing the simplifier.

\COMMENTS
I learned of this ingenious trick for maintaining context from Don Syme, who
discovered it by reading some code written by Richard Boulton. I was told by
Simon Finn that there are similar ideas in the functional language literature
for simulating existential types.

\SEEALSO
augment, mk_prover, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{AP{\_}TERM}

\TYPE {\small\verb%AP_TERM : term -> thm -> thm%}\egroup

\SYNOPSIS
Applies a function to both sides of an equational theorem.

\DESCRIBE
When applied to a term {\small\verb%f%} and a theorem {\small\verb%A |- x = y%}, the
inference rule {\small\verb%AP_TERM%} returns the theorem {\small\verb%A |- f x = f y%}.
{\par\samepage\setseps\small
\begin{verbatim}
      A |- x = y
   ----------------  AP_TERM `f`
    A |- f x = f y
\end{verbatim}
}

\FAILURE
Fails unless the theorem is equational and the supplied term is a function
whose domain type is the same as the type of both sides of the equation.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_ADD_CONV `2 + 2`;;
  val it : thm = |- 2 + 2 = 4

  # AP_TERM `(+) 1` it;;
  val it : thm = |- 1 + 2 + 2 = 1 + 4
\end{verbatim}
}

\SEEALSO
AP_THM, MK_COMB.

\ENDDOC
\DOC{AP{\_}TERM{\_}TAC}

\TYPE {\small\verb%AP_TERM_TAC : tactic%}\egroup

\SYNOPSIS
Strips a function application from both sides of an equational goal.

\DESCRIBE
{\small\verb%AP_TERM_TAC%} reduces a goal of the form {\small\verb%A ?- f x = f y%} by stripping away
the function applications, giving the new goal {\small\verb%A ?- x = y%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- f x = f y
   ================  AP_TERM_TAC
     A ?- x = y
\end{verbatim}
}

\FAILURE
Fails unless the goal is equational, with both sides being applications
of the same function.

\SEEALSO
ABS_TAC, AP_TERM, AP_THM_TAC, BINOP_TAC, MK_COMB_TAC.

\ENDDOC
\DOC{AP{\_}THM}

\TYPE {\small\verb%AP_THM : thm -> term -> thm%}\egroup

\SYNOPSIS
Proves equality of equal functions applied to a term.

\DESCRIBE
When applied to a theorem {\small\verb%A |- f = g%} and a term {\small\verb%x%}, the inference
rule {\small\verb%AP_THM%} returns the theorem {\small\verb%A |- f x = g x%}.
{\par\samepage\setseps\small
\begin{verbatim}
      A |- f = g
   ----------------  AP_THM (A |- f = g) `x`
    A |- f x = g x
\end{verbatim}
}

\FAILURE
Fails unless the conclusion of the theorem is an equation, both sides
of which are functions whose domain type is the same as that of the
supplied term.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_RULE[GSYM FUN_EQ_THM] ADD1;;
  val it : thm = |- SUC = (\m. m + 1)

  # AP_THM it `11`;;
  val it : thm = |- SUC 11 = (\m. m + 1) 11
\end{verbatim}
}

\SEEALSO
AP_TERM, ETA_CONV, MK_COMB.

\ENDDOC
\DOC{AP{\_}THM{\_}TAC}

\TYPE {\small\verb%AP_THM_TAC : tactic%}\egroup

\SYNOPSIS
Strips identical operands from functions on both sides of an equation.

\DESCRIBE
When applied to a goal of the form {\small\verb%A ?- f x = g x%}, the tactic {\small\verb%AP_THM_TAC%}
strips away the operands of the function application:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- f x = g x
   ================  AP_THM_TAC
      A ?- f = g
\end{verbatim}
}

\FAILURE
Fails unless the goal has the above form, namely an equation both sides of
which consist of function applications to the same argument.

\SEEALSO
ABS_TAC, AP_TERM_TAC, AP_THM, BINOP_TAC, MK_COMB_TAC.

\ENDDOC
\DOC{ARITH{\_}RULE}

\TYPE {\small\verb%ARITH_RULE : term -> thm%}\egroup

\SYNOPSIS
Automatically proves natural number arithmetic theorems needing basic
rearrangement and linear inequality reasoning only.

\DESCRIBE
The function {\small\verb%ARITH_RULE%} can automatically prove natural number theorems using
basic algebraic normalization and inequality reasoning. For nonlinear
equational reasoning use {\small\verb%NUM_RING%}.

\FAILURE
Fails if the term is not boolean or if it cannot be proved using the basic
methods employed, e.g. requiring nonlinear inequality reasoning.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ARITH_RULE `x = 1 ==> y <= 1 \/ x < y`;;
  val it : thm = |- x = 1 ==> y <= 1 \/ x < y

  # ARITH_RULE `x <= 127 ==> ((86 * x) DIV 256 = x DIV 3)`;;
  val it : thm = |- x <= 127 ==> (86 * x) DIV 256 = x DIV 3

  # ARITH_RULE
     `2 * a * b EXP 2 <= b * a * b ==> (SUC c - SUC(a * b * b) <= c)`;;
  val it : thm =
    |- 2 * a * b EXP 2 <= b * a * b ==> SUC c - SUC (a * b * b) <= c
\end{verbatim}
}

\USES
Disposing of elementary arithmetic goals.

\SEEALSO
ARITH_TAC, INT_ARITH, NUM_RING, REAL_ARITH, REAL_FIELD, REAL_RING.

\ENDDOC
\DOC{ARITH{\_}TAC}

\TYPE {\small\verb%ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Tactic for proving arithmetic goals needing basic rearrangement and linear
inequality reasoning only.

\DESCRIBE
{\small\verb%ARITH_TAC%} will automatically prove goals that require basic algebraic
normalization and inequality reasoning over the natural numbers. For nonlinear
equational reasoning use {\small\verb%NUM_RING%} and derivatives.

\FAILURE
Fails if the automated methods do not suffice.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `1 <= x /\ x <= 3 ==> x = 1 \/ x = 2 \/ x = 3`;;
  Warning: Free variables in goal: x
  val it : goalstack = 1 subgoal (1 total)

  `1 <= x /\ x <= 3 ==> x = 1 \/ x = 2 \/ x = 3`

  # e ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Solving basic arithmetic goals.

\SEEALSO
ARITH_RULE, ASM_ARITH_TAC, INT_ARITH_TAC, NUM_RING, REAL_ARITH_TAC.

\ENDDOC
\DOC{ASM}

\TYPE {\small\verb%ASM : (thm list -> tactic) -> thm list -> tactic%}\egroup

\SYNOPSIS
Augments a tactic's theorem list with the assumptions.

\DESCRIBE
If {\small\verb%tac%} is a tactic that expects a list of theorems as its arguments, e.g.
{\small\verb%MESON_TAC%}, {\small\verb%REWRITE_TAC%} or {\small\verb%SET_TAC%}, then {\small\verb%ASM tac%} converts it to a tactic
where that list is augmented by the goal's assumptions.

\FAILURE
Never fails (though the resulting tactic may do).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
The inbuilt {\small\verb%ASM_REWRITE_TAC%} is in fact defined as just {\small\verb%ASM REWRITE_TAC%}.
\end{verbatim}
}

\SEEALSO
ASSUM_LIST, FREEZE_THEN, HYP, MESON_TAC, REWRITE_TAC, SET_TAC.

\ENDDOC
\DOC{ASM{\_}ARITH{\_}TAC}

\TYPE {\small\verb%ASM_ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Tactic for proving arithmetic goals needing basic rearrangement and linear
inequality reasoning only, using assumptions

\DESCRIBE
{\small\verb%ASM_ARITH_TAC%} will automatically prove goals that require basic algebraic
normalization and inequality reasoning over the natural numbers. For nonlinear
equational reasoning use {\small\verb%NUM_RING%} and derivatives. Unlike plain {\small\verb%ARITH_TAC%},
{\small\verb%ASM_ARITH_TAC%} uses any assumptions that are not universally quantified as
additional hypotheses.

\FAILURE
Fails if the automated methods do not suffice.

\EXAMPLE
This example illustrates how {\small\verb%ASM_ARITH_TAC%} uses assumptions while {\small\verb%ARITH_TAC%}
does not. Of course, this is for illustration only: plain {\small\verb%ARITH_TAC%} would
solve the entire goal before application of {\small\verb%STRIP_TAC%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `1 <= 6 * x /\ 2 * x <= 3 ==> x = 1`;;
  Warning: Free variables in goal: x
  val it : goalstack = 1 subgoal (1 total)

  `1 <= 6 * x /\ 2 * x <= 3 ==> x = 1`

  # e STRIP_TAC;;
  val it : goalstack = 1 subgoal (1 total)

    0 [`1 <= 6 * x`]
    1 [`2 * x <= 3`]

  `x = 1`

  # e ARITH_TAC;;
  Exception: Failure "linear_ineqs: no contradiction".
  # e ASM_ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Solving basic arithmetic goals.

\SEEALSO
ARITH_RULE, ARITH_TAC, INT_ARITH_TAC, NUM_RING, REAL_ARITH_TAC.

\ENDDOC
\DOC{ASM{\_}CASES{\_}TAC}

\TYPE {\small\verb%ASM_CASES_TAC : term -> tactic%}\egroup

\SYNOPSIS
Given a term, produces a case split based on whether or not that
term is true.

\DESCRIBE
Given a term {\small\verb%u%}, {\small\verb%ASM_CASES_TAC%} applied to a goal produces two
subgoals, one with {\small\verb%u%} as an assumption and one with {\small\verb%~u%}:
{\par\samepage\setseps\small
\begin{verbatim}
               A ?-  t
   ================================  ASM_CASES_TAC `u`
    A u {u} ?- t   A u {~u} ?- t
\end{verbatim}
}

\FAILURE
Fails if {\small\verb%u%} does not have boolean type.

\EXAMPLE
The tactic {\small\verb%ASM_CASES_TAC `&0 <= u`%} can be used to produce a case analysis
on {\small\verb%`&0 <= u`%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `&0 <= (u:real) pow 2`;;
  Warning: Free variables in goal: u
  val it : goalstack = 1 subgoal (1 total)

  `&0 <= u pow 2`

  # e(ASM_CASES_TAC `&0 <= u`);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`~(&0 <= u)`]

  `&0 <= u pow 2`

   0 [`&0 <= u`]

  `&0 <= u pow 2`
\end{verbatim}
}

\USES
Performing a case analysis according to whether a given term is true or false.

\SEEALSO
BOOL_CASES_TAC, COND_CASES_TAC, ITAUT, DISJ_CASES_TAC, STRUCT_CASES_TAC, TAUT.

\ENDDOC
\DOC{ASM{\_}FOL{\_}TAC}

\TYPE {\small\verb%ASM_FOL_TAC : (string * thm) list * term -> goalstate%}\egroup

\SYNOPSIS
Fix up function arities for first-order proof search.

\DESCRIBE
This function attempts to make the assumptions of a goal more `first-order'.
Functions that are not consistently used with the same arity, e.g. a function
{\small\verb%f%} that is sometimes applied {\small\verb%f(a)%} and sometimes used as an argument to other
functions, {\small\verb%g(f)%}, will be identified. Applications of the function will then
be modified by the introduction of the identity function {\small\verb%I%} (which can be
thought of later as binary `function application') so that {\small\verb%f(a)%} becomes
{\small\verb%I f a%}. This gives a more natural formulation as a prelude to traditional
first-order proof search.

\FAILURE
Never fails.

\COMMENTS
This function is not intended for general use, but is part of the initial
normalization in {\small\verb%MESON%} and {\small\verb%MESON_TAC%}.

\SEEALSO
MESON, MESON_TAC.

\ENDDOC
\DOC{ASM{\_}INT{\_}ARITH{\_}TAC}

\TYPE {\small\verb%ASM_INT_ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Attempt to prove goal using basic algebra and linear arithmetic over the
integers.

\DESCRIBE
The tactic {\small\verb%ASM_INT_ARITH_TAC%} is the tactic form of {\small\verb%INT_ARITH%}. Roughly
speaking, it will automatically prove any formulas over the reals that are
effectively universally quantified and can be proved valid by algebraic
normalization and linear equational and inequality reasoning. See {\small\verb%REAL_ARITH%}
for more information about the algorithm used and its scope. Unlike plain
{\small\verb%INT_ARITH_TAC%}, {\small\verb%ASM_INT_ARITH_TAC%} uses any assumptions that are not
universally quantified as additional hypotheses.

\FAILURE
Fails if the goal is not in the subset solvable by these means, or is not
valid.

\EXAMPLE
This example illustrates how {\small\verb%ASM_INT_ARITH_TAC%} uses assumptions while
{\small\verb%INT_ARITH_TAC%} does not. Of course, this is for illustration only: plain
{\small\verb%INT_ARITH_TAC%} would solve the entire goal before application of {\small\verb%STRIP_TAC%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x y:int. x <= y /\ &2 * y <= &2 * x + &1 ==> x = y`;;
  val it : goalstack = 1 subgoal (1 total)

  `!x y. x <= y /\ &2 * y <= &2 * x + &1 ==> x = y`

  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

    0 [`x <= y`]
    1 [`&2 * y <= &2 * x + &1`]

  `x = y`

  # e INT_ARITH_TAC;;
  Exception: Failure "linear_ineqs: no contradiction".
  # e ASM_INT_ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ARITH_TAC, INT_ARITH, INT_ARITH_TAC, REAL_ARITH_TAC.

\ENDDOC
\DOC{ASM{\_}MESON{\_}TAC}

\TYPE {\small\verb%ASM_MESON_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic using assumptions of goal.

\DESCRIBE
A call to {\small\verb%ASM_MESON_TAC[theorems]%} will attempt to establish the goal using
pure first-order reasoning, taking {\small\verb%theorems%} and the assumptions of the goal
as the starting-point. It will usually either solve the goal completely or run
for an infeasible length of time before terminating, but it may sometimes fail
quickly. For more details, see {\small\verb%MESON%} or {\small\verb%MESON_TAC%}.

\FAILURE
Fails if the goal is unprovable within the search bounds, though not
necessarily in a feasible amount of time.

\SEEALSO
ASM_METIS_TAC, GEN_MESON_TAC, MESON, MESON_TAC.

\ENDDOC
\DOC{ASM{\_}METIS{\_}TAC}

\TYPE {\small\verb%ASM_METIS_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic using assumptions of goal.

\DESCRIBE
A call to {\small\verb%ASM_METIS_TAC[theorems]%} will attempt to establish the goal using
pure first-order reasoning, taking {\small\verb%theorems%} and the assumptions of the goal
as the starting-point. It will usually either solve the goal completely or run
for an infeasible length of time before terminating, but it may sometimes fail
quickly. For more details, see {\small\verb%METIS%} or {\small\verb%METIS_TAC%}.

\FAILURE
Fails if the goal is unprovable within the search bounds.

\SEEALSO
ASM_MESON_TAC, METIS, METIS_TAC.

\ENDDOC
\DOC{ASM{\_}REAL{\_}ARITH{\_}TAC}

\TYPE {\small\verb%ASM_REAL_ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Attempt to prove goal using basic algebra and linear arithmetic over the reals.

\DESCRIBE
The tactic {\small\verb%ASM_REAL_ARITH_TAC%} is the tactic form of {\small\verb%REAL_ARITH%}. Roughly
speaking, it will automatically prove any formulas over the reals that are
effectively universally quantified and can be proved valid by algebraic
normalization and linear equational and inequality reasoning. See {\small\verb%REAL_ARITH%}
for more information about the algorithm used and its scope. Unlike plain
{\small\verb%REAL_ARITH_TAC%}, {\small\verb%ASM_REAL_ARITH_TAC%} uses any assumptions that are not
universally quantified as additional hypotheses.

\FAILURE
Fails if the goal is not in the subset solvable by these means, or is not
valid.

\EXAMPLE
This example illustrates how {\small\verb%ASM_REAL_ARITH_TAC%} uses assumptions while
{\small\verb%REAL_ARITH_TAC%} does not. Of course, this is for illustration only: plain
{\small\verb%REAL_ARITH_TAC%} would solve the entire goal before application of {\small\verb%STRIP_TAC%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x y z:real. abs(x) <= y ==> abs(x - z) <= abs(y + abs(z))`;;
  val it : goalstack = 1 subgoal (1 total)

  `!x y z. abs x <= y ==> abs (x - z) <= abs (y + abs z)`

  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

    0 [`abs x <= y`]

  `abs (x - z) <= abs (y + abs z)`

  # e REAL_ARITH_TAC;;
  Exception: Failure "linear_ineqs: no contradiction".
  # e ASM_REAL_ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\COMMENTS
For nonlinear equational reasoning, use {\small\verb%CONV_TAC REAL_RING%} or {\small\verb%CONV_TAC
REAL_FIELD%}. For nonlinear inequality reasoning, there are no powerful rules
built into HOL Light, but the additional derived rules defined in
{\small\verb%Examples/sos.ml%} and {\small\verb%Rqe/make.ml%} may be useful.

\SEEALSO
ARITH_TAC, INT_ARITH_TAC, REAL_ARITH, REAL_ARITH_TAC, REAL_FIELD, REAL_RING.

\ENDDOC
\DOC{ASM{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%ASM_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem including built-in rewrites and the theorem's assumptions.

\DESCRIBE
{\small\verb%ASM_REWRITE_RULE%} rewrites with the tautologies in {\small\verb%basic_rewrites%},
the given list of theorems, and the set of hypotheses of the theorem. All
hypotheses are used. No ordering is specified among applicable rewrites.
Matching subterms are searched for recursively, starting with the entire term
of the conclusion and stopping when no rewritable expressions remain.  For more
details about the rewriting process, see {\small\verb%GEN_REWRITE_RULE%}. To avoid using the
set of basic tautologies, see {\small\verb%PURE_ASM_REWRITE_RULE%}.

\FAILURE
{\small\verb%ASM_REWRITE_RULE%} does not fail, but may result in divergence. To
prevent divergence where it would occur, {\small\verb%ONCE_ASM_REWRITE_RULE%} can be
used.

\SEEALSO
GEN_REWRITE_RULE, ONCE_ASM_REWRITE_RULE,
PURE_ASM_REWRITE_RULE, PURE_ONCE_ASM_REWRITE_RULE, REWRITE_RULE.

\ENDDOC
\DOC{ASM{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%ASM_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal including built-in rewrites and the goal's assumptions.

\DESCRIBE
{\small\verb%ASM_REWRITE_TAC%} generates rewrites with the tautologies in {\small\verb%basic_rewrites%},
the set of assumptions, and a list of theorems supplied by the user. These are
applied top-down and recursively on the goal, until no more matches are found.
The order in which the set of rewrite equations is applied is an implementation
matter and the user should not depend on any ordering. Rewriting strategies are
described in more detail under {\small\verb%GEN_REWRITE_TAC%}. For omitting the common
tautologies, see the tactic {\small\verb%PURE_ASM_REWRITE_TAC%}.

\FAILURE
{\small\verb%ASM_REWRITE_TAC%} does not fail, but it can diverge in certain
situations. For rewriting to a limited depth, see
{\small\verb%ONCE_ASM_REWRITE_TAC%}. The resulting tactic may not be valid if the
applicable replacement introduces new assumptions into the theorem
eventually proved.

\EXAMPLE
The use of assumptions in rewriting, specially when they are not in an
obvious equational form, is illustrated below:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `P ==> (P /\ Q /\ R <=> R /\ Q /\ P)`;;
  Warning: Free variables in goal: P, Q, R
  val it : goalstack = 1 subgoal (1 total)

  `P ==> (P /\ Q /\ R <=> R /\ Q /\ P)`

  # e DISCH_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`P`]

  `P /\ Q /\ R <=> R /\ Q /\ P`

  # e(ASM_REWRITE_TAC[]);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`P`]

  `Q /\ R <=> R /\ Q`
\end{verbatim}
}

\SEEALSO
basic_rewrites, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, ONCE_REWRITE_TAC,
PURE_ASM_REWRITE_TAC, PURE_ONCE_ASM_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC,
SUBST_ALL_TAC, SUBST1_TAC.

\ENDDOC
\DOC{ASM{\_}SIMP{\_}TAC}

\TYPE {\small\verb%ASM_SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Perform simplification of goal by conditional contextual rewriting using
assumptions and built-in simplifications.

\DESCRIBE
A call to {\small\verb%ASM_SIMP_TAC[theorems]%} will apply conditional contextual rewriting
with {\small\verb%theorems%} and the current assumptions of the goal to the goal's
conclusion, as well as the default simplifications (see {\small\verb%basic_rewrites%} and
{\small\verb%basic_convs%}). For more details on this kind of rewriting, see {\small\verb%SIMP_CONV%}. If
the extra generality of contextual conditional rewriting is not needed,
{\small\verb%REWRITE_TAC%} is usually more efficient.

\FAILURE
Never fails, but may loop indefinitely.

\SEEALSO
ASM_REWRITE_TAC, SIMP_CONV, SIMP_TAC, REWRITE_TAC.
\ENDDOC
\DOC{assoc}

\TYPE {\small\verb%assoc : 'a -> ('a * 'b) list -> 'b%}\egroup

\SYNOPSIS
Searches a list of pairs for a pair whose first component equals a specified
value.

\DESCRIBE
{\small\verb%assoc x [(x1,y1);...;(xn,yn)]%} returns the first {\small\verb%yi%} in the list such
that {\small\verb%xi%} equals {\small\verb%x%}.

\FAILURE
Fails if no matching pair is found. This will always be the case if the list
is empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # assoc 2 [1,4; 3,2; 2,5; 2,6];;
  val it : int = 5
\end{verbatim}
}
\SEEALSO
rev_assoc, find, mem, tryfind, exists, forall.

\ENDDOC
\DOC{assocd}

\TYPE {\small\verb%assocd : 'a -> ('a * 'b) list -> 'b -> 'b%}\egroup

\SYNOPSIS
Looks up item in association list taking default in case of failure.

\DESCRIBE
The call {\small\verb%assocd x [x1,y1; ...; xn,yn] y%} returns the first {\small\verb%yi%} in the list
where the corresponding {\small\verb%xi%} is the same as {\small\verb%x%}. If there is no such item, it
returns the value {\small\verb%y%}. This is similar to {\small\verb%assoc%} except that the latter will
fail rather than take a default.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # assocd 2 [1,2; 2,4; 3,6] (-1);;
  val it : int = 4
  # assocd 4 [1,2; 2,4; 3,6] (-1);;
  val it : int = -1
\end{verbatim}
}

\USES
Simple lookup without exception handling.

\SEEALSO
assoc, rev_assocd.

\ENDDOC
\DOC{ASSOC{\_}CONV}

\TYPE {\small\verb%ASSOC_CONV : thm -> term -> thm%}\egroup

\SYNOPSIS
Right-associates a term with respect to an associative binary operator.

\DESCRIBE
The conversion {\small\verb%ASSOC_CONV%} expects a theorem asserting that a certain binary
operator is associative, in the standard form (with optional universal
quantifiers):
{\par\samepage\setseps\small
\begin{verbatim}
  x op (y op z) = (x op y) op z
\end{verbatim}
}
It is then applied to a term, and will right-associate any toplevel
combinations built up from the operator {\small\verb%op%}. Note that if {\small\verb%op%} is polymorphic,
the type instance of the theorem needs to be the same as in the term to which
it is applied.

\FAILURE
May fail if the theorem is malformed. On application to the term, it never
fails, but returns a reflexive theorem when itis inapplicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ASSOC_CONV ADD_ASSOC `((1 + 2) + 3) + (4 + 5) + (6 + 7)`;;
  val it : thm = |- ((1 + 2) + 3) + (4 + 5) + 6 + 7 = 1 + 2 + 3 + 4 + 5 + 6 + 7

  # ASSOC_CONV CONJ_ASSOC `((p /\ q) /\ (r /\ s)) /\ t`;;
  val it : thm = |- ((p /\ q) /\ r /\ s) /\ t <=> p /\ q /\ r /\ s /\ t
\end{verbatim}
}

\SEEALSO
AC, CNF_CONV, CONJ_ACI_RULE, DISJ_ACI_RULE, DNF_CONV.

\ENDDOC
\DOC{ASSUME}

\TYPE {\small\verb%ASSUME : term -> thm%}\egroup

\SYNOPSIS
Introduces an assumption.

\DESCRIBE
When applied to a term {\small\verb%t%}, which must have type {\small\verb%bool%}, the inference rule
{\small\verb%ASSUME%} returns the theorem {\small\verb%t |- t%}.
{\par\samepage\setseps\small
\begin{verbatim}
   --------  ASSUME `t`
    t |- t
\end{verbatim}
}
\FAILURE
Fails unless the term {\small\verb%t%} has type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ASSUME `p /\ q`;;
  val it : thm = p /\ q |- p /\ q
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
ADD_ASSUM, REFL.

\ENDDOC
\DOC{ASSUME{\_}TAC}

\TYPE {\small\verb%ASSUME_TAC : thm_tactic%}\egroup

\SYNOPSIS
Adds an assumption to a goal.

\DESCRIBE
Given a theorem {\small\verb%th%} of the form {\small\verb%A' |- u%}, and a goal, {\small\verb%ASSUME_TAC th%}
adds {\small\verb%u%} to the assumptions of the goal.
{\par\samepage\setseps\small
\begin{verbatim}
         A ?- t
    ==============  ASSUME_TAC (A' |- u)
     A u {u} ?- t
\end{verbatim}
}
\noindent Note that unless {\small\verb%A'%} is a subset of {\small\verb%A%}, this tactic is invalid. The
new assumption is unlabelled; for a named assumption use {\small\verb%LABEL_TAC%}.

\FAILURE
Never fails.

\EXAMPLE
One can add an external theorem as an assumption if desired, for example so
that {\small\verb%ASM_REWRITE_TAC[]%} will automatically apply it. But usually the theorem
is derived from some theorem-tactical, e.g. by discharging the antecedent of an
implication or doing forward inference on another assumption. For example iff
faced with the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `0 = x ==> f(2 * x) = f(x * f(x))`;;
\end{verbatim}
}
\noindent one might not want to just do {\small\verb%DISCH_TAC%} or {\small\verb%STRIP_TAC%} because the
assumption will be {\small\verb%`0 = x`%}. One can swap it first then put it on the
assumptions by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN(ASSUME_TAC o SYM));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`x = 0`]

  `f (2 * x) = f (x * f x)`
\end{verbatim}
}
\noindent after which the goal can very easily be solved:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_REWRITE_TAC[MULT_CLAUSES]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Useful as a parameter to various theorem-tacticals such as {\small\verb%X_CHOOSE_THEN%},
{\small\verb%DISCH_THEN%} etc. when it is simply desired to add the theorem that has been
deduced to the assumptions rather than used further at once.

\SEEALSO
ACCEPT_TAC, DESTRUCT_TAC, LABEL_TAC, STRIP_ASSUME_TAC.

\ENDDOC
\DOC{ASSUM{\_}LIST}

\TYPE {\small\verb%ASSUM_LIST : (thm list -> tactic) -> tactic%}\egroup

\SYNOPSIS
Applies a tactic generated from the goal's assumption list.

\DESCRIBE
When applied to a function of type {\small\verb%thm list -> tactic%} and a goal,
{\small\verb%ASSUM_LIST%} constructs a tactic by applying {\small\verb%f%} to a list of {\small\verb%ASSUME%}d
assumptions of the goal, then applies that tactic to the goal.
{\par\samepage\setseps\small
\begin{verbatim}
   ASSUM_LIST f ({A1;...;An} ?- t)
         = f [A1 |- A1; ... ; An |- An] ({A1;...;An} ?- t)
\end{verbatim}
}
\FAILURE
Fails if the function fails when applied to the list of {\small\verb%ASSUME%}d assumptions,
or if the resulting tactic fails when applied to the goal.

\COMMENTS
There is nothing magical about {\small\verb%ASSUM_LIST%}: the same effect can usually be
achieved just as conveniently by using {\small\verb%ASSUME a%} wherever the
assumption {\small\verb%a%} is needed. If {\small\verb%ASSUM_LIST%} is used, it is extremely unwise to
use a function which selects elements from its argument list by number, since
the ordering of assumptions should not be relied on.

\EXAMPLE
The tactic:
{\par\samepage\setseps\small
\begin{verbatim}
   ASSUM_LIST(MP_TAC o end_itlist CONJ)
\end{verbatim}
}
\noindent adds a conjunction of all assumptions as an antecedent of a goal.

\USES
Making more careful use of the assumption list than simply rewriting.

\SEEALSO
ASM_REWRITE_TAC, EVERY_ASSUM, POP_ASSUM, POP_ASSUM_LIST, REWRITE_TAC.

\ENDDOC
\DOC{atleast}

\TYPE {\small\verb%atleast : int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Parses at least a given number of successive items using given parser.

\DESCRIBE
If {\small\verb%p%} is a parser and {\small\verb%n%} an integer, {\small\verb%atleast n p%} is a new parser
that attempts to parse at least {\small\verb%n%} successive items using parser {\small\verb%p%} and fails
otherwise. Unless {\small\verb%n%} is positive, this is equivalent to {\small\verb%many p%}.

\FAILURE
The call to {\small\verb%atleast n p%} itself never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{atoms}

\TYPE {\small\verb%atoms : term -> term list%}\egroup

\SYNOPSIS
Returns a list of the atomic propositions in a Boolean term

\DESCRIBE
When applied to a term of Boolean type, {\small\verb%atoms%} returns a list of the atomic
fomulas, considering the term as a propositional formula built up recursively
with negation, conjunction, disjunction, implication and logical equivalence,
treating all other subterms (e.g. quantified ones) as atomic.

\FAILURE
Fails if the term does not have type {\small\verb%:bool%}.

\EXAMPLE
Here the atomic formulas are simply variables:
{\par\samepage\setseps\small
\begin{verbatim}
  # atoms `p \/ q ==> r`;;
  val it : term list = [`r`; `p`; `q`]
\end{verbatim}
}
\noindent while here the atomic formulas are composite:
{\par\samepage\setseps\small
\begin{verbatim}
  # atoms `x < 1 \/ x > 1 ==> ~(x = 1)`;;
  val it : term list = [`x < 1`; `x > 1`; `x = 1`]
\end{verbatim}
}

\SEEALSO
frees, freesl, free_in, thm_frees, variables.

\ENDDOC
\DOC{aty}

\TYPE {\small\verb%aty : hol_type%}\egroup

\SYNOPSIS
The type variable {\small\verb%`:A`%}.

\DESCRIBE
This name is bound to the HOL type {\small\verb%:A%}.

\FAILURE
Not applicable.

\USES
Exploiting the very common type variable {\small\verb%:A%} inside derived rules (e.g. an
instantiation list for {\small\verb%inst%} or {\small\verb%type_subst%}) without the inefficiency or
inconvenience of calling a quotation parser or explicit constructor.

\SEEALSO
bty, bool_ty.

\ENDDOC
\DOC{augment}

\TYPE {\small\verb%augment : prover -> thm list -> prover%}\egroup

\SYNOPSIS
Augments a prover's context with new theorems.

\DESCRIBE
The HOL Light simplifier (e.g. as invoked by {\small\verb%SIMP_TAC%}) allows provers of type
{\small\verb%prover%} to be installed into simpsets, to automatically dispose of
side-conditions. These may maintain a state dynamically and augment it as more
theorems become available (e.g. a theorem {\small\verb%p |- p%} becomes available when
simplifying the consequent of an implication {\small\verb%`p ==> q`%}). In order to allow
maximal flexibility in the data structure used to maintain state, provers are
set up in an `object-oriented' style, where the context is part of the prover
function itself. A call {\small\verb%augment p thl%} maps a prover {\small\verb%p%} to a new prover with
theorems {\small\verb%thl%} added to the initial state.

\FAILURE
Never fails unless the prover is abnormal.

\USES
This is mostly for experts wishing to customize the simplifier.

\COMMENTS
I learned of this ingenious trick for maintaining context from Don Syme, who
discovered it by reading some code written by Richard Boulton. I was told by
Simon Finn that there are similar ideas in the functional language literature
for simulating existential types.

\SEEALSO
apply_prover, mk_prover, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{AUGMENT{\_}SIMPSET}

\TYPE {\small\verb%AUGMENT_SIMPSET : thm -> simpset -> simpset%}\egroup

\SYNOPSIS
Augment context of a simpset with a list of theorems.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset'. Given a list of theorems {\small\verb%thl%}
and a simpset {\small\verb%ss%}, the call {\small\verb%AUGMENT_SIMPSET thl ss%} augments the state of the
simpset, adding the theorems as new rewrite rules and also making any
provers in the simpset process the new context appropriately.

\FAILURE
Never fails unless some of the simpset functions are ill-formed.

\USES
Mostly for experts wishing to customize the simplifier.

\SEEALSO
augment, SIMP_CONV.

\ENDDOC
\DOC{axioms}

\TYPE {\small\verb%axioms : unit -> thm list%}\egroup

\SYNOPSIS
Returns the current set of axioms.

\DESCRIBE
A call {\small\verb%axioms()%} returns the current list of axioms.

\FAILURE
Never fails.

\EXAMPLE
Under normal circumstances, the list of axioms will be as follows, containing
the axioms of infinity, choice and extensionality.
{\par\samepage\setseps\small
\begin{verbatim}
  # axioms();;
  val it : thm list =
    [|- ?f. ONE_ONE f /\ ~ONTO f; |- !P x. P x ==> P ((@) P);
     |- !t. (\x. t x) = t]
\end{verbatim}
}
If other axioms are used, the consistency of the resulting theory cannot be
guaranteed. However, new definitions and type definitions are always safe and
are not considered as true `axioms'.

\SEEALSO
define, definitions, new_axiom, new_definition, the_definitions.

\ENDDOC
\DOC{b}

\TYPE {\small\verb%b : unit -> goalstack%}\egroup

\SYNOPSIS
Restores the proof state, undoing the effects of a previous expansion.

\DESCRIBE
The function {\small\verb%b%} is part of the subgoal package.  It allows backing up
from the last state change (caused by calls to {\small\verb%e%}, {\small\verb%g%}, {\small\verb%r%}, {\small\verb%set_goal%} etc.)
The package maintains a backup list of previous proof states. A call to {\small\verb%b%}
restores the state to the previous state (which was on top of the backup list).

\FAILURE
The function {\small\verb%b%} will fail if the backup list is empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3]`

  # e CONJ_TAC;;
  val it : goalstack = 2 subgoals (2 total)

  `TL [1; 2; 3] = [2; 3]`

  `HD [1; 2; 3] = 1`

  # b();;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3]`
\end{verbatim}
}

\USES
Back tracking in a goal-directed proof to undo errors or try different tactics.

\SEEALSO
e, er, g, p, r, set_goal, top_goal, top_thm.

\ENDDOC
\DOC{basic{\_}congs}

\TYPE {\small\verb%basic_congs : unit -> thm list%}\egroup

\SYNOPSIS
Lists the congruence rules used by the simplifier.

\DESCRIBE
The HOL Light simplifier (as invoked by {\small\verb%SIMP_TAC%} etc.) uses congruence rules
to determine how it uses context when descending through a term. These are
essentially theorems showing how to decompose one equality to a series of other
inequalities in context. A call to {\small\verb%basic_congs()%} returns those congruences
that are built into the system.

\FAILURE
Never fails.

\EXAMPLE
Here is the effect in HOL Light's initial state:
{\par\samepage\setseps\small
\begin{verbatim}
  # basic_congs();;
  val it : thm list =
    [|- (!x. x IN s ==> f x = g x) ==> sum s (\i. f i) = sum s g;
     |- (!i. a <= i /\ i <= b ==> f i = g i)
        ==> sum (a..b) (\i. f i) = sum (a..b) g;
     |- (!x. p x ==> f x = g x) ==> sum {y | p y} (\i. f i) = sum {y | p y} g;
     |- (!x. x IN s ==> f x = g x) ==> nsum s (\i. f i) = nsum s g;
     |- (!i. a <= i /\ i <= b ==> f i = g i)
        ==> nsum (a..b) (\i. f i) = nsum (a..b) g;
     |- (!x. p x ==> f x = g x) ==> nsum {y | p y} (\i. f i) = nsum {y | p y} g;
     |- (g <=> g')
        ==> (g' ==> t = t')
        ==> (~g' ==> e = e')
        ==> (if g then t else e) = (if g' then t' else e');
     |- (p <=> p') ==> (p' ==> (q <=> q')) ==> (p ==> q <=> p' ==> q')]
\end{verbatim}
}

\SEEALSO
extend_basic_congs, set_basic_congs, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{basic{\_}convs}

\TYPE {\small\verb%basic_convs : unit -> (string * (term * conv)) list%}\egroup

\SYNOPSIS
List the current default conversions used in rewriting and simplification.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. A call to {\small\verb%basic_convs()%}
returns the current set of conversions.

\FAILURE
Never fails.

\EXAMPLE
In the default HOL Light state the only conversions are for generalized beta
reduction and the reduction of pattern-matching constructs such as
{\small\verb%match...with%}. All the other default simplifications are done by rewrite
rules.
{\par\samepage\setseps\small
\begin{verbatim}
  # basic_convs();;
  val it : (string * (term * conv)) list =
    [("FUN_ONEPATTERN_CONV", (`_FUNCTION (\y z. P y z) x`, <fun>));
     ("MATCH_ONEPATTERN_CONV", (`_MATCH x (\y z. P y z)`, <fun>));
     ("FUN_SEQPATTERN_CONV", (`_FUNCTION (_SEQPATTERN r s) x`, <fun>));
     ("MATCH_SEQPATTERN_CONV", (`_MATCH x (_SEQPATTERN r s)`, <fun>));
     ("GEN_BETA_CONV", (`GABS (\a. b) c`, <fun>))]
\end{verbatim}
}

\SEEALSO
basic_rewrites, extend_basic_convs, set_basic_convs.

\ENDDOC
\DOC{basic{\_}net}

\TYPE {\small\verb%basic_net : unit -> gconv net%}\egroup

\SYNOPSIS
Returns the term net used to optimize access to default rewrites and
conversions.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. Internally, these are
maintained in a term net (see {\small\verb%enter%} and {\small\verb%lookup%} for more information), and a
call to {\small\verb%basic_net()%} returns that net.

\FAILURE
Never fails.

\USES
Only useful for those who are delving deep into the implementation of
rewriting.

\SEEALSO
basic_convs, basic_rewrites, enter, lookup.

\ENDDOC
\DOC{basic{\_}prover}

\TYPE {\small\verb%basic_prover : (simpset -> 'a -> term -> thm) -> simpset -> 'a -> term -> thm%}\egroup

\SYNOPSIS
The basic prover use function used in the simplifier.

\DESCRIBE
The HOL Light simplifier (e.g. as invoked by {\small\verb%SIMP_TAC%}) allows provers of type
{\small\verb%prover%} to be installed into simpsets, to automatically dispose of
side-conditions. There is another component of the simpset that controls how
these are applied to unproven subgoals arising in simplification. The
{\small\verb%basic_prover%} function, which is used in all the standard simpsets, simply
tries to simplify the goals with the rewrites as far as possible, then tries
the provers one at a time on the resulting subgoals till one succeeds.

\FAILURE
Never fails, though the later application to a term may fail to prove it.

\SEEALSO
mk_prover, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{basic{\_}rectype{\_}net}

\TYPE {\small\verb%basic_rectype_net : (int * (term -> thm)) net ref%}\egroup

\SYNOPSIS
Net of injectivity and distinctness properties for recursive type constructors.

\DESCRIBE
HOL Light maintains a net of theorems used to simplify equations between
elements of recursive datatypes; essentially these include injectivity and
distinctness, e.g. {\small\verb%CONS_11%} and {\small\verb%NOT_CONS_NIL%} for lists. This net is used in
some situations where such things need to be proved automatically, notably in
{\small\verb%define%}. A call to {\small\verb%basic_rectype_net()%} returns that net. It is automatically
updated whenever a type is defined by {\small\verb%define_type%}.

\FAILURE
Never fails.

\SEEALSO
cases, define, distinctness, GEN_BETA_CONV, injectivity.

\ENDDOC
\DOC{basic{\_}rewrites}

\TYPE {\small\verb%basic_rewrites : unit -> thm list%}\egroup

\SYNOPSIS
Returns the set of built-in theorems used, by default, in rewriting.

\DESCRIBE
The list of theorems returned by {\small\verb%basic_rewrites()%} is applied by default in
rewriting conversions, rules and tactics such as {\small\verb%ONCE_REWRITE_CONV%},
{\small\verb%REWRITE_RULE%} and {\small\verb%SIMP_TAC%}, though not in the `pure' variants like
{\small\verb%PURE_REWRITE_TAC%}. This default set can be modified using
{\small\verb%extend_basic_rewrites%}, {\small\verb%set_basic_rewrites%}. Other conversions, not
necessarily expressible as rewriting with a theorem, can be added using
{\small\verb%set_basic_convs%} and {\small\verb%extend_basic_convs%} and examined by {\small\verb%basic_convs%}.

\EXAMPLE
The following shows the list of default rewrites in the standard HOL Light
state. Most of them are basic logical tautologies.
{\par\samepage\setseps\small
\begin{verbatim}
# basic_rewrites();;
val it : thm list =
  [|- FST (x,y) = x; |- SND (x,y) = y; |- FST x,SND x = x;
   |- (if x = x then y else z) = y; |- (if T then t1 else t2) = t1;
   |- (if F then t1 else t2) = t2; |- ~ ~t <=> t; |- ~T <=> F; |- ~F <=> T;
   |- (@y. y = x) = x; |- x = x <=> T; |- (T <=> t) <=> t;
   |- (t <=> T) <=> t; |- (F <=> t) <=> ~t; |- (t <=> F) <=> ~t; |- ~T <=> F;
   |- ~F <=> T; |- T /\ t <=> t; |- t /\ T <=> t; |- F /\ t <=> F;
   |- t /\ F <=> F; |- t /\ t <=> t; |- T \/ t <=> T; |- t \/ T <=> T;
   |- F \/ t <=> t; |- t \/ F <=> t; |- t \/ t <=> t; |- T ==> t <=> t;
   |- t ==> T <=> T; |- F ==> t <=> T; |- t ==> t <=> T; |- t ==> F <=> ~t;
   |- (!x. t) <=> t; |- (?x. t) <=> t; |- (\x. f x) y = f y;
   |- x = x ==> p <=> p]
\end{verbatim}
}

\USES
The {\small\verb%basic_rewrites%} are included in the set of equations used by some
of the rewriting tools.

\SEEALSO
extend_basic_rewrites, set_basic_rewrites, set_basic_convs, extend_basic_convs,
basic_convs, REWRITE_CONV, REWRITE_RULE, REWRITE_TAC, SIMP_CONV, SIMP_RULE,
SIMP_TAC.

\ENDDOC
\DOC{basic{\_}ss}

\TYPE {\small\verb%basic_ss : thm list -> simpset%}\egroup

\SYNOPSIS
Construct a straightforward simpset from a list of theorems.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset'. A call {\small\verb%basic_ss thl%} gives a
straightforward simpset used by the default simplifier instances like
{\small\verb%SIMP_TAC%}, which has the given theorems as well as the basic rewrites and
conversions, and no other provers.

\FAILURE
Never fails.

\SEEALSO
basic_convs, basic_rewrites, empty_ss, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{BETA}

\TYPE {\small\verb%BETA : term -> thm%}\egroup

\SYNOPSIS
Special primitive case of beta-reduction.

\DESCRIBE
Given a term of the form {\small\verb%(\x. t[x]) x%}, i.e. a lambda-term applied to exactly
the same variable that occurs in the abstraction, {\small\verb%BETA%} returns the theorem
{\small\verb%|- (\x. t[x]) x = t[x]%}.

\FAILURE
Fails if the term is not of the required form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BETA `(\n. n + 1) n`;;
  val it : thm = |- (\n. n + 1) n = n + 1
\end{verbatim}
}
\noindent Note that more general beta-reduction is not handled by {\small\verb%BETA%}, but
will be by {\small\verb%BETA_CONV%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # BETA `(\n. n + 1) m`;;
  Exception: Failure "BETA: not a trivial beta-redex".
  # BETA_CONV `(\n. n + 1) m`;;
  val it : thm = |- (\n. n + 1) m = m + 1
\end{verbatim}
}

\USES
This is more efficient than {\small\verb%BETA_CONV%} in the special case in which it works,
because no traversal and replacement of the body of the abstraction is needed.

\COMMENTS
This is one of HOL Light's 10 primitive inference rules. The more general case
of beta-reduction, where a lambda-term is applied to any term, is implemented
by {\small\verb%BETA_CONV%}, derived in terms of this primitive.

\SEEALSO
BETA_CONV.

\ENDDOC
\DOC{BETAS{\_}CONV}

\TYPE {\small\verb%BETAS_CONV : conv%}\egroup

\SYNOPSIS
Beta conversion over multiple arguments.

\DESCRIBE
Given a term {\small\verb%t%} of the form {\small\verb%`(\x1 ... xn. t[x1,...,xn]) s1 ... sn`%}, the call
{\small\verb%BETAS_CONV t%} returns
{\par\samepage\setseps\small
\begin{verbatim}
  |- (\x1 ... xn. t[x1,...,xn]) s1 ... sn = t[s1,...,sn]
\end{verbatim}
}

\FAILURE
Fails if the term is not of the form shown, for some {\small\verb%n%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BETAS_CONV `(\x y. x + y) 1 2`;;
  val it : thm = |- (\x y. x + y) 1 2 = 1 + 2
\end{verbatim}
}

\SEEALSO
BETA_CONV, RIGHT_BETAS.

\ENDDOC
\DOC{BETA{\_}CONV}

\TYPE {\small\verb%BETA_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs a simple beta-conversion.

\DESCRIBE
The conversion {\small\verb%BETA_CONV%} maps a beta-redex {\small\verb%`(\x.u)v`%} to the theorem
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\x.u)v = u[v/x]
\end{verbatim}
}
\noindent where {\small\verb%u[v/x]%} denotes the result of substituting {\small\verb%v%} for all free
occurrences of {\small\verb%x%} in {\small\verb%u%}, after renaming sufficient bound variables to avoid
variable capture. This conversion is one of the primitive inference rules of
the HOL system.

\FAILURE
{\small\verb%BETA_CONV tm%} fails if {\small\verb%tm%} is not a beta-redex.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BETA_CONV `(\x. x + 1) y`;;
  val it : thm = |- (\x. x + 1) y = y + 1

  # BETA_CONV `(\x y. x + y) y`;;
  val it : thm = |- (\x y. x + y) y = (\y'. y + y')
\end{verbatim}
}

\COMMENTS
The HOL Light primitive rule {\small\verb%BETA%} is the special case where the argument is
the same as the bound variable. If you know that you are in this case, {\small\verb%BETA%}
is significantly more efficient. Though traditionally a primitive, {\small\verb%BETA_CONV%}
is actually a derived rule in HOL Light.

\SEEALSO
BETA, BETA_RULE, BETA_TAC, GEN_BETA_CONV, MATCH_CONV.

\ENDDOC
\DOC{BETA{\_}RULE}

\TYPE {\small\verb%BETA_RULE : thm -> thm%}\egroup

\SYNOPSIS
Beta-reduces all the beta-redexes in the conclusion of a theorem.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t%}, the inference rule {\small\verb%BETA_RULE%} beta-reduces
all beta-redexes, at any depth, in the conclusion {\small\verb%t%}. Variables are renamed
where necessary to avoid free variable capture.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- ....((\x. s1) s2)....
   ----------------------------  BETA_RULE
      A |- ....(s1[s2/x])....
\end{verbatim}
}
\FAILURE
Never fails, but will have no effect if there are no beta-redexes.

\EXAMPLE
The following example is a simple reduction which illustrates variable
renaming:
{\par\samepage\setseps\small
\begin{verbatim}
  # let x = ASSUME `f = ((\x y. x + y) y)`;;
  val x : thm = f = (\x y. x + y) y |- f = (\x y. x + y) y

  # BETA_RULE x;;
  val it : thm = f = (\x y. x + y) y |- f = (\y'. y + y')
\end{verbatim}
}
\SEEALSO
BETA_CONV, BETA_TAC, GEN_BETA_CONV.

\ENDDOC
\DOC{BETA{\_}TAC}

\TYPE {\small\verb%BETA_TAC : tactic%}\egroup

\SYNOPSIS
Beta-reduces all the beta-redexes in the conclusion of a goal.

\DESCRIBE
When applied to a goal {\small\verb%A ?- t%}, the tactic {\small\verb%BETA_TAC%} produces a new goal
which results from beta-reducing all beta-redexes, at any depth, in {\small\verb%t%}.
Variables are renamed where necessary to avoid free variable capture.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- ...((\x. s1) s2)...
   ==========================  BETA_TAC
     A ?- ...(s1[s2/x])...
\end{verbatim}
}

\FAILURE
Never fails, but will have no effect if there are no beta-redexes.

\COMMENTS
Beta-reduction, and indeed, generalized beta reduction ({\small\verb%GEN_BETA_CONV%}) are
already among the basic rewrites, so happen anyway simply on {\small\verb%REWRITE_TAC[]%}.
But occasionally it is convenient to be able to invoke them separately.

\SEEALSO
BETA_CONV, BETA_RULE, GEN_BETA_CONV.

\ENDDOC
\DOC{binders}

\TYPE {\small\verb%binders : unit -> string list%}\egroup

\SYNOPSIS
Lists the binders.

\DESCRIBE
The function {\small\verb%binders%} returns a list of all the binders declared so far. A
binder {\small\verb%b%} is then parsed in constructs like {\small\verb%b x. t[x]%} as an abbreviation for
{\small\verb%(b) (\x. t[x])%}. The set of binders can be changed with {\small\verb%parse_as_binder%} and
{\small\verb%unparse_as_binder%}.

\FAILURE
Never fails

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # binders();;
  val it : string list = ["\\"; "!"; "?"; "?!"; "@"; "minimal"; "lambda"]
\end{verbatim}
}
\SEEALSO
parse_as_binder, parses_as_binder, parse_as_infix, parse_as_prefix,
unparse_as_binder.

\ENDDOC
\DOC{BINDER{\_}CONV}

\TYPE {\small\verb%BINDER_CONV : conv -> term -> thm%}\egroup

\SYNOPSIS
Applies conversion to the body of a binder.

\DESCRIBE
If {\small\verb%c%} is a conversion such that {\small\verb%c `t`%} returns {\small\verb%|- t = t'%}, then
{\small\verb%BINDER_CONV c `b (\x. t)`%} returns {\small\verb%|- b (\x. t) = b (\x. t')%}, i.e. applies
the core conversion to the body of a `binder'. In fact, {\small\verb%b%} here can be any
term, but it is typically a binder constant such as a quantifier.

\FAILURE
Fails if the core conversion does, or if the theorem returned by it is not of
the right form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BINDER_CONV SYM_CONV `@n. n = m + 1`;;
  val it : thm = |- (@n. n = m + 1) = (@n. m + 1 = n)

  # BINDER_CONV (REWR_CONV SWAP_FORALL_THM) `!x y z. x + y + z = y + x + z`;;
  val it : thm =
    |- (!x y z. x + y + z = y + x + z) <=> (!x z y. x + y + z = y + x + z)
\end{verbatim}
}

\SEEALSO
ABS_CONV, RAND_CONV, RATOR_CONV.

\ENDDOC
\DOC{BINOP2{\_}CONV}

\TYPE {\small\verb%BINOP2_CONV : conv -> conv -> conv%}\egroup

\SYNOPSIS
Applies conversions to the two arguments of a binary operator.

\DESCRIBE
If {\small\verb%c1%} is a conversion where {\small\verb%c1 `l`%} returns {\small\verb%|- l = l'%} and {\small\verb%c2%} is a
conversion where {\small\verb%c2 `r`%} returns {\small\verb%|- r = r'%}, then
{\small\verb%BINOP2_CONV c1 c2 `op l r`%} returns {\small\verb%|- op l r = op l' r'%}. The
term {\small\verb%op%} is arbitrary, but is often a constant such as addition or
conjunction.

\FAILURE
Never fails when applied to the conversion. But may fail when applied to the
term if one of the core conversions fails or returns an inappropriate theorem
on the subterms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BINOP2_CONV NUM_ADD_CONV NUM_SUB_CONV `(3 + 3) * (10 - 3)`;;
  val it : thm = |- (3 + 3) * (10 - 3) = 6 * 7
\end{verbatim}
}

\COMMENTS
The special case when the two conversions are the same is more briefly achieved
using {\small\verb%BINOP_CONV%}.

\SEEALSO
ABS_CONV, BINOP_CONV, COMB_CONV, COMB2_CONV, RAND_CONV, RATOR_CONV.

\ENDDOC
\DOC{binops}

\TYPE {\small\verb%binops : term -> term -> term list%}\egroup

\SYNOPSIS
Repeatedly breaks apart an iterated binary operator into components.

\DESCRIBE
The call {\small\verb%binops op t%} repeatedly breaks down applications of the binary
operator {\small\verb%op%} within {\small\verb%t%}. If {\small\verb%t%} is of the form {\small\verb%(op l) r%} (thinking of {\small\verb%op%} as
infix, {\small\verb%l op r%}), then it recursively breaks down {\small\verb%l%} and {\small\verb%r%} in the same way
and appends the results. Otherwise, a singleton list of the original term is
returned.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # binops `(+):num->num->num` `((1 + 2) + 3) + 4 + 5 + 6`;;
  val it : term list = [`1`; `2`; `3`; `4`; `5`; `6`]

  # binops `(+):num->num->num` `F`;;
  val it : term list = [`F`]
\end{verbatim}
}

\SEEALSO
dest_binop, mk_binop, striplist.

\ENDDOC
\DOC{BINOP{\_}CONV}

\TYPE {\small\verb%BINOP_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to both arguments of a binary operator.

\DESCRIBE
If {\small\verb%c%} is a conversion where {\small\verb%c `l`%} returns {\small\verb%|- l = l'%} and {\small\verb%c `r`%} returns
{\small\verb%|- r = r'%}, then {\small\verb%BINOP_CONV c `op l r`%} returns {\small\verb%|- op l r = op l' r'%}. The
term {\small\verb%op%} is arbitrary, but is often a constant such as addition or
conjunction.

\FAILURE
Never fails when applied to the conversion. But may fail when applied to the
term if one of the core conversions fails or returns an inappropriate theorem
on the subterms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BINOP_CONV NUM_ADD_CONV `(1 + 1) * (2 + 2)`;;
  val it : thm = |- (1 + 1) * (2 + 2) = 2 * 4
\end{verbatim}
}

\SEEALSO
ABS_CONV, BINOP2_CONV, COMB_CONV, COMB2_CONV, RAND_CONV, RATOR_CONV.

\ENDDOC
\DOC{BINOP{\_}TAC}

\TYPE {\small\verb%BINOP_TAC : tactic%}\egroup

\SYNOPSIS
Breaks apart equation between binary operator applications into equality
between their arguments.

\DESCRIBE
Given a goal whose conclusion is an equation between applications of the same
curried binary function {\small\verb%f%}, the tactic {\small\verb%BINOP_TAC%} breaks it down to two
subgoals expressing equality of the corresponding arguments:
{\par\samepage\setseps\small
\begin{verbatim}
       A ?- f x1 y1 = f x2 y2
   ================================  BINOP_TAC
      A ?- x1 = x2    A ?- y1 = y2
\end{verbatim}
}

\FAILURE
Fails if the conclusion of the goal is not an equation between applications of
the same curried binary operator.

\EXAMPLE
We can set up the following goal which is an equation between applications of
the binary operator {\small\verb%+%}:

{\par\samepage\setseps\small
\begin{verbatim}
  # g `f(2 * x + 1) + w * z = f(SUC(x + 1) * 2 - 1) + z * w`;;
\end{verbatim}
}
\noindent and it is simplest to prove if we split it up into two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e BINOP_TAC;;
  val it : goalstack = 2 subgoals (2 total)

  `w * z = z * w`

  `f (2 * x + 1) = f (SUC (x + 1) * 2 - 1)`
\end{verbatim}
}
\noindent the first of which can be solved by {\small\verb%ARITH_TAC%}, and the second by
{\small\verb%AP_TERM_TAC THEN ARITH_TAC%}.

\SEEALSO
ABS_TAC, AP_TERM_TAC, AP_THM_TAC, MK_BINOP, MK_COMB_TAC.

\ENDDOC
\DOC{BITS{\_}ELIM{\_}CONV}

\TYPE {\small\verb%BITS_ELIM_CONV : conv%}\egroup

\SYNOPSIS
Removes stray instances of special constants used in numeral representation

\DESCRIBE
The HOL Light representation of numeral constants like {\small\verb%`6`%} uses a
number of special constants {\small\verb%`NUMERAL`%}, {\small\verb%`BIT0`%}, {\small\verb%`BIT1`%} and {\small\verb%`_0`%},
essentially to represent those numbers in binary. The conversion
{\small\verb%BITS_ELIM_CONV%} eliminates any uses of these constants within the given term
not used as part of a standard numeral.

\FAILURE
Never fails

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BITS_ELIM_CONV `BIT0(BIT1(BIT1 _0)) = 6`;;
  val it : thm =
    |- BIT0 (BIT1 (BIT1 _0)) = 6 <=> 2 * (2 * (2 * 0 + 1) + 1) = 6

  # (BITS_ELIM_CONV THENC NUM_REDUCE_CONV) `BIT0(BIT1(BIT1 _0)) = 6`;;
  val it : thm = |- BIT0 (BIT1 (BIT1 _0)) = 6 <=> T
\end{verbatim}
}

\USES
Mainly intended for internal use in functions doing sophisticated things with
numerals.

\SEEALSO
ARITH_RULE, ARITH_TAC, NUM_RING.

\ENDDOC
\DOC{bndvar}

\TYPE {\small\verb%bndvar : term -> term%}\egroup

\SYNOPSIS
Returns the bound variable of an abstraction.

\DESCRIBE
{\small\verb%bndvar `\var. t`%} returns {\small\verb%`var`%}.

\FAILURE
Fails unless the term is an abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # bndvar `\x. x + 1`;;
  val it : term = `x`
\end{verbatim}
}

\SEEALSO
body, dest_abs.

\ENDDOC
\DOC{body}

\TYPE {\small\verb%body : term -> term%}\egroup

\SYNOPSIS
Returns the body of an abstraction.

\DESCRIBE
{\small\verb%body `\var. t`%} returns {\small\verb%`t`%}.

\FAILURE
Fails unless the term is an abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # body `\x. x + 1`;;
  val it : term = `x + 1`
\end{verbatim}
}

\SEEALSO
bndvar, dest_abs.

\ENDDOC
\DOC{BOOL{\_}CASES{\_}TAC}

\TYPE {\small\verb%BOOL_CASES_TAC : term -> tactic%}\egroup

\SYNOPSIS
Performs boolean case analysis on a (free) term in the goal.

\DESCRIBE
When applied to a term {\small\verb%x%} (which must be of type {\small\verb%bool%} but need not be simply
a variable), and a goal {\small\verb%A ?- t%}, the tactic {\small\verb%BOOL_CASES_TAC%} generates the two
subgoals corresponding to {\small\verb%A ?- t%} but with any free instances of {\small\verb%x%} replaced
by {\small\verb%F%} and {\small\verb%T%} respectively.
{\par\samepage\setseps\small
\begin{verbatim}
              A ?- t
   ============================  BOOL_CASES_TAC `x`
    A ?- t[F/x]    A ?- t[T/x]
\end{verbatim}
}
\noindent The term given does not have to be free in the goal, but if it isn't,
{\small\verb%BOOL_CASES_TAC%} will merely duplicate the original goal twice. Note that in
the new goals, we don't have {\small\verb%x%} and {\small\verb%~x%} as assumptions; for that use
{\small\verb%ASM_CASES_TAC%}.

\FAILURE
Fails unless the term {\small\verb%x%} has type {\small\verb%bool%}.

\EXAMPLE
The goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(b ==> ~b) ==> (b ==> a)`;;
\end{verbatim}
}
\noindent can be completely solved by using {\small\verb%BOOL_CASES_TAC%} on the variable
{\small\verb%b%}, then simply rewriting the two subgoals using only the inbuilt tautologies,
i.e. by applying the following tactic:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(BOOL_CASES_TAC `b:bool` THEN REWRITE_TAC[]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Avoiding fiddly logical proofs by brute-force case analysis, possibly only
over a key term as in the above example, possibly over all free boolean
variables.

\SEEALSO
ASM_CASES_TAC, COND_CASES_TAC, DISJ_CASES_TAC, ITAUT, STRUCT_CASES_TAC, TAUT.

\ENDDOC
\DOC{bool{\_}ty}

\TYPE {\small\verb%bool_ty : hol_type%}\egroup

\SYNOPSIS
The type {\small\verb%`:bool`%}.

\DESCRIBE
This name is bound to the HOL type {\small\verb%:bool%}.

\FAILURE
Not applicable.

\USES
Exploiting the very common type {\small\verb%:bool%} inside derived rules without the
inefficiency or inconvenience of calling a quotation parser or explicit
constructor.

\SEEALSO
aty, bty.

\ENDDOC
\DOC{bty}

\TYPE {\small\verb%bty : hol_type%}\egroup

\SYNOPSIS
The type variable {\small\verb%`:B`%}.

\DESCRIBE
This name is bound to the HOL type {\small\verb%:B%}.

\FAILURE
Not applicable.

\USES
Exploiting the very common type variable {\small\verb%:B%} inside derived rules (e.g. an
instantiation list for {\small\verb%inst%} or {\small\verb%type_subst%}) without the inefficiency or
inconvenience of calling a quotation parser or explicit constructor.

\SEEALSO
aty, bool_ty.

\ENDDOC
\DOC{butlast}

\TYPE {\small\verb%butlast : 'a list -> 'a list%}\egroup

\SYNOPSIS
Computes the sub-list of a list consisting of all but the last element.

\DESCRIBE
{\small\verb%butlast [x1;...;xn]%} returns {\small\verb%[x1;...;x(n-1)]%}.

\FAILURE
Fails if the list is empty.

\SEEALSO
last, hd, tl, el.

\ENDDOC
\DOC{by}

\TYPE {\small\verb%by : tactic -> refinement%}\egroup

\SYNOPSIS
Converts a tactic to a refinement.

\DESCRIBE
The call {\small\verb%by tac%} for a tactic {\small\verb%tac%} gives a refinement of the current list of
subgoals that applies {\small\verb%tac%} to the first subgoal.

\COMMENTS
Only of interest to users who want to handle `refinements' explicitly.

\ENDDOC
\DOC{C}

\TYPE {\small\verb%C : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c%}\egroup

\SYNOPSIS
Permutes first two arguments to curried function: {\small\verb%C f x y%} = {\small\verb%f y x%}.

\FAILURE
Never fails.

\SEEALSO
F_F, I, K, W.

\ENDDOC
\DOC{CACHE{\_}CONV}

\TYPE {\small\verb%CACHE_CONV : (term -> thm) -> term -> thm%}\egroup

\SYNOPSIS
Accelerates a conversion by cacheing previous results.

\DESCRIBE
If {\small\verb%cnv%} is any conversion, then {\small\verb%CACHE_CONV cnv%} gives a new conversion that
is functionally identical but keeps a cache of previous arguments and results,
and simply returns the cached result if the same input is encountered again.

\FAILURE
Never fails, though the subsequent application to a term may.

\EXAMPLE
The following call takes a while, making several applications to the same
expression:
{\par\samepage\setseps\small
\begin{verbatim}
  # time (DEPTH_CONV NUM_RED_CONV) `31 EXP 31 + 31 EXP 31 + 31 EXP 31`;;
  CPU time (user): 1.542
  val it : thm =
    |- 31 EXP 31 + 31 EXP 31 + 31 EXP 31 =
       51207522392169707875831929087177944268134203293
\end{verbatim}
}
\noindent whereas the cached variant is faster since the result for {\small\verb%31 EXP 31%}
is stored away and re-used after the first call:
{\par\samepage\setseps\small
\begin{verbatim}
  # time (DEPTH_CONV(CACHE_CONV NUM_RED_CONV))
         `31 EXP 31 + 31 EXP 31 + 31 EXP 31`;;
  CPU time (user): 0.461
  val it : thm =
    |- 31 EXP 31 + 31 EXP 31 + 31 EXP 31 =
       51207522392169707875831929087177944268134203293
\end{verbatim}
}

\SEEALSO

\ENDDOC
\DOC{can}

\TYPE {\small\verb%can : ('a -> 'b) -> 'a -> bool%}\egroup

\SYNOPSIS
Tests for failure.

\DESCRIBE
{\small\verb%can f x%} evaluates to {\small\verb%true%} if the application of {\small\verb%f%} to {\small\verb%x%} succeeds.
It evaluates to {\small\verb%false%} if the application fails with a {\small\verb%Failure _%} exception.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # can hd [1;2];;
  val it : bool = true
  # can hd [];;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
check.

\ENDDOC
\DOC{cases}

\TYPE {\small\verb%cases : string -> thm%}\egroup

\SYNOPSIS
Produce cases theorem for an inductive type.

\DESCRIBE
A call {\small\verb%cases "ty"%} where {\small\verb%"ty"%} is the name of a recursive type defined with
{\small\verb%define_type%}, returns a ``cases'' theorem asserting that each element of the
type is an instance of one of the type constructors. The effect is exactly
the same is if {\small\verb%prove_cases_thm%} were applied to the induction theorem produced
by {\small\verb%define_type%}, and the documentation for {\small\verb%prove_cases_thm%} gives a lengthier
discussion.

\FAILURE
Fails if {\small\verb%ty%} is not the name of a recursive type.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # cases "num";;
  val it : thm = |- !m. m = 0 \/ (?n. m = SUC n)

  # cases "list";;
  val it : thm = |- !x. x = [] \/ (?a0 a1. x = CONS a0 a1)
\end{verbatim}
}

\SEEALSO
define_type, distinctness, injectivity, prove_cases_thm.

\ENDDOC
\DOC{CASE{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%CASE_REWRITE_TAC : thm -> tactic%}\egroup

\SYNOPSIS
Performs casewise rewriting.

\DESCRIBE
Same usage as {\small\verb%IMP_REWRITE_TAC%} but applies case rewriting instead of
implicational rewriting, i.e. given a theorem of the form
{\small\verb%!x_1... x_n. P ==> !y_1... y_m. l = r%} and a goal with an atom {\small\verb%A%} containing
a subterm matching {\small\verb%l%}, turns the atom into {\small\verb%(P' ==> A') /\ (~P' ==> A)%} where
{\small\verb%A'%} is the atom in which the matching subterm of {\small\verb%l%} is rewritten, and where
{\small\verb%P'%} is the instantiation of {\small\verb%P%} so that the rewrite is valid. Note that this
tactic takes only one theorem since in practice there is seldom a need to
apply it subsequently with several theorems.

\FAILURE
Fails if no subterm matching {\small\verb%l%} occurs in the goal.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g ‘!a b c. a < b ==> (a - b) / (a - b) * c = c‘;;
  val it : goalstack = 1 subgoal (1 total)

  ‘!a b c. a < b ==> (a - b) / (a - b) * c = c‘

  # e(CASE_REWRITE_TAC REAL_DIV_REFL);;
  val it : goalstack = 1 subgoal (1 total)

  ‘!a b c.
    a < b
      ==> (~(a - b = &0) ==> &1 * c = c) /\
        (a - b = &0 ==> (a - b) / (a - b) * c = c)‘
\end{verbatim}
}

\USES
Similar to {\small\verb%IMP_REWRITE_TAC%}, but instead of assuming that a precondition
holds, one just wants to make a distinction between the case where this
precondition holds, and the one where it does not.

\SEEALSO
IMP_REWRITE_TAC, REWRITE_TAC, SIMP_TAC, SEQ_IMP_REWRITE_TAC, TARGET_REWRITE_TAC.

\ENDDOC
\DOC{CCONTR}

\TYPE {\small\verb%CCONTR : term -> thm -> thm%}\egroup

\SYNOPSIS
Implements the classical contradiction rule.

\DESCRIBE
When applied to a term {\small\verb%t%} and a theorem {\small\verb%A |- F%}, the inference rule {\small\verb%CCONTR%}
returns the theorem {\small\verb%A - {~t} |- t%}.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- F
   ---------------  CCONTR `t`
    A - {~t} |- t
\end{verbatim}
}

\FAILURE
Fails unless the term has type {\small\verb%bool%} and the theorem has {\small\verb%F%} as its
conclusion.

\COMMENTS
The usual use will be when {\small\verb%~t%} exists in the assumption list; in this case,
{\small\verb%CCONTR%} corresponds to the classical contradiction rule: if {\small\verb%~t%} leads to
a contradiction, then {\small\verb%t%} must be true.

\SEEALSO
CONTR, CONTR_TAC, NOT_ELIM.

\ENDDOC
\DOC{CHANGED{\_}CONV}

\TYPE {\small\verb%CHANGED_CONV : conv -> conv%}\egroup

\SYNOPSIS
Makes a conversion fail if applying it leaves a term unchanged.

\DESCRIBE
For a conversion {\small\verb%cnv%}, the construct {\small\verb%CHANGED_CONV c%} gives a new conversion
that has the same action as {\small\verb%cnv%}, except that it will fail on terms {\small\verb%t%} such
that {\small\verb%cnv t%} returns a reflexive theorem {\small\verb%|- t = t%}, or more precisely
{\small\verb%|- t = t'%} where {\small\verb%t%} and {\small\verb%t'%} are alpha-equivalent.

\FAILURE
Never fails when applied to the conversion, but fails on further application to
a term if the original conversion does or it returns a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ONCE_DEPTH_CONV num_CONV `x + 0`;;
  val it : thm = |- x + 0 = x + 0

  # CHANGED_CONV(ONCE_DEPTH_CONV num_CONV) `x + 0`;;
  Exception: Failure "CHANGED_CONV".

  # CHANGED_CONV(ONCE_DEPTH_CONV num_CONV) `6`;;
  val it : thm = |- 6 = SUC 5

  # REPEATC(CHANGED_CONV(ONCE_DEPTH_CONV num_CONV)) `6`;;
  val it : thm = |- 6 = SUC (SUC (SUC (SUC (SUC (SUC 0)))))
\end{verbatim}
}

\USES
{\small\verb%CHANGED_CONV%} is used to transform a conversion that may leave terms
unchanged, and therefore may cause a nonterminating computation if repeated,
into one that can safely be repeated until application of it fails to
substantially modify its input term, as in the last example above.

\ENDDOC
\DOC{CHANGED{\_}TAC}

\TYPE {\small\verb%CHANGED_TAC : tactic -> tactic%}\egroup

\SYNOPSIS
Makes a tactic fail if it has no effect.

\DESCRIBE
When applied to a tactic {\small\verb%t%}, the tactical {\small\verb%CHANGED_TAC%} gives a new tactic
which is the same as {\small\verb%t%} if that has any effect, and otherwise fails.

\FAILURE
The application of {\small\verb%CHANGED_TAC%} to a tactic never fails. The resulting
tactic fails if the basic tactic either fails or has no effect.

\USES
Occasionally useful in controlling complicated tactic compositions. Also
sometimes convenient just to check that a step did indeed modify a goal.

\SEEALSO
TRY, VALID.

\ENDDOC
\DOC{CHAR{\_}EQ{\_}CONV}

\TYPE {\small\verb%CHAR_EQ_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves equality or inequality of two HOL character literals.

\DESCRIBE
If {\small\verb%s%} and {\small\verb%t%} are two character literal terms in the HOL logic,
{\small\verb%CHAR_EQ_CONV `s = t`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- s = t <=> T       or       |- s = t <=> F
\end{verbatim}
}
\noindent depending on whether the character literals are equal or not equal,
respectively.

\FAILURE
{\small\verb%CHAR_EQ_CONV tm%} fails f {\small\verb%tm%} is not of the specified form, an equation
between character literals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = mk_eq(mk_char 'A',mk_char 'A');;
  val t : term = `ASCII F T F F F F F T = ASCII F T F F F F F T`

  # CHAR_EQ_CONV t;;
  val it : thm = |- ASCII F T F F F F F T = ASCII F T F F F F F T <=> T
\end{verbatim}
}

\USES
Performing basic equality reasoning while producing a proof about characters.

\COMMENTS
There is no particularly convenient parser/printer support for the HOL {\small\verb%char%}
type, but when combined into lists they are considered as strings and provided
with more intuitive parser/printer support. There is a corresponding proof rule
{\small\verb%STRING_EQ_CONV%} for strings.

\SEEALSO
dest_char, mk_char, NUM_EQ_CONV, STRING_EQ_CONV.

\ENDDOC
\DOC{CHEAT{\_}TAC}

\TYPE {\small\verb%CHEAT_TAC : tactic%}\egroup

\SYNOPSIS
Proves goal by asserting it as an axiom.

\DESCRIBE
Given any goal {\small\verb%A ?- p%}, the tactic {\small\verb%CHEAT_TAC%} solves it by using {\small\verb%mk_thm%},
which in turn involves essentially asserting the goal as a new axiom.

\FAILURE
Never fails.

\USES
Temporarily plugging boring parts of a proof to deal with the interesting
parts.

\COMMENTS
Needless to say, this should be used with caution since once new axioms are
asserted there is no guarantee that logical consistency is preserved.

\SEEALSO
new_axiom, mk_thm.

\ENDDOC
\DOC{check}

\TYPE {\small\verb%check : ('a -> bool) -> 'a -> 'a%}\egroup

\SYNOPSIS
Checks that a value satisfies a predicate.

\DESCRIBE
{\small\verb%check p x%} returns {\small\verb%x%} if the application {\small\verb%p x%} yields {\small\verb%true%}. Otherwise,
{\small\verb%check p x%} fails.

\FAILURE
{\small\verb%check p x%} fails with {\small\verb%Failure "check"%} if the predicate {\small\verb%p%} yields
{\small\verb%false%} when applied to the value {\small\verb%x%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # check is_var `x:bool`;;
  val it : term = `x`
  # check is_var `x + 2`;;
  Exception: Failure "check".
\end{verbatim}
}

\USES
Can be used to filter out candidates from a set of terms, e.g. to apply
theorem-tactics to assumptions with a certain pattern.

\SEEALSO
can.

\ENDDOC
\DOC{checkpoint}

\TYPE {\small\verb%checkpoint : string -> unit%}\egroup

\SYNOPSIS
Exits HOL Light but saves current state ready to restart.

\DESCRIBE
This is only available in Linux. A call {\small\verb%checkpoint s%} calls the {\small\verb%freeze%}
function from CryoPID to create a checkpoint of the current state of HOL Light,
named {\small\verb%hol.snapshot%}. When this image is restarted, the string {\small\verb%s%} is printed
as well as the usual startup banner.

\FAILURE
Never fails, except in the face of OS-level problems such as running out of
disc space.

\USES
To quickly save the state of HOL Light when it would take a long time to
regenerate.

\COMMENTS
Unfortunately I do not know of any checkpointing tool that can give this
behaviour under Windows or Mac OS X. See the README file and tutorial for
additional information on Linux checkpointing options.

\SEEALSO
self_destruct, startup_banner.

\ENDDOC
\DOC{choose}

\TYPE {\small\verb%choose : ('a, 'b) func -> 'a * 'b%}\egroup

\SYNOPSIS
Picks an arbitrary element from the graph of a finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If {\small\verb%f%} is a finite partial function, {\small\verb%choose f%} picks an arbitrary pair of
values from its graph, i.e. a pair {\small\verb%x,y%} where {\small\verb%f%} maps {\small\verb%x%} to {\small\verb%y%}. The
particular choice is implementation-defined, and it is not likely to be the
most obvious `first' value.

\FAILURE
Fails if and only if the finite partial function is completely undefined.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = itlist I [1 |-> 2; 2 |-> 3; 3 |-> 4] undefined;;
  val f : (int, int) func = <func>
  # choose f;;
  val it : int * int = (2, 3)
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{CHOOSE{\_}TAC}

\TYPE {\small\verb%CHOOSE_TAC : thm_tactic%}\egroup

\SYNOPSIS
Adds the body of an existentially quantified theorem to the assumptions of
a goal.

\DESCRIBE
When applied to a theorem {\small\verb%A' |- ?x. t%} and a goal, {\small\verb%CHOOSE_TAC%} adds
{\small\verb%t[x'/x]%} to the assumptions of the goal, where {\small\verb%x'%} is a variant of {\small\verb%x%}
which is not free in the assumption list; normally {\small\verb%x'%} is just {\small\verb%x%}.
{\par\samepage\setseps\small
\begin{verbatim}
         A ?- u
   ====================  CHOOSE_TAC (A' |- ?x. t)
    A u {t[x'/x]} ?- u
\end{verbatim}
}
\noindent Unless {\small\verb%A'%} is a subset of {\small\verb%A%}, this is not a valid tactic.

\FAILURE
Fails unless the given theorem is existentially quantified.

\EXAMPLE
Suppose we have a goal asserting that the output of an electrical circuit
(represented as a boolean-valued function) will become high at some time:
{\par\samepage\setseps\small
\begin{verbatim}
   ?- ?t. output(t)
\end{verbatim}
}
\noindent and we have the following theorems available:
{\par\samepage\setseps\small
\begin{verbatim}
   t1 = |- ?t. input(t)
   t2 = !t. input(t) ==> output(t+1)
\end{verbatim}
}
\noindent Then the goal can be solved by the application of:
{\par\samepage\setseps\small
\begin{verbatim}
   CHOOSE_TAC t1 THEN EXISTS_TAC `t+1` THEN
   UNDISCH_TAC `input (t:num) :bool` THEN MATCH_ACCEPT_TAC t2
\end{verbatim}
}
\SEEALSO
CHOOSE_THEN, X_CHOOSE_TAC.

\ENDDOC
\DOC{CHOOSE{\_}THEN}

\TYPE {\small\verb%CHOOSE_THEN : thm_tactical%}\egroup

\SYNOPSIS
Applies a tactic generated from the body of existentially quantified theorem.

\DESCRIBE
When applied to a theorem-tactic {\small\verb%ttac%}, an existentially quantified
theorem {\small\verb%A' |- ?x. t%}, and a goal, {\small\verb%CHOOSE_THEN%} applies the tactic {\small\verb%ttac
(t[x'/x] |- t[x'/x])%} to the goal, where {\small\verb%x'%} is a variant of {\small\verb%x%} chosen not to
be free in the assumption list of the goal. Thus if:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- s1
   =========  ttac (t[x'/x] |- t[x'/x])
    B ?- s2
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- s1
   ==========  CHOOSE_THEN ttac (A' |- ?x. t)
    B ?- s2
\end{verbatim}
}
\noindent This is invalid unless {\small\verb%A'%} is a subset of {\small\verb%A%}.

\FAILURE
Fails unless the given theorem is existentially quantified, or if the
resulting tactic fails when applied to the goal.

\EXAMPLE
This theorem-tactical and its relatives are very useful for using existentially
quantified theorems. For example one might use the inbuilt theorem
{\par\samepage\setseps\small
\begin{verbatim}
  LT_EXISTS = |- !m n. m < n <=> (?d. n = m + SUC d)
\end{verbatim}
}
\noindent to help solve the goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `x < y ==> 0 < y * y`;;
\end{verbatim}
}
\noindent by starting with the following tactic
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN(CHOOSE_THEN SUBST1_TAC o REWRITE_RULE[LT_EXISTS]));;
\end{verbatim}
}
\noindent reducing the goal to
{\par\samepage\setseps\small
\begin{verbatim}
  val it : goalstack = 1 subgoal (1 total)

  `0 < (x + SUC d) * (x + SUC d)`
\end{verbatim}
}
\noindent which can then be finished off quite easily, by, for example just
{\small\verb%ARITH_TAC%}, or
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[ADD_CLAUSES; MULT_CLAUSES; LT_0]);;
\end{verbatim}
}

\SEEALSO
CHOOSE_TAC, X_CHOOSE_THEN.

\ENDDOC
\DOC{CHOOSE}

\TYPE {\small\verb%CHOOSE : term * thm -> thm -> thm%}\egroup

\SYNOPSIS
Eliminates existential quantification using deduction from a
particular witness.

\DESCRIBE
When applied to a term-theorem pair {\small\verb%(v,A1 |- ?x. s)%} and a second
theorem of the form {\small\verb%A2 |- t%}, the inference rule {\small\verb%CHOOSE%}
produces the theorem {\small\verb%A1 u (A2 - {s[v/x]}) |- t%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- ?x. s[x]    A2 |- t
   -------------------------------  CHOOSE (`v`,(A1 |- ?x. s))
     A1 u (A2 - {s[v/x]}) |- t
\end{verbatim}
}
\noindent Where {\small\verb%v%} is not free in {\small\verb%A2 - {s[v/x]}%}, {\small\verb%s%} or {\small\verb%t%}.

\FAILURE
Fails unless the terms and theorems correspond as indicated above; in
particular, {\small\verb%v%} must be a variable and have the same type as the variable
existentially quantified over, and it must not be free in {\small\verb%A2 - {s[v/x]}%},
{\small\verb%s%} or {\small\verb%t%}.

\COMMENTS
For the special case of simply existentially quantifying an assumption over a
variable, {\small\verb%SIMPLE_CHOOSE%} is easier.

\SEEALSO
CHOOSE_TAC, EXISTS, EXISTS_TAC, SIMPLE_CHOOSE.

\ENDDOC
\DOC{chop{\_}list}

\TYPE {\small\verb%chop_list : int -> 'a list -> 'a list * 'a list%}\egroup

\SYNOPSIS
Chops a list into two parts at a specified point.

\DESCRIBE
{\small\verb%chop_list i [x1;...;xn]%} returns {\small\verb%([x1;...;xi],[x(i+1);...;xn])%}.

\FAILURE
Fails with {\small\verb%chop_list%} if {\small\verb%i%} is negative or greater than the length of the
list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # chop_list 3 [1;2;3;4;5];;
  val it : int list * int list = ([1; 2; 3], [4; 5])
\end{verbatim}
}

\SEEALSO
partition.

\ENDDOC
\DOC{CLAIM{\_}TAC}

\TYPE {\small\verb%CLAIM_TAC : string -> term -> tactic%}\egroup

\SYNOPSIS
Breaks down and labels an intermediate claim in a proof.

\DESCRIBE
Given a Boolean term {\small\verb%t%} and a string {\small\verb%s%} of the form expected by
{\small\verb%DESTRUCT_TAC%} indicating how to break down and label that assertion,
{\small\verb%CLAIM_TAC s t%} breaks the current goal into two or more subgoals. One of
these is to establish {\small\verb%t%} using the current context and the others are to
establish the original goal with the broken-down form of {\small\verb%t%} as additional
assumptions.

\FAILURE
Fails if the term is not Boolean or the pattern is ill-formed or does not match
the form of the theorem.

\EXAMPLE
Here we show how we can attack a propositional goal (admittedly trivial with
{\small\verb%TAUT%}).
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(p <=> q) ==> p \/ ~q`;;

  val it : goalstack = 1 subgoal (1 total)

  `(p <=> q) ==> p \/ ~q`

  # e DISCH_TAC;;
  val it : goalstack = 1 subgoal (1 total)

    0 [`p <=> q`]

  `p \/ ~q`
\end{verbatim}
}

We establish the intermediate goal {\small\verb%p /\ q \/ ~p /\ ~q%}, the disjunction being
in turn broken down into two labelled hypotheses {\small\verb%yes%} and {\small\verb%no%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(CLAIM_TAC "yes|no" `p /\ q \/ ~p /\ ~q`);;
  val it : goalstack = 3 subgoals (3 total)

    0 [`p <=> q`]
    1 [`~p /\ ~q`] (no)

  `p \/ ~q`

    0 [`p <=> q`]
    1 [`p /\ q`] (yes)

  `p \/ ~q`

    0 [`p <=> q`]

  `p /\ q \/ ~p /\ ~q`
\end{verbatim}
}

\SEEALSO
DESTRUCT_TAC, SUBGOAL_TAC, SUBGOAL_THEN.

\ENDDOC
\DOC{CNF{\_}CONV}

\TYPE {\small\verb%CNF_CONV : conv%}\egroup

\SYNOPSIS
Converts a term already in negation normal form into conjunctive normal form.

\DESCRIBE
When applied to a term already in negation normal form (see {\small\verb%NNF_CONV%}),
meaning that all other propositional connectives have been eliminated in favour
of conjunction, disjunction and negation, and negation is only applied to
atomic formulas, {\small\verb%CNF_CONV%} puts the term into an equivalent conjunctive normal
form, which is a right-associated conjunction of disjunctions without
repetitions. No reduction by subsumption is performed, however, e.g. from
{\small\verb%a /\ (a \/ b)%} to just {\small\verb%a%}).

\FAILURE
Never fails; non-Boolean terms will just yield a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CNF_CONV `(a /\ b) \/ (a /\ b /\ c) \/ d`;;
  val it : thm =
    |- a /\ b \/ a /\ b /\ c \/ d <=>
       (a \/ d) /\ (a \/ b \/ d) /\ (a \/ c \/ d) /\ (b \/ d) /\ (b \/ c \/ d)
\end{verbatim}
}

\SEEALSO
DNF_CONV, NNF_CONV, WEAK_CNF_CONV, WEAK_DNF_CONV.

\ENDDOC
\DOC{COMB2{\_}CONV}

\TYPE {\small\verb%COMB2_CONV : (term -> thm) -> (term -> thm) -> term -> thm%}\egroup

\SYNOPSIS
Applies two conversions to the two sides of an application.

\DESCRIBE
If {\small\verb%c1%} and {\small\verb%c2%} are conversions such that {\small\verb%c1 `f`%} returns {\small\verb%|- f = f'%} and
{\small\verb%c2 `x`%} returns {\small\verb%|- x = x'%}, then {\small\verb%COMB2_CONV c1 c2 `f x`%} returns
{\small\verb%|- f x = f' x'%}. That is, the conversions {\small\verb%c1%} and {\small\verb%c2%} are applied
respectively to the two immediate subterms.

\FAILURE
Never fails when applied to the initial conversions. On application to the term,
it fails if either {\small\verb%c1%} or {\small\verb%c2%} does, or if either returns a theorem that is of
the wrong form.

\COMMENTS
The special case when the two conversions are the same is more briefly achieved
using {\small\verb%COMB_CONV%}.

\SEEALSO
BINOP_CONV, BINOP2_CONV, COMB_CONV, LAND_CONV, RAND_CONV, RATOR_CONV

\ENDDOC
\DOC{combine}

\TYPE {\small\verb%combine : ('a -> 'a -> 'a) -> ('a -> bool) -> ('b, 'a) func -> ('b, 'a) func -> ('b, 'a) func%}\egroup

\SYNOPSIS
Combine together two finite partial functions using pointwise operation.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If {\small\verb%f%} and {\small\verb%g%} are finite partial functions, then {\small\verb%combine op z f g%} will
combine them together in the following somewhat complicated way. If just one of
the functions {\small\verb%f%} and {\small\verb%g%} is defined at point {\small\verb%x%}, that will give the value of
the combined function. If both {\small\verb%f%} and {\small\verb%g%} are defined at {\small\verb%x%} with values {\small\verb%y1%}
and {\small\verb%y2%}, the value of the combined function will be {\small\verb%op y1 y2%}. However, if
the resulting value {\small\verb%y%} satisfies the predicate {\small\verb%z%}, the new function will be
undefined at that point; the intuition is that the two values {\small\verb%y1%} and {\small\verb%y2%}
cancel each other out.

\FAILURE
Can only fail if the given operation fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = itlist I [1 |-> 2; 2 |-> 3; 3 |-> 6] undefined
    and g = itlist I [1 |-> 5; 2 |-> -3] undefined;;
  val f : (int, int) func = <func>
  val g : (int, int) func = <func>

  # graph(combine (+) (fun x -> x = 0) f g);;
  val it : (int * int) list = [(1, 7); (3, 6)]
\end{verbatim}
}

\USES
When finite partial functions are used to represent values with a numeric
domain (e.g. matrices or polynomials), this can be used to perform addition
pointwise by using addition for the {\small\verb%op%} argument. Using a zero test as the
predicate {\small\verb%z%} will ensure that no zero values are included in the result,
giving a canonical representation.

\SEEALSO
|->, |=>, apply, applyd, choose, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{COMB{\_}CONV}

\TYPE {\small\verb%COMB_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the two sides of an application.

\DESCRIBE
If {\small\verb%c%} is a conversion such that {\small\verb%c `f`%} returns {\small\verb%|- f = f'%} and
{\small\verb%c `x`%} returns {\small\verb%|- x = x'%}, then {\small\verb%COMB_CONV c `f x`%} returns
{\small\verb%|- f x = f' x'%}. That is, the conversion {\small\verb%c%} is applied to the two
immediate subterms.

\FAILURE
Never fails when applied to the initial conversion. On application to the term,
it fails if conversion given as the argument does, or if the theorem returned
by it is inappropriate.

\SEEALSO
BINOP_CONV, BINOP2_CONV, COMB2_CONV, LAND_CONV, RAND_CONV, RATOR_CONV

\ENDDOC
\DOC{comment{\_}token}

\TYPE {\small\verb%comment_token : lexcode ref%}\egroup

\SYNOPSIS
HOL Light comment token.

\DESCRIBE
Users may insert comments in HOL Light terms that are ignored in parsing.
Comments are introduced by a special comment token and terminated by the next
end of line. (There are no multi-line comments supported in HOL Light terms.)
The reference {\small\verb%comment_token%} stores the token that introduces a comment, which
by default is {\small\verb%Resword "//"%} as in BCPL, C++, Java etc. The user may change it
to another token, though this should be done with care in case other proofs
break.

\FAILURE
Not applicable.

\EXAMPLE
Here we change the comment token to be `{\small\verb%--%}' (as used in Ada, Eiffel, Haskell,
Occam and several other programming languages):
{\par\samepage\setseps\small
\begin{verbatim}
  # comment_token := Ident "--";;
  val it : unit = ()
\end{verbatim}
}
\noindent and we can test that it works:
{\par\samepage\setseps\small
\begin{verbatim}
  # `let wordsize = 32 -- may change to 64 later
     and radix = 2     -- only care about binary
     in radix EXP wordsize`;;
  val it : term = `let wordsize = 32 and radix = 2 in radix EXP wordsize`
\end{verbatim}
}

\COMMENTS
Comments are handled at the level of the lexical analyzer, so can also be used
in types and the strings used for the specification of inductive types.

\SEEALSO
define_type, lex, parse_inductive_type_specification, parse_term, parse_type.

\ENDDOC
\DOC{compose{\_}insts}

\TYPE {\small\verb%compose_insts : instantiation -> instantiation -> instantiation%}\egroup

\SYNOPSIS
Compose two instantiations.

\DESCRIBE
Given two instantiations {\small\verb%i1%} and {\small\verb%i2%} (with type {\small\verb%instantiation%}, as returned
by {\small\verb%term_match%} for example), the call {\small\verb%compose_insts i1 i2%} will give a new
instantiation that results from composing them, with {\small\verb%i1%} applied first and
then {\small\verb%i2%}. For example, {\small\verb%instantiate (compose_insts i1 i2) t%} should be the
same as {\small\verb%instantiate i2 (instantiate i1 t)%}.

\FAILURE
Never fails.

\COMMENTS
Mostly of specialized interest; used in sequencing tactics like {\small\verb%THEN%} to
compose metavariable instantiations.

\SEEALSO
instantiate, INSTANTIATE, INSTANTIATE_ALL, inst_goal, PART_MATCH, term_match.

\ENDDOC
\DOC{concl}

\TYPE {\small\verb%concl : thm -> term%}\egroup

\SYNOPSIS
Returns the conclusion of a theorem.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t%}, the function {\small\verb%concl%} returns {\small\verb%t%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD_SYM;;
  val it : thm = |- !m n. m + n = n + m
  # concl ADD_SYM;;
  val it : term = `!m n. m + n = n + m`

  # concl (ASSUME `1 = 0`);;
  val it : term = `1 = 0`
\end{verbatim}
}

\SEEALSO
dest_thm, hyp.

\ENDDOC
\DOC{CONDS{\_}CELIM{\_}CONV}

\TYPE {\small\verb%CONDS_CELIM_CONV : conv%}\egroup

\SYNOPSIS
Remove all conditional expressions from a Boolean formula.

\DESCRIBE
When applied to a Boolean term, {\small\verb%CONDS_CELIM_CONV%} identifies subterms that are
conditional expressions of the form `{\small\verb%if p then x else y%}', and eliminates
them. First they are ``pulled out'' as far as possible, e.g.
from `{\small\verb%f (if p then x else y)%}' to `{\small\verb%if p then f(x) else f(y)%}' and so on. When
a quantifier that binds one of the variables in the expression is reached, the
subterm is of Boolean type, say `{\small\verb%if p then q else r%}', and it is replaced by a
propositional equivalent of the form `{\small\verb%(~p \/ q) /\ (p \/ r)%}'.

\FAILURE
Never fails, but will just return a reflexive theorem if the term is not
Boolean.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONDS_CELIM_CONV `y <= z ==> !x. (if x <= y then y else x) <= z`;;
  val it : thm =
    |- y <= z ==> (!x. (if x <= y then y else x) <= z) <=>
       y <= z ==> (!x. (~(x <= y) \/ y <= z) /\ (x <= y \/ x <= z))
\end{verbatim}
}

\USES
Mostly for initial normalization in automated rules, but may be helpful for
other uses.

\COMMENTS
The function {\small\verb%CONDS_ELIM_CONV%} is functionally similar, but will do the final
propositional splitting in a ``disjunctive'' rather than ``conjunctive'' way.
The disjunctive way is usually better when the term will subsequently be passed
to a refutation procedure, whereas the conjunctive form is better for
non-refutation procedures. In each case, the policy is changed in an
appropriate way after passing through quantifiers.

\SEEALSO
COND_CASES_TAC, COND_ELIM_CONV, CONDS_ELIM_CONV.

\ENDDOC
\DOC{CONDS{\_}ELIM{\_}CONV}

\TYPE {\small\verb%CONDS_ELIM_CONV : conv%}\egroup

\SYNOPSIS
Remove all conditional expressions from a Boolean formula.

\DESCRIBE
When applied to a Boolean term, {\small\verb%CONDS_ELIM_CONV%} identifies subterms that are
conditional expressions of the form `{\small\verb%if p then x else y%}', and eliminates
them. First they are ``pulled out'' as far as possible, e.g.
from `{\small\verb%f (if p then x else y)%}' to `{\small\verb%if p then f(x) else f(y)%}' and so on. When
a quantifier that binds one of the variables in the expression is reached, the
subterm is of Boolean type, say `{\small\verb%if p then q else r%}', and it is replaced by a
propositional equivalent of the form `{\small\verb%p /\ q \/ ~p /\ r%}'.

\FAILURE
Never fails, but will just return a reflexive theorem if the term is not
Boolean.

\EXAMPLE
Note that in contrast to {\small\verb%COND_ELIM_CONV%}, there are no freeness restrictions,
and the Boolean split will be done inside quantifiers if necessary:
{\par\samepage\setseps\small
\begin{verbatim}
  # CONDS_ELIM_CONV `!x y. (if x <= y then y else x) <= z ==> x <= z`;;
  val it : thm =
    |- (!x y. (if x <= y then y else x) <= z ==> x <= z) <=>
       (!x y. ~(x <= y) \/ (y <= z ==> x <= z))
\end{verbatim}
}

\USES
Mostly for initial normalization in automated rules, but may be helpful for
other uses.

\COMMENTS
The function {\small\verb%CONDS_CELIM_CONV%} is functionally similar, but will do the final
propositional splitting in a ``conjunctive'' rather than ``disjunctive'' way.
The disjunctive way is usually better when the term will subsequently be passed
to a refutation procedure, whereas the conjunctive form is better for
non-refutation procedures. In each case, the policy is changed in an
appropriate way after passing through quantifiers.

\SEEALSO
COND_CASES_TAC, COND_ELIM_CONV, CONDS_CELIM_CONV.

\ENDDOC
\DOC{COND{\_}CASES{\_}TAC}

\TYPE {\small\verb%COND_CASES_TAC : tactic%}\egroup

\SYNOPSIS
Induces a case split on a conditional expression in the goal.

\DESCRIBE
{\small\verb%COND_CASES_TAC%} searches for a free conditional subterm in the term of a goal,
i.e. a subterm of the form {\small\verb%if p then u else v%}, choosing some topmost one if
there are several. It then induces a case split over {\small\verb%p%} as follows:
{\par\samepage\setseps\small
\begin{verbatim}
                       A ?- t
    ==========================================  COND_CASES_TAC
     A u {p} ?- t[T/p; u/(if p then u else v)]
     A u {~p} ?- t[F/p; v/(if p then u else v)]
\end{verbatim}
}
\noindent where {\small\verb%p%} is not a constant, and the term {\small\verb%p then u else v%} is free
in {\small\verb%t%}. Note that it both enriches the assumptions and inserts the assumed
value into the conditional.

\FAILURE
{\small\verb%COND_CASES_TAC%} fails if there is no conditional sub-term as described above.

\EXAMPLE
We can prove the following just by {\small\verb%REAL_ARITH `!x y:real. x <= max x y`%}, but
it is instructive to consider a manual proof.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x y:real. x <= max x y`;;
  val it : goalstack = 1 subgoal (1 total)

  `!x y. x <= max x y`

  # e(REPEAT GEN_TAC THEN REWRITE_TAC[real_max]);;'
  val it : goalstack = 1 subgoal (1 total)

  `x <= (if x <= y then y else x)`

  # e COND_CASES_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`~(x <= y)`]

  `x <= x`
\end{verbatim}
}

\USES
Useful for case analysis and replacement in one step, when there is a
conditional sub-term in the term part of the goal.  When there is more than
one such sub-term and one in particular is to be analyzed, {\small\verb%COND_CASES_TAC%}
cannot always be depended on to choose the `desired' one. It can, however, be
used repeatedly to analyze all conditional sub-terms of a goal.

\COMMENTS
Note that logically it should only be necessary for {\small\verb%p%} to be free in the whole
term, not the two branches {\small\verb%x%} and {\small\verb%y%}. However, as an artifact of the current
implementation, we need them to be free too. The more sophisticated
conversion {\small\verb%CONDS_ELIM_CONV%} handles this better.

\SEEALSO
ASM_CASES_TAC, COND_ELIM_CONV, CONDS_ELIM_CONV, DISJ_CASES_TAC,
STRUCT_CASES_TAC.

\ENDDOC
\DOC{COND{\_}ELIM{\_}CONV}

\TYPE {\small\verb%COND_ELIM_CONV : term -> thm%}\egroup

\SYNOPSIS
Conversion to eliminate one free conditional subterm.

\DESCRIBE
When applied to a term {\small\verb%`....(if p then x else y)...`%} containing a free
conditional subterm, {\small\verb%COND_ELIM_CONV%} returns a theorem asserting its
equivalence to a term with the conditional eliminated:
{\par\samepage\setseps\small
\begin{verbatim}
  |- ....(if p then x else y).... <=>
     (p ==> ....x....) /\ (~p ==> ....y....)
\end{verbatim}
}
If the term contains many free conditional subterms, a topmost one will be
used.

\FAILURE
Fails if there are no free conditional subterms.

\EXAMPLE
We can prove the little equivalence noted by Dijkstra in EWD1176 automatically:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_ARITH `!a b:real. a + b >= max a b <=> a >= &0 /\ b >= &0`;;
  val it : thm = |- !a b. a + b >= max a b <=> a >= &0 /\ b >= &0
\end{verbatim}
}
However, if our automated tools were unfamiliar with {\small\verb%max%}, we might expand its
definition (theorem {\small\verb%real_max%}) and then eliminate the resulting conditional by
{\small\verb%COND_ELIM_CONV%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # COND_ELIM_CONV `a + b >= (if a <= b then b else a) <=> a >= &0 /\ b >= &0`;;
  val it : thm =
    |- (a + b >= (if a <= b then b else a) <=> a >= &0 /\ b >= &0) <=>
       (a <= b ==> (a + b >= b <=> a >= &0 /\ b >= &0)) /\
       (~(a <= b) ==> (a + b >= a <=> a >= &0 /\ b >= &0))
\end{verbatim}
}

\USES
Eliminating conditionals as a prelude to other automated proof steps that are
not equipped to handle them.

\COMMENTS
Note that logically it should only be necessary for {\small\verb%p%} to be free in the whole
term, not the two branches {\small\verb%x%} and {\small\verb%y%}. However, as an artifact of the current
implementation, we need them to be free too. The more sophisticated
{\small\verb%CONDS_ELIM_CONV%} handles this better.

\SEEALSO
COND_CASES_TAC, CONDS_ELIM_CONV.

\ENDDOC
\DOC{CONJ}

\TYPE {\small\verb%CONJ : thm -> thm -> thm%}\egroup

\SYNOPSIS
Introduces a conjunction.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- t1      A2 |- t2
   ------------------------  CONJ
     A1 u A2 |- t1 /\ t2
\end{verbatim}
}
\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJ (NUM_REDUCE_CONV `2 + 2`) (ASSUME `p:bool`);;
  val it : thm = p |- 2 + 2 = 4 /\ p
\end{verbatim}
}

\SEEALSO
CONJUNCT1, CONJUNCT2, CONJUNCTS, CONJ_PAIR.

\ENDDOC
\DOC{CONJUNCT1}

\TYPE {\small\verb%CONJUNCT1 : thm -> thm%}\egroup

\SYNOPSIS
Extracts left conjunct of theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t1 /\ t2
   ---------------  CONJUNCT1
       A |- t1
\end{verbatim}
}
\FAILURE
Fails unless the input theorem is a conjunction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJUNCT1(ASSUME `p /\ q`);;
  val it : thm = p /\ q |- p
\end{verbatim}
}

\SEEALSO
CONJ_PAIR, CONJUNCT2, CONJ, CONJUNCTS.

\ENDDOC
\DOC{CONJUNCT2}

\TYPE {\small\verb%CONJUNCT2 : thm -> thm%}\egroup

\SYNOPSIS
Extracts right conjunct of theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t1 /\ t2
   ---------------  CONJUNCT2
       A |- t2
\end{verbatim}
}
\FAILURE
Fails unless the input theorem is a conjunction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJUNCT2(ASSUME `p /\ q`);;
  val it : thm = p /\ q |- q
\end{verbatim}
}

\SEEALSO
CONJ_PAIR, CONJUNCT1, CONJ, CONJUNCTS.

\ENDDOC
\DOC{conjuncts}

\TYPE {\small\verb%conjuncts : term -> term list%}\egroup

\SYNOPSIS
Iteratively breaks apart a conjunction.

\DESCRIBE
If a term {\small\verb%t%} is a conjunction {\small\verb%p /\ q%}, then {\small\verb%conjuncts t%} will recursively
break down {\small\verb%p%} and {\small\verb%q%} into conjuncts and append the resulting lists. Otherwise
it will return the singleton list {\small\verb%[t]%}. So if {\small\verb%t%} is of the form
{\small\verb%t1 /\ ... /\ tn%} with any reassociation, no {\small\verb%ti%} itself being a conjunction,
the list returned will be {\small\verb%[t1; ...; tn]%}. But
{\par\samepage\setseps\small
\begin{verbatim}
   conjuncts(list_mk_conj([t1;...;tn]))
\end{verbatim}
}
\noindent will not return {\small\verb%[t1;...;tn]%} if any of {\small\verb%t1%},...,{\small\verb%tn%} is a
conjunction.

\FAILURE
Never fails, even if the term is not boolean.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # conjuncts `((p /\ q) /\ r) /\ ((p /\ s /\ t) /\ u)`;;
  val it : term list = [`p`; `q`; `r`; `p`; `s`; `t`; `u`]

  # conjuncts(list_mk_conj [`a /\ b`; `c:bool`; `d /\ e /\ f`]);;
  val it : term list = [`a`; `b`; `c`; `d`; `e`; `f`]
\end{verbatim}
}

\COMMENTS
Because {\small\verb%conjuncts%} splits both the left and right sides of a conjunction,
this operation is not the inverse of {\small\verb%list_mk_conj%}. You can also use
{\small\verb%splitlist dest_conj%} to split in a right-associated way only.

\SEEALSO
dest_conj, disjuncts, is_conj.

\ENDDOC
\DOC{CONJUNCTS{\_}THEN}

\TYPE {\small\verb%CONJUNCTS_THEN : thm_tactical%}\egroup

\SYNOPSIS
Applies a theorem-tactic to each conjunct of a theorem.

\DESCRIBE
{\small\verb%CONJUNCTS_THEN%} takes a theorem-tactic {\small\verb%ttac%}, and a theorem {\small\verb%t%} whose
conclusion must be a conjunction. {\small\verb%CONJUNCTS_THEN%} breaks {\small\verb%t%} into two new
theorems, {\small\verb%t1%} and {\small\verb%t2%} which are {\small\verb%CONJUNCT1%} and {\small\verb%CONJUNCT2%} of {\small\verb%t%}
respectively, and then returns a new tactic: {\small\verb%ttac t1 THEN ttac t2%}. That is,
{\par\samepage\setseps\small
\begin{verbatim}
   CONJUNCTS_THEN ttac (A |- l /\ r) =  ttac (A |- l) THEN ttac (A |- r)
\end{verbatim}
}
\noindent so if
{\par\samepage\setseps\small
\begin{verbatim}
   A1 ?- t1                       A2 ?- t2
  ==========  ttac (A |- l)      ==========  ttac (A |- r)
   A2 ?- t2                       A3 ?- t3
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
    A1 ?- t1
   ==========  CONJUNCTS_THEN ttac (A |- l /\ r)
    A3 ?- t3
\end{verbatim}
}

\FAILURE
{\small\verb%CONJUNCTS_THEN ttac%} will fail if applied to a theorem whose conclusion is not
a conjunction.

\COMMENTS
{\small\verb%CONJUNCTS_THEN ttac (A |- u1 /\ ... /\ un)%} results in the tactic:
{\par\samepage\setseps\small
\begin{verbatim}
   ttac (A |- u1) THEN ttac (A |- u2 /\ ... /\ un)
\end{verbatim}
}
\noindent The iterated effect:
{\par\samepage\setseps\small
\begin{verbatim}
   ttac (A |- u1) THEN ... THEN ttac(A |- un)
\end{verbatim}
}
\noindent can be achieved by
{\par\samepage\setseps\small
\begin{verbatim}
  REPEAT_TCL CONJUNCTS_THEN ttac (A |- u1 /\ ... /\ un)
\end{verbatim}
}

\SEEALSO
CONJUNCT1, CONJUNCT2, CONJUNCTS, CONJUNCTS_TAC, CONJUNCTS_THEN2,
STRIP_THM_THEN.

\ENDDOC
\DOC{CONJUNCTS{\_}THEN2}

\TYPE {\small\verb%CONJUNCTS_THEN2 : thm_tactic -> thm_tactic -> thm_tactic%}\egroup

\SYNOPSIS
Applies two theorem-tactics to the corresponding conjuncts of a theorem.

\DESCRIBE
{\small\verb%CONJUNCTS_THEN2%} takes two theorem-tactics, {\small\verb%f1%} and {\small\verb%f2%}, and a theorem {\small\verb%t%}
whose conclusion must be a conjunction. {\small\verb%CONJUNCTS_THEN2%} breaks {\small\verb%t%} into two
new theorems, {\small\verb%t1%} and {\small\verb%t2%} which are {\small\verb%CONJUNCT1%} and {\small\verb%CONJUNCT2%} of {\small\verb%t%}
respectively, and then returns the tactic {\small\verb%f1 t1 THEN f2 t2%}. Thus
{\par\samepage\setseps\small
\begin{verbatim}
   CONJUNCTS_THEN2 f1 f2 (A |- l /\ r) =  f1 (A |- l) THEN f2 (A |- r)
\end{verbatim}
}
\noindent so if
{\par\samepage\setseps\small
\begin{verbatim}
   A1 ?- t1                     A2 ?- t2
  ==========  f1 (A |- l)      ==========  f2 (A |- r)
   A2 ?- t2                     A3 ?- t3
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
    A1 ?- t1
   ==========  CONJUNCTS_THEN2 f1 f2 (A |- l /\ r)
    A3 ?- t3
\end{verbatim}
}

\FAILURE
{\small\verb%CONJUNCTS_THEN f%} will fail if applied to a theorem whose conclusion is not a
conjunction.

\USES
The construction of complex {\small\verb%tactical%}s like {\small\verb%CONJUNCTS_THEN%}.

\SEEALSO
CONJUNCT1, CONJUNCT2, CONJUNCTS, CONJUNCTS_TAC, CONJUNCTS_THEN2,
STRIP_THM_THEN.

\ENDDOC
\DOC{CONJUNCTS}

\TYPE {\small\verb%CONJUNCTS : thm -> thm list%}\egroup

\SYNOPSIS
Recursively splits conjunctions into a list of conjuncts.

\DESCRIBE
Flattens out all conjuncts, regardless of grouping. Returns a singleton list
if the input theorem is not a conjunction.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t1 /\ t2 /\ ... /\ tn
   -----------------------------------  CONJUNCTS
    A |- t1   A |- t2   ...   A |- tn
\end{verbatim}
}
\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJUNCTS(ASSUME `(x /\ y) /\ z /\ w`);;
  val it : thm list =
    [(x /\ y) /\ z /\ w |- x; (x /\ y) /\ z /\ w |- y; (x /\ y) /\ z /\ w
     |- z; (x /\ y) /\ z /\ w |- w]
\end{verbatim}
}

\SEEALSO
CONJ, CONJUNCT1, CONJUNCT2, CONJ_PAIR.

\ENDDOC
\DOC{CONJ{\_}ACI{\_}RULE}

\TYPE {\small\verb%CONJ_ACI_RULE : term -> thm%}\egroup

\SYNOPSIS
Proves equivalence of two conjunctions containing same set of conjuncts.

\DESCRIBE
The call {\small\verb%CONJ_ACI_RULE `t1 /\ ... /\ tn <=> u1 /\ ... /\ um`%}, where both
sides of the equation are conjunctions of exactly the same set of conjuncts,
(with arbitrary ordering, association, and repetitions), will return the
corresponding theorem {\small\verb%|- t1 /\ ... /\ tn <=> u1 /\ ... /\ um%}.

\FAILURE
Fails if applied to a term that is not a Boolean equation or the two sets of
conjuncts are different.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJ_ACI_RULE `(a /\ b) /\ (a /\ c) <=> (a /\ (c /\ a)) /\ b`;;
  val it : thm = |- (a /\ b) /\ a /\ c <=> (a /\ c /\ a) /\ b
\end{verbatim}
}

\COMMENTS
The same effect can be had with the more general {\small\verb%AC%} construct. However, for
the special case of conjunction, {\small\verb%CONJ_ACI_RULE%} is substantially more
efficient when there are many conjuncts involved.

\SEEALSO
AC, CONJ_CANON_CONV, DISJ_ACI_RULE.

\ENDDOC
\DOC{CONJ{\_}CANON{\_}CONV}

\TYPE {\small\verb%CONJ_CANON_CONV : term -> thm%}\egroup

\SYNOPSIS
Puts an iterated conjunction in canonical form.

\DESCRIBE
When applied to a term, {\small\verb%CONJ_CANON_CONV%} splits it into the set of conjuncts
and produces a theorem asserting the equivalence of the term and the new term
with the disjuncts right-associated without repetitions and in a canonical
order.

\FAILURE
Fails if applied to a non-Boolean term. If applied to a term that is not a
conjunction, it will trivially work in the sense of regarding it as a single
conjunct and returning a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJ_CANON_CONV `(a /\ b) /\ ((b /\ d) /\ a) /\ c`;;
  val it : thm = |- (a /\ b) /\ ((b /\ d) /\ a) /\ c <=> a /\ b /\ c /\ d
\end{verbatim}
}

\SEEALSO
AC, CONJ_ACI_CONV, DISJ_CANON_CONV.

\ENDDOC
\DOC{CONJ{\_}PAIR}

\TYPE {\small\verb%CONJ_PAIR : thm -> thm * thm%}\egroup

\SYNOPSIS
Extracts both conjuncts of a conjunction.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t1 /\ t2
   ----------------------  CONJ_PAIR
    A |- t1      A |- t2
\end{verbatim}
}
\noindent The two resultant theorems are returned as a pair.

\FAILURE
Fails if the input theorem is not a conjunction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONJ_PAIR(ASSUME `p /\ q`);;
  val it : thm * thm = (p /\ q |- p, p /\ q |- q)
\end{verbatim}
}

\SEEALSO
CONJUNCT1, CONJUNCT2, CONJ, CONJUNCTS.

\ENDDOC
\DOC{CONJ{\_}TAC}

\TYPE {\small\verb%CONJ_TAC : tactic%}\egroup

\SYNOPSIS
Reduces a conjunctive goal to two separate subgoals.

\DESCRIBE
When applied to a goal {\small\verb%A ?- t1 /\ t2%}, the tactic {\small\verb%CONJ_TAC%} reduces it to the
two subgoals corresponding to each conjunct separately.
{\par\samepage\setseps\small
\begin{verbatim}
       A ?- t1 /\ t2
   ======================  CONJ_TAC
    A ?- t1      A ?- t2
\end{verbatim}
}

\FAILURE
Fails unless the conclusion of the goal is a conjunction.

\SEEALSO
STRIP_TAC.

\ENDDOC
\DOC{constants}

\TYPE {\small\verb%constants : unit -> (string * hol_type) list%}\egroup

\SYNOPSIS
Returns a list of the constants currently defined.

\DESCRIBE
The call
{\par\samepage\setseps\small
\begin{verbatim}
   constants();;
\end{verbatim}
}
returns a list of all the constants that have been defined so far.

\FAILURE
Never fails.

\SEEALSO
axioms, binders, infixes.

\ENDDOC
\DOC{CONTR}

\TYPE {\small\verb%CONTR : term -> thm -> thm%}\egroup

\SYNOPSIS
Implements the intuitionistic contradiction rule.

\DESCRIBE
When applied to a term {\small\verb%t%} and a theorem {\small\verb%A |- F%}, the inference rule {\small\verb%CONTR%}
returns the theorem {\small\verb%A |- t%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- F
   --------  CONTR `t`
    A |- t
\end{verbatim}
}

\FAILURE
Fails unless the term has type {\small\verb%bool%} and the theorem has {\small\verb%F%} as its
conclusion.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = REWRITE_RULE[ARITH] (ASSUME `1 = 0`);;
  val th : thm = 1 = 0 |- F

  # CONTR `Russell:Person = Pope` th;;
  val it : thm = 1 = 0 |- Russell = Pope
\end{verbatim}
}

\SEEALSO
CCONTR, CONTR_TAC, NOT_ELIM.

\ENDDOC
\DOC{CONTRAPOS{\_}CONV}

\TYPE {\small\verb%CONTRAPOS_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves the equivalence of an implication and its contrapositive.

\DESCRIBE
When applied to an implication {\small\verb%`p ==> q`%}, the conversion {\small\verb%CONTRAPOS_CONV%}
returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (p ==> q) <=> (~q ==> ~p)
\end{verbatim}
}

\FAILURE
Fails if applied to a term that is not an implication.

\COMMENTS
The same effect can be had by {\small\verb%GEN_REWRITE_CONV I [GSYM CONTRAPOS_THM]%}

\SEEALSO
CCONTR, CONTR_TAC.

\ENDDOC
\DOC{CONTR{\_}TAC}

\TYPE {\small\verb%CONTR_TAC : thm_tactic%}\egroup

\SYNOPSIS
Solves any goal from contradictory theorem.

\DESCRIBE
When applied to a contradictory theorem {\small\verb%A' |- F%}, and a goal {\small\verb%A ?- t%},
the tactic {\small\verb%CONTR_TAC%} completely solves the goal. This is an invalid
tactic unless {\small\verb%A'%} is a subset of {\small\verb%A%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   ========  CONTR_TAC (A' |- F)

\end{verbatim}
}

\USES
One quite common pattern is to use a contradictory hypothesis via
{\small\verb%FIRST_ASSUM CONTR_TAC%}.

\FAILURE
Fails unless the theorem is contradictory, i.e. has {\small\verb%F%} as its conclusion.

\SEEALSO
CCONTR, CONTR, NOT_ELIM.

\ENDDOC
\DOC{CONV{\_}RULE}

\TYPE {\small\verb%CONV_RULE : conv -> thm -> thm%}\egroup

\SYNOPSIS
Makes an inference rule from a conversion.

\DESCRIBE
If {\small\verb%c%} is a conversion, then {\small\verb%CONV_RULE c%} is an inference rule that applies
{\small\verb%c%} to the conclusion of a theorem.  That is, if {\small\verb%c%} maps a term {\small\verb%`t`%} to the
theorem {\small\verb%|- t = t'%}, then the rule {\small\verb%CONV_RULE c%} infers {\small\verb%|- t'%} from the
theorem {\small\verb%|- t%}.  More precisely, if {\small\verb%c `t`%} returns {\small\verb%A' |- t = t'%}, then:
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t
   --------------  CONV_RULE c
    A u A' |- t'
\end{verbatim}
}
\noindent Note that if the conversion {\small\verb%c%} returns a theorem with assumptions,
then the resulting inference rule adds these to the assumptions of the
theorem it returns.

\FAILURE
{\small\verb%CONV_RULE c th%} fails if {\small\verb%c%} fails when applied to the conclusion of {\small\verb%th%}. The
function returned by {\small\verb%CONV_RULE c%} will also fail if the ML function {\small\verb%c%} is
not, in fact, a conversion (i.e. a function that maps a term {\small\verb%t%} to a theorem
{\small\verb%|- t = t'%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # CONV_RULE BETA_CONV (ASSUME `(\x. x < 2) 1`);;
  val it : thm = (\x. x < 2) 1 |- 1 < 2
\end{verbatim}
}

\SEEALSO
CONV_TAC.

\ENDDOC
\DOC{CONV{\_}TAC}

\TYPE {\small\verb%CONV_TAC : conv -> tactic%}\egroup

\SYNOPSIS
Makes a tactic from a conversion.

\DESCRIBE
If {\small\verb%c%} is a conversion, then {\small\verb%CONV_TAC c%} is a tactic that applies {\small\verb%c%} to the
goal.  That is, if {\small\verb%c%} maps a term {\small\verb%`g`%} to the theorem {\small\verb%|- g = g'%}, then the
tactic {\small\verb%CONV_TAC c%} reduces a goal {\small\verb%g%} to the subgoal {\small\verb%g'%}.  More precisely, if
{\small\verb%c `g`%} returns {\small\verb%A' |- g = g'%}, then:
{\par\samepage\setseps\small
\begin{verbatim}
         A ?- g
     ===============  CONV_TAC c
         A ?- g'
\end{verbatim}
}
\noindent In the special case where {\small\verb%`g`%} is {\small\verb%`T`%}, the call immediately solves
the goal rather than generating a subgoal {\small\verb%A ?- T%}. And in a slightly liberal
interpretation of ``conversion'', the conversion may also just prove the goal
and return {\small\verb%A' |- g%}, in which case again the goal will be completely solved.

Note that in all cases the conversion {\small\verb%c%} should return a theorem whose
assumptions are also among the assumptions of the goal (normally, the
conversion will returns a theorem with no assumptions). {\small\verb%CONV_TAC%} does not
fail if this is not the case, but the resulting tactic will be invalid, so the
theorem ultimately proved using this tactic will have more assumptions than
those of the original goal.

\FAILURE
{\small\verb%CONV_TAC c%} applied to a goal {\small\verb%A ?- g%} fails if {\small\verb%c%} fails when applied to the
term {\small\verb%g%}. The function returned by {\small\verb%CONV_TAC c%} will also fail if the function
{\small\verb%c%} is not, in fact, a conversion (i.e. a function that maps a term {\small\verb%t%} to a
theorem {\small\verb%|- t = t'%}).

\USES
{\small\verb%CONV_TAC%} can be used to apply simplifications that can't be expressed as
equations (rewrite rules).  For example, a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `abs(pi - &22 / &7) <= abs(&355 / &113 - &22 / &7)`;;
\end{verbatim}
}
\noindent can be simplified by rational number arithmetic:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(CONV_TAC REAL_RAT_REDUCE_CONV);;
  val it : goalstack = 1 subgoal (1 total)

  `abs (pi - &22 / &7) <= &1 / &791`
\end{verbatim}
}
It is also handy for invoking decision procedures that only have a ``rule''
form, and no special ``tactic'' form. (Indeed, the tactic form can be defined
in terms of the rule form by using {\small\verb%CONV_TAC%}.) For example, the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x:real. &0 < x ==> &1 / x - &1 / (x + &1) = &1 / (x * (x + &1))`;;
\end{verbatim}
}
\noindent can be solved by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(CONV_TAC REAL_FIELD);;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
CONV_RULE.

\ENDDOC
\DOC{metisverb}

\TYPE {\small\verb%metisverb : bool ref%}\egroup

\SYNOPSIS
Make {\small\verb%METIS%}'s output more verbose and detailed.

\DESCRIBE
When this reference variable is set to {\small\verb%true%}, it makes any applications of
{\small\verb%METIS%}, {\small\verb%METIS_TAC%} and related rules and tactics provide more verbose output
about their working.

\FAILURE
Not applicable.

\SEEALSO
copverb, meson_chatty, METIS, METIS_TAC.

\ENDDOC
\DOC{current{\_}goalstack}

\TYPE {\small\verb%current_goalstack : goalstack ref%}\egroup

\SYNOPSIS
Reference variable holding current goalstack.

\DESCRIBE
The reference variable {\small\verb%current_goalstack%} contains the current goalstack. A
goalstack is a type containing a list of goalstates.

\FAILURE
Not applicable.

\COMMENTS
Users will probably not often want to examine this variable explicitly, since
various proof commands modify it in various ways.

\SEEALSO
b, g, e, r.

\ENDDOC
\DOC{curry}

\TYPE {\small\verb%curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c%}\egroup

\SYNOPSIS
Converts a function on a pair to a corresponding curried function.

\DESCRIBE
The application {\small\verb%curry f%} returns {\small\verb%\x y. f(x,y)%}, so that
{\par\samepage\setseps\small
\begin{verbatim}
   curry f x y = f(x,y)
\end{verbatim}
}
\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # curry mk_var;;
  val it : string -> hol_type -> term = <fun>
  # it "x";;
  val it : hol_type -> term = <fun>
  # it `:bool`;;
  val it : term = `x`
\end{verbatim}
}
\SEEALSO
uncurry.

\ENDDOC
\DOC{decreasing}

\TYPE {\small\verb%decreasing : ('a -> 'b) -> 'a -> 'a -> bool%}\egroup

\SYNOPSIS
When applied to a ``measure'' function {\small\verb%f%}, the call {\small\verb%increasing f%} returns a
binary function ordering elements in a call {\small\verb%increasing f x y%} by
{\small\verb%f(y) <? f(x)%}, where the ordering {\small\verb%<?%} is the OCaml polymorphic ordering.

\FAILURE
Never fails unless the measure function does.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let nums = -5 -- 5;;
  val nums : int list = [-5; -4; -3; -2; -1; 0; 1; 2; 3; 4; 5]
  # sort (decreasing abs) nums;;
  val it : int list = [5; -5; 4; -4; 3; -3; 2; -2; 1; -1; 0]
\end{verbatim}
}

\SEEALSO
<?, increasing, sort.

\ENDDOC
\DOC{DEDUCT{\_}ANTISYM{\_}RULE}

\TYPE {\small\verb%DEDUCT_ANTISYM_RULE : thm -> thm -> thm%}\egroup

\SYNOPSIS
Deduces logical equivalence from deduction in both directions.

\DESCRIBE
When applied to two theorems, this rule deduces logical equivalence between
their conclusions with a modified assumption list:
{\par\samepage\setseps\small
\begin{verbatim}
        A |- p       B |- q
  ----------------------------------
   (A - {q}) u (B - {p}) |- p <=> q
\end{verbatim}
}
The special case when {\small\verb%A = {q}%} and {\small\verb%B = {p}%} is perhaps the easiest to
understand:
{\par\samepage\setseps\small
\begin{verbatim}

        {q} |- p        {p} |- q
       --------------------------
              |- p <=> q
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = SYM(ASSUME `x:num = y`)
    and th2 = SYM(ASSUME `y:num = x`);;
  val th1 : thm = x = y |- y = x
  val th2 : thm = y = x |- x = y
  # DEDUCT_ANTISYM_RULE th1 th2;;
  val it : thm = |- y = x <=> x = y
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
IMP_ANTISYM_RULE, PROVE_HYP.

\ENDDOC
\DOC{deep{\_}alpha}

\TYPE {\small\verb%deep_alpha : (string * string) list -> term -> term%}\egroup

\SYNOPSIS
Modify bound variable according to renaming scheme.

\DESCRIBE
When applied to a list of string-string pairs
{\par\samepage\setseps\small
\begin{verbatim}
  deep_alpha ["x1'","x1"; ...; "xn'","xn"]
\end{verbatim}
}
\noindent a conversion results that will attempt to traverse a term and
systematically replace any bound variable called {\small\verb%xi%} with one called {\small\verb%xi'%}. It
will quietly do nothing in cases where that is impossible because of variable
capture.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # deep_alpha ["x'","x"; "y'","y"] `?x. x <=> !y. y = y`;;
  Warning: inventing type variables
  val it : term = `?x'. x' <=> (!y'. y' = y')`
\end{verbatim}
}

\COMMENTS
This is used inside {\small\verb%PART_MATCH%} to try to achieve a reasonable correspondence
in bound variable names, e.g. so that the bound variable is still called `{\small\verb%n%}'
rather than `{\small\verb%x%}' here:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWR_CONV NOT_FORALL_THM `~(!n. n < m)`;;
  val it : thm = |- ~(!n. n < m) <=> (?n. ~(n < m))
\end{verbatim}
}

\SEEALSO
alpha, PART_MATCH.

\ENDDOC
\DOC{define}

\TYPE {\small\verb%define : term -> thm%}\egroup

\SYNOPSIS
Defines a general recursive function.

\DESCRIBE
The function {\small\verb%define%} should be applied to a conjunction of `definitional'
clauses {\small\verb%`def_1[f] /\ ... /\ def_n[f]`%} for some variable {\small\verb%f%}, where each
clause {\small\verb%def_i%} is a universally quantified equation with an application of {\small\verb%f%}
to arguments on the left-hand side. The idea is that these clauses define the
action of {\small\verb%f%} on arguments of various kinds, for example on an empty list and
nonempty list:
{\par\samepage\setseps\small
\begin{verbatim}
  (f [] = a) /\ (!h t. CONS h t = k[f,h,t])
\end{verbatim}
}
\noindent or on even numbers and odd numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  (!n. f(2 * n) = a[f,n]) /\ (!n. f(2 * n + 1) = b[f,n])
\end{verbatim}
}
The {\small\verb%define%} function attempts to prove that there is indeed a function
satisfying all these properties, and if it succeeds it defines a new function
{\small\verb%f%} and returns the input term with the variable {\small\verb%f%} replaced by the newly
defined constant.

\FAILURE
Fails if the definition is malformed or if some of the necessary conditions for
the definition to be admissible cannot be proved automatically, or if there is
already a constant of the given name.

\EXAMPLE
This is a `multifactorial' function:
{\par\samepage\setseps\small
\begin{verbatim}
  # define
      `multifactorial m n =
          if m = 0 then 1
          else if n <= m then n else n * multifactorial m (n - m)`;;
  val it : thm =
  |- multifactorial m n =
     (if m = 0 then 1 else if n <= m then n else n * multifactorial m (n - m))
\end{verbatim}
}
Note that it fails without the {\small\verb%m = 0%} guard because then there's no reason
to suppose that {\small\verb%n - m%} decreases and hence the recursion is apparently
illfounded. Perhaps a more surprising example is the Collatz function:
{\par\samepage\setseps\small
\begin{verbatim}
  # define
     `!n. collatz(n) = if n <= 1 then n
                       else if EVEN(n) then collatz(n DIV 2)
                       else collatz(3 * n + 1)`;;
\end{verbatim}
}
Note that the definition was made successfully because there provably is a
function satisfying these recursion equations, notwithstanding the fact that it
is unknown whether the recursion is wellfounded. (Tail-recursive functions are
always logically consistent, though they may not have any useful provable
properties.)

\COMMENTS
Assuming the definition is well-formed and the constant name is unused, failure
indicates that {\small\verb%define%} was unable to prove one or both of the following two
properties: (i) the clauses are not mutually inconsistent (more than one clause
could apply to some arguments, and the results are not obviously the same), or
(ii) the definition is recursive and no ordering justifying the recursion could
be arrived at by the automated heuristic. In order to make progress in such
cases, try applying {\small\verb%prove_general_recursive_function_exists%} or
{\small\verb%pure_prove_recursive_function_exists%} to the same definition with existential
quantification over {\small\verb%f%}, to see the unproven side-conditions. An example is in
the documentation for {\small\verb%prove_general_recursive_function_exists%}. On the other
hand, for suitably simple and regular primitive recursive definitions,
the explicit alternative {\small\verb%prove_recursive_functions_exist%} is often much faster
than any of these.

\SEEALSO
new_definition, new_recursive_definition, new_specification,
prove_general_recursive_function_exists, prove_recursive_functions_exist,
pure_prove_recursive_function_exists.

\ENDDOC
\DOC{defined}

\TYPE {\small\verb%defined : ('a, 'b) func -> 'a -> bool%}\egroup

\SYNOPSIS
Tests if a finite partial function is defined on a certain domain value.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The call {\small\verb%defined f x%} returns {\small\verb%true%} if the finite partial function {\small\verb%f%}
is defined on domain value {\small\verb%x%}, and {\small\verb%false%} otherwise.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # defined (1 |=> 2) 1;;
  val it : bool = true

  # defined (1 |=> 2) 2;;
  val it : bool = false

  # defined undefined 1;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefined.

\ENDDOC
\DOC{define{\_}quotient{\_}type}

\TYPE {\small\verb%define_quotient_type : string -> string * string -> term -> thm * thm%}\egroup

\SYNOPSIS
Defines a quotient type based on given equivalence relation.

\DESCRIBE
The call {\small\verb%define_quotient_type "qty" ("abs","rep") `R`%}, where {\small\verb%R:A->A->bool%}
is a binary relation, defines a new ``quotient type'' {\small\verb%:qty%} and two new
functions {\small\verb%abs:(A->bool)->qty%} and {\small\verb%rep:qty->(A->bool)%}, and returns the pair
of theorems {\small\verb%|- abs(rep a) = a%} and {\small\verb%|- (?x. r = R x) <=> rep(abs r) = r%}.
Normally, {\small\verb%R%} will be an equivalence relation (reflexive, symmetric and
transitive), in which case the quotient type will be in bijection with the set
of {\small\verb%R%}-equivalence classes.

\FAILURE
Fails if there is already a type {\small\verb%qty%} or if either {\small\verb%abs%} or {\small\verb%rep%} is already
in use as a constant.

\EXAMPLE
For some purposes we may want to use ``multisets'' or ``bags''. These are like
sets in that order is irrelevant, but like lists in that multiplicity is
counted. We can define a type of finite multisets as a quotient of lists by the
relation:
{\par\samepage\setseps\small
\begin{verbatim}
  # let multisame = new_definition
     `multisame l1 l2 <=> !a:A. FILTER (\x. x = a) l1 = FILTER (\x. x = a) l2`;;
\end{verbatim}
}
\noindent as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # let multiset_abs,multiset_rep =
      define_quotient_type "multiset" ("multiset_of_list","list_of_multiset")
      `multisame:A list -> A list -> bool`;;
  val multiset_abs : thm = |- multiset_of_list (list_of_multiset a) = a
  val multiset_rep : thm =
    |- (?x. r = multisame x) <=> list_of_multiset (multiset_of_list r) = r
\end{verbatim}
}
For development of this example, see the documentation entries for
{\small\verb%lift_function%} and {\small\verb%lift_theorem%} (in that order). Similarly we could define a
type of finite sets by:
{\par\samepage\setseps\small
\begin{verbatim}
  define_quotient_type "finiteset" ("finiteset_of_list","list_of_finiteset")
   `\l1 l2. !a:A. MEM a l1 <=> MEM a l2`;;
  val it : thm * thm =
    (|- finiteset_of_list (list_of_finiteset a) = a,
     |- (?x. r = (\l1 l2. !a. MEM a l1 <=> MEM a l2) x) <=>
        list_of_finiteset (finiteset_of_list r) = r)
\end{verbatim}
}

\USES
Convenient creation of quotient structures. Using related functions
{\small\verb%lift_function%} and {\small\verb%lift_theorem%}, functions, relations and theorems can be
lifted from the representing type to the type of equivalence classes. As well
as those shown above, characteristic applications are the definition of
rationals as equivalence classes of pairs of integers under
cross-multiplication, or of `directions' as equivalence classes of vectors
under parallelism.

\COMMENTS
If {\small\verb%R%} is not an equivalence relation, the basic operation of
{\small\verb%define_quotient_type%} will work equally well, but the usefulness of the new
type will be limited. In particular, {\small\verb%lift_function%} and {\small\verb%lift_theorem%} may not
be usable.

\SEEALSO
lift_function, lift_theorem.

\ENDDOC
\DOC{define{\_}type}

\TYPE {\small\verb%define_type : string -> thm * thm%}\egroup

\SYNOPSIS
Automatically define user-specified inductive data types.

\DESCRIBE
The function {\small\verb%define_type%} automatically defines an inductive data type or a
mutually inductive family of them. These may optionally contain nested
instances of other inductive data types. The function returns two theorems that
together identify the type up to isomorphism. The input is just a string
indicating the desired pattern of recursion. The simplest case where we define
a single type is:
{\par\samepage\setseps\small
\begin{verbatim}
   "op = C1 ty ... ty | C2 ty ... ty | ... | Cn ty ... ty"
\end{verbatim}
}
\noindent where {\small\verb%op%} is the name of the type constant or type operator to be
defined, {\small\verb%C1%}, ..., {\small\verb%Cn%} are identifiers, and each {\small\verb%ty%} is either a (logical)
type expression valid in the current theory (in which case {\small\verb%ty%} must not
contain {\small\verb%op%}) or just the identifier "{\small\verb%op%}' itself.

A string of this form describes an n-ary type operator {\small\verb%op%}, where n is the
number of distinct type variables in the types {\small\verb%ty%} on the right hand side of
the equation.  If n is zero then {\small\verb%op%} is a type constant; otherwise {\small\verb%op%} is an
n-ary type operator.  The type described by the specification has {\small\verb%n%} distinct
constructors {\small\verb%C1%}, ..., {\small\verb%Cn%}.  Each constructor {\small\verb%Ci%} is a function that takes
arguments whose types are given by the associated type expressions {\small\verb%ty%} in the
specification. If one or more of the type expressions {\small\verb%ty%} is the type {\small\verb%op%}
itself, then the equation specifies a recursive data type.  In any
specification, at least one constructor must be non-recursive, i.e. all its
arguments must have types which already exist in the current theory.

Each of the types {\small\verb%ty%} above may be built from the type being defined using
other inductive type operators already defined, e.g. {\small\verb%list%}. Moreover, one can
actually have a mutually recursive family of types, where the format is a
sequence of specifications in the above form separated by semicolons:
{\par\samepage\setseps\small
\begin{verbatim}
  "op1 = C1_1 ty ... ty | C1_2 ty ... ty | ... | C1_n1 ty ... ty;
   op2 = C2_1 ty ... ty | ... | C2_n2 ty ... ty;
   ...
   opk = Ck_1 ty ... ty | ... | ... | Ck_nk ty ... ty"
\end{verbatim}
}

Given a type specification of the form described above, {\small\verb%define_type%} makes an
appropriate type definition for the type operator or type operators.  It then
makes appropriate definitions for the constants {\small\verb%Ci_j%} and automatically proves
and returns two theorems that characterize the type up to isomorphism. Roughly,
the first theorem allows one to prove properties over the new (family of) types
by (mutual) induction, while the latter allows one to defined functions by
recursion. Rather than presenting these in full generality, it is probably
easier to consider some simple examples.

\FAILURE
The evaluation fails if one of the types or constructor constants is already
defined, or if there are certain improper kinds of recursion, e.g. involving
function spaces of one of the types being defined.

\EXAMPLE
The following call to {\small\verb%define_type%} defines {\small\verb%tri%} to be a simple enumerated
type with exactly three distinct values:
{\par\samepage\setseps\small
\begin{verbatim}
  # define_type "tri = ONE | TWO | THREE";;
  val it : thm * thm =
    (|- !P. P ONE /\ P TWO /\ P THREE ==> (!x. P x),
     |- !f0 f1 f2. ?fn. fn ONE = f0 /\ fn TWO = f1 /\ fn THREE = f2)
\end{verbatim}
}
\noindent The theorem returned is a degenerate `primitive recursion' theorem
for the concrete type {\small\verb%tri%}.  An example of a recursive type that can be
defined using {\small\verb%define_type%} is a type of binary trees:
{\par\samepage\setseps\small
\begin{verbatim}
  # define_type "btree = LEAF A | NODE btree btree";;
  val it : thm * thm =
    (|- !P. (!a. P (LEAF a)) /\ (!a0 a1. P a0 /\ P a1 ==> P (NODE a0 a1))
            ==> (!x. P x),
     |- !f0 f1.
            ?fn. (!a. fn (LEAF a) = f0 a) /\
                 (!a0 a1. fn (NODE a0 a1) = f1 a0 a1 (fn a0) (fn a1)))
\end{verbatim}
}
\noindent The theorem returned by {\small\verb%define_type%} in this case asserts the unique
existence of functions defined by primitive recursion over labelled binary
trees. For an example of nested recursion, here we use the type of lists in a
nested fashion to define a type of first-order terms:
{\par\samepage\setseps\small
\begin{verbatim}
  # define_type "term = Var num | Fn num (term list)";;
  val it : thm * thm =
    (|- !P0 P1.
            (!a. P0 (Var a)) /\
            (!a0 a1. P1 a1 ==> P0 (Fn a0 a1)) /\
            P1 [] /\
            (!a0 a1. P0 a0 /\ P1 a1 ==> P1 (CONS a0 a1))
            ==> (!x0. P0 x0) /\ (!x1. P1 x1),
     |- !f0 f1 f2 f3.
            ?fn0 fn1.
                (!a. fn1 (Var a) = f0 a) /\
                (!a0 a1. fn1 (Fn a0 a1) = f1 a0 a1 (fn0 a1)) /\
                fn0 [] = f2 /\
                (!a0 a1. fn0 (CONS a0 a1) = f3 a0 a1 (fn1 a0) (fn0 a1)))
\end{verbatim}
}
\noindent and here we have an example of mutual recursion, defining syntax
trees for commands and expressions for a hypothetical programming language:
{\par\samepage\setseps\small
\begin{verbatim}
  # define_type "command = Assign num expression
                         | Ite expression command command;
                 expression = Variable num
                            | Constant num
                            | Plus expression expression
                            | Valof command";;
  val it : thm * thm =
    (|- !P0 P1.
            (!a0 a1. P1 a1 ==> P0 (Assign a0 a1)) /\
            (!a0 a1 a2. P1 a0 /\ P0 a1 /\ P0 a2 ==> P0 (Ite a0 a1 a2)) /\
            (!a. P1 (Variable a)) /\
            (!a. P1 (Constant a)) /\
            (!a0 a1. P1 a0 /\ P1 a1 ==> P1 (Plus a0 a1)) /\
            (!a. P0 a ==> P1 (Valof a))
            ==> (!x0. P0 x0) /\ (!x1. P1 x1),
     |- !f0 f1 f2 f3 f4 f5.
            ?fn0 fn1.
                (!a0 a1. fn0 (Assign a0 a1) = f0 a0 a1 (fn1 a1)) /\
                (!a0 a1 a2.
                     fn0 (Ite a0 a1 a2) =
                     f1 a0 a1 a2 (fn1 a0) (fn0 a1) (fn0 a2)) /\
                (!a. fn1 (Variable a) = f2 a) /\
                (!a. fn1 (Constant a) = f3 a) /\
                (!a0 a1. fn1 (Plus a0 a1) = f4 a0 a1 (fn1 a0) (fn1 a1)) /\
                (!a. fn1 (Valof a) = f5 a (fn0 a)))
\end{verbatim}
}

\SEEALSO
INDUCT_THEN, new_recursive_definition, new_type_abbrev, prove_cases_thm,
prove_constructors_distinct, prove_constructors_one_one, prove_induction_thm,
prove_rec_fn_exists.

\ENDDOC
\DOC{define{\_}type{\_}raw}

\TYPE {\small\verb%define_type_raw : (hol_type * (string * hol_type list) list) list -> thm * thm%}\egroup

\SYNOPSIS
Like {\small\verb%define_type%} but from a more structured representation than a string.

\DESCRIBE
The core functionality of {\small\verb%define_type_raw%} is the same as {\small\verb%define_type%}, but
the input is a more structured format for the type specification. In fact,
{\small\verb%define_type%} is just the composition of {\small\verb%define_type_raw%} and
{\small\verb%parse_inductive_type_specification%}.

\FAILURE
May fail for the usual reasons {\small\verb%define_type%} may.

\USES
Not intended for general use, but sometimes useful in proof tools that want to
generate inductive types.

\SEEALSO
define_type, parse_inductive_type_specification.

\ENDDOC
\DOC{definitions}

\TYPE {\small\verb%definitions : unit -> thm list%}\egroup

\SYNOPSIS
Returns the current set of primitive definitions.

\DESCRIBE
A call {\small\verb%definitions()%} returns the current list of basic definitions made in
the HOL Light kernel.

\FAILURE
Never fails.

\COMMENTS
This is a more logically primitive list than the one maintained in the list
{\small\verb%!the_definitions%}, and is intended mainly for auditing a proof development
that uses axioms to ensure that no axioms and definitions clash. Under normal
circumstances axioms are not used and so this information is not needed.
Definitions returned by {\small\verb%definitions()%} are in their primitive equational form,
and include everything defined in the kernel. By contrast, those in the list
{\small\verb%!the_definitions%} are often quantified and eta-expanded, and the list may be
incomplete since it is only maintained outside the logical kernel as a
convenience.

\SEEALSO
define, new_axiom, new_definition, the_definitions.

\ENDDOC
\DOC{delete{\_}parser}

\TYPE {\small\verb%delete_parser : string -> unit%}\egroup

\SYNOPSIS
Uninstall a user parser.

\DESCRIBE
HOL Light allows user parsing functions to be installed, and will try them on
all terms during parsing before the usual parsers. The call {\small\verb%delete_parser "s"%}
removes any parsers associated with string {\small\verb%"s"%}.

\FAILURE
Never fails, regardless of whether there are any parsers associated with the
string.

\SEEALSO
install_parser, installed_parsers, try_user_parser.

\ENDDOC
\DOC{delete{\_}user{\_}color{\_}printer}

\TYPE {\small\verb%delete_user_color_printer : string -> unit%}\egroup

\SYNOPSIS
Remove user-defined color printer from the HOL Light term printing.

\DESCRIBE
HOL Light allows arbitrary user printers to be inserted into the toplevel
printer so that they are invoked on all applicable subterms (see
{\small\verb%install_user_printer%} and {\small\verb%install_user_color_printer%}).
The call {\small\verb%delete_user_color_printer s%} removes any such printer
associated with the tag {\small\verb%s%} that is registered by {\small\verb%install_user_color_printer%}.

\FAILURE
Never fails, even if there is no printer with the given tag.

\SEEALSO
delete_user_printer, install_user_color_printer, install_user_printer,
try_user_color_printer, try_user_printer.

\ENDDOC
\DOC{delete{\_}user{\_}printer}

\TYPE {\small\verb%delete_user_printer : string -> unit%}\egroup

\SYNOPSIS
Remove user-defined printer from the HOL Light term printing.

\DESCRIBE
HOL Light allows arbitrary user printers to be inserted into the toplevel
printer so that they are invoked on all applicable subterms (see
{\small\verb%install_user_printer%}). The call {\small\verb%delete_user_printer s%} removes any such
printer associated with the tag {\small\verb%s%}.

\FAILURE
Never fails, even if there is no printer with the given tag.

\EXAMPLE
If a user printer has been installed as in the example given for
{\small\verb%install_user_printer%}, it can be removed again by:
{\par\samepage\setseps\small
\begin{verbatim}
  # delete_user_printer "print_typed_var";;
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
delete_user_color_printer, install_user_color_printer, install_user_printer,
try_user_color_printer, try_user_printer.

\ENDDOC
\DOC{denominator}

\TYPE {\small\verb%denominator : num -> num%}\egroup

\SYNOPSIS
Returns denominator of rational number in canonical form.

\DESCRIBE
Given a rational number as supported by the {\small\verb%Num%} library, {\small\verb%denominator%} returns
the denominator $q$ from the rational number cancelled to its reduced form,
$p/q$ where $q > 0$ and $p$ and $q$ have no common factor.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # denominator(Int 22 // Int 7);;
  val it : num = 7
  # denominator(Int 0);;
  val it : num = 1
  # denominator(Int 100);;
  val it : num = 1
  # denominator(Int 4 // Int(-2));;
  val it : num = 1
\end{verbatim}
}

\SEEALSO
numdom, numerator.

\ENDDOC
\DOC{DENUMERAL}

\TYPE {\small\verb%DENUMERAL : thm -> thm%}\egroup

\SYNOPSIS
Remove instances of the {\small\verb%NUMERAL%} constant from a theorem.

\DESCRIBE
The call {\small\verb%DENUMERAL th%} removes from the conclusion of {\small\verb%th%} any instances of
the constant {\small\verb%NUMERAL%}, used in the internal representation of numerals.

\FAILURE
Never fails.

\USES
Only intended for users manipulating the internal structure of numerals.

\SEEALSO
NUM_REDUCE_CONV.

\ENDDOC
\DOC{DEPTH{\_}BINOP{\_}CONV}

\TYPE {\small\verb%DEPTH_BINOP_CONV : term -> (term -> thm) -> term -> thm%}\egroup

\SYNOPSIS
Applied a conversion to the leaves of a tree of binary operator expressions.

\DESCRIBE
If a term {\small\verb%t%} is built up from terms {\small\verb%t1,...,tn%} using a binary operator {\small\verb%op%}
(for example {\small\verb%op (op t1 t2) (op (op t3 t4) t5)%}), the call
{\small\verb%DEPTH_BINOP_CONV `op` cnv t%} will apply the conversion {\small\verb%cnv%} to each {\small\verb%ti%} to
give a theorem {\small\verb%|- ti = ti'%}, and return the equational theorem {\small\verb%|- t = t'%}
where {\small\verb%t'%} results from replacing each {\small\verb%ti%} in {\small\verb%t%} with the corresponding
{\small\verb%ti'%}.

\FAILURE
Fails only if the core conversion {\small\verb%cnv%} fails on one of the chosen subterms.

\EXAMPLE
One can always completely evaluate arithmetic expressions with
{\small\verb%NUM_REDUCE_CONV%}, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_REDUCE_CONV `(1 + 2) + (3 * (4 + 5) + 6) + (7 DIV 8)`;;
  val it : thm = |- (1 + 2) + (3 * (4 + 5) + 6) + 7 DIV 8 = 36
\end{verbatim}
}
However, if one wants for some reason not to reduce the top-level combination
of additions, one can do instead:
{\par\samepage\setseps\small
\begin{verbatim}
  # DEPTH_BINOP_CONV `(+):num->num->num` NUM_REDUCE_CONV
   `(1 + 2)   + (3 * (4 + 5) + 6) + (7 DIV 8)`;;
  val it : thm =
    |- (1 + 2) + (3 * (4 + 5) + 6) + 7 DIV 8 = (1 + 2) + (27 + 6) + 0
    # NUM_REDUCE_CONV `(1 + 2) + (3 * (4 + 5) + 6) + (7 DIV 8)`;;
\end{verbatim}
}
Note that the subterm {\small\verb%`3 * (4 + 5)`%} did get completely evaluated, because the
addition was not part of the toplevel tree, but was nested inside a
multiplication.

\SEEALSO
BINOP_CONV, ONCE_DEPTH_CONV, PROP_ATOM_CONV, TOP_DEPTH_CONV.

\ENDDOC
\DOC{DEPTH{\_}CONV}

\TYPE {\small\verb%DEPTH_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion repeatedly to all the sub-terms of a term, in bottom-up
order.

\DESCRIBE
{\small\verb%DEPTH_CONV c tm%} repeatedly applies the conversion {\small\verb%c%} to all the subterms of
the term {\small\verb%tm%}, including the term {\small\verb%tm%} itself.  The supplied conversion is
applied repeatedly (zero or more times, as is done by {\small\verb%REPEATC%}) to each
subterm until it fails. The conversion is applied to subterms in bottom-up
order.

\FAILURE
{\small\verb%DEPTH_CONV c tm%} never fails but can diverge if the conversion {\small\verb%c%} can be
applied repeatedly to some subterm of {\small\verb%tm%} without failing.

\EXAMPLE
The following example shows how {\small\verb%DEPTH_CONV%} applies a conversion to all
subterms to which it applies:
{\par\samepage\setseps\small
\begin{verbatim}
  # DEPTH_CONV BETA_CONV `(\x. (\y. y + x) 1) 2`;;
  val it : thm = |- (\x. (\y. y + x) 1) 2 = 1 + 2
\end{verbatim}
}
\noindent Here, there are two beta-redexes in the input term, one of which
occurs within the other. {\small\verb%DEPTH_CONV BETA_CONV%} applies beta-conversion to
innermost beta-redex {\small\verb%(\y. y + x) 1%} first.  The outermost beta-redex is then
{\small\verb%(\x. 1 + x) 2%}, and beta-conversion of this redex gives {\small\verb%1 + 2%}.

Because {\small\verb%DEPTH_CONV%} applies a conversion bottom-up, the final result may still
contain subterms to which the supplied conversion applies.  For example, in:
{\par\samepage\setseps\small
\begin{verbatim}
  # DEPTH_CONV BETA_CONV `(\f x. (f x) + 1) (\y.y) 2`;;
  val it : thm = |- (\f x. f x + 1) (\y. y) 2 = (\y. y) 2 + 1
\end{verbatim}
}
\noindent the right-hand side of the result still contains a beta-redex,
because the redex {\small\verb%`(\y.y)2`%} is introduced by virtue an application of
{\small\verb%BETA_CONV%} higher-up in the structure of the input term.  By contrast, in the
example:
{\par\samepage\setseps\small
\begin{verbatim}
  # DEPTH_CONV BETA_CONV `(\f x. (f x)) (\y.y) 2`;;
  val it : thm = |- (\f x. f x) (\y. y) 2 = 2
\end{verbatim}
}
\noindent all beta-redexes are eliminated, because {\small\verb%DEPTH_CONV%} repeats the
supplied conversion (in this case, {\small\verb%BETA_CONV%}) at each subterm (in this case,
at the top-level term).

\USES
If the conversion {\small\verb%c%} implements the evaluation of a function in logic, then
{\small\verb%DEPTH_CONV c%} will do bottom-up evaluation of nested applications of it.
For example, the conversion {\small\verb%ADD_CONV%} implements addition of natural number
constants within the logic. Thus, the effect of:
{\par\samepage\setseps\small
\begin{verbatim}
  # DEPTH_CONV NUM_ADD_CONV `(1 + 2) + (3 + 4 + 5)`;;
  val it : thm = |- (1 + 2) + 3 + 4 + 5 = 15
\end{verbatim}
}
\noindent is to compute the sum represented by the input term.

\SEEALSO
ONCE_DEPTH_CONV, REDEPTH_CONV, TOP_DEPTH_CONV, TOP_SWEEP_CONV.

\ENDDOC
\DOC{DEPTH{\_}SQCONV}

\TYPE {\small\verb%DEPTH_SQCONV : strategy%}\egroup

\SYNOPSIS
Applies simplification repeatedly to all the sub-terms of a term, in bottom-up
order.

\DESCRIBE
HOL Light's simplification functions (e.g. {\small\verb%SIMP_TAC%}) have their traversal
algorithm controlled by a ``strategy''. {\small\verb%DEPTH_SQCONV%} is a strategy
corresponding to {\small\verb%DEPTH_CONV%} for ordinary conversions: simplification is
applied repeatedly to all the sub-terms of a term, in bottom-up
order.

\FAILURE
Not applicable.

\SEEALSO
DEPTH_CONV, ONCE_DEPTH_SQCONV, REDEPTH_SQCONV, TOP_DEPTH_SQCONV,
TOP_SWEEP_SQCONV.

\ENDDOC
\DOC{derive{\_}nonschematic{\_}inductive{\_}relations}

\TYPE {\small\verb%derive_nonschematic_inductive_relations : term -> thm%}\egroup

\SYNOPSIS
Deduce inductive definitions properties from an explicit assignment.

\DESCRIBE
Given a set of clauses as given to {\small\verb%new_inductive_definitions%}, the call
{\small\verb%derive_nonschematic_inductive_relations%} will introduce explicit equational
constraints (``definitions'', though only assumptions of the theorem, not
actually constant definitions) that allow it to deduce those clauses. It will
in general have additional `monotonicity' hypotheses, but these may be
removable by {\small\verb%prove_monotonicity_hyps%}. None of the arguments are treated as
schematic.

\FAILURE
Fails if the format of the clauses is wrong.

\EXAMPLE
Here we try one of the classic examples of a mutually inductive definition,
defining odd-ness and even-ness of natural numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  # (prove_monotonicity_hyps o derive_nonschematic_inductive_relations)
      `even(0) /\ odd(1) /\
       (!n. even(n) ==> odd(n + 1)) /\ (!n. odd(n) ==> even(n + 1))`;;
  val it : thm =
    odd =
    (\a0. !odd' even'.
              (!a0. a0 = 1 \/ (?n. a0 = n + 1 /\ even' n) ==> odd' a0) /\
              (!a1. a1 = 0 \/ (?n. a1 = n + 1 /\ odd' n) ==> even' a1)
              ==> odd' a0),
    even =
    (\a1. !odd' even'.
              (!a0. a0 = 1 \/ (?n. a0 = n + 1 /\ even' n) ==> odd' a0) /\
              (!a1. a1 = 0 \/ (?n. a1 = n + 1 /\ odd' n) ==> even' a1)
              ==> even' a1)
    |- (even 0 /\
        odd 1 /\
        (!n. even n ==> odd (n + 1)) /\
        (!n. odd n ==> even (n + 1))) /\
       (!odd' even'.
            even' 0 /\
            odd' 1 /\
            (!n. even' n ==> odd' (n + 1)) /\
            (!n. odd' n ==> even' (n + 1))
            ==> (!a0. odd a0 ==> odd' a0) /\ (!a1. even a1 ==> even' a1)) /\
       (!a0. odd a0 <=> a0 = 1 \/ (?n. a0 = n + 1 /\ even n)) /\
       (!a1. even a1 <=> a1 = 0 \/ (?n. a1 = n + 1 /\ odd n))
\end{verbatim}
}
\noindent Note that the final theorem has two assumptions that one can think of
as the appropriate explicit definitions of these relations, and the conclusion
gives the rule, induction and cases theorems.

\COMMENTS
Normally, use {\small\verb%prove_inductive_relations_exist%} or {\small\verb%new_inductive_definition%}.
This function is only needed for a very fine level of control.

\SEEALSO
new_inductive_definition, prove_inductive_relations_exist,
prove_monotonicity_hyps.

\ENDDOC
\DOC{derive{\_}strong{\_}induction}

\TYPE {\small\verb%derive_strong_induction : thm * thm -> thm%}\egroup

\SYNOPSIS
Derive stronger induction theorem from inductive definition.

\DESCRIBE
The function {\small\verb%derive_strong_induction%} is applied to a pair of theorems as
returned by {\small\verb%new_inductive_definition%}. The first theorem is the `rule'
theorem, the second the `induction' theorem; the `case' theorem returned by
{\small\verb%new_inductive_definition%} is not needed. It returns a stronger induction
theorem where instances of each inductive predicate occurring in hypotheses
is conjoined with the corresponding inductive relation too.

\FAILURE
Fails if the two input theorems are not of the correct form for rule and
induction theorems returned by {\small\verb%new_inductive_definition%}.

\EXAMPLE
A simple example of a mutually inductive definition is:
{\par\samepage\setseps\small
\begin{verbatim}
  # let eo_RULES,eo_INDUCT, eo_CASES = new_inductive_definition
     `even(0) /\ odd(1) /\
      (!n. even(n) ==> odd(n + 1)) /\
      (!n. odd(n) ==> even(n + 1))`;;
  val eo_RULES : thm =
    |- even 0 /\
       odd 1 /\
       (!n. even n ==> odd (n + 1)) /\
       (!n. odd n ==> even (n + 1))
  val eo_INDUCT : thm =
    |- !odd' even'.
           even' 0 /\
           odd' 1 /\
           (!n. even' n ==> odd' (n + 1)) /\
           (!n. odd' n ==> even' (n + 1))
           ==> (!a0. odd a0 ==> odd' a0) /\ (!a1. even a1 ==> even' a1)
  val eo_CASES : thm =
    |- (!a0. odd a0 <=> a0 = 1 \/ (?n. a0 = n + 1 /\ even n)) /\
       (!a1. even a1 <=> a1 = 0 \/ (?n. a1 = n + 1 /\ odd n))
\end{verbatim}
}
The stronger induction theorem can be derived as follows. Note that it is
similar in form to {\small\verb%eo_INDUCT%} but has stronger hypotheses for two of the
conjuncts in the antecedent.
{\par\samepage\setseps\small
\begin{verbatim}
  # derive_strong_induction(eo_RULES,eo_INDUCT);;
  val it : thm =
    |- !odd' even'.
           even' 0 /\
           odd' 1 /\
           (!n. even n /\ even' n ==> odd' (n + 1)) /\
           (!n. odd n /\ odd' n ==> even' (n + 1))
           ==> (!a0. odd a0 ==> odd' a0) /\ (!a1. even a1 ==> even' a1)
\end{verbatim}
}

\COMMENTS
This function needs to discharge monotonicity theorems as part of its internal
working, just as {\small\verb%new_inductive_definition%} does when the inductive definition
is made. Usually this is automatic and the user doesn't see it, but in
difficult cases, the theorem returned may have additional monotonicity
hypotheses that are unproven. In such cases, you can either try to prove them
manually or extend {\small\verb%monotonicity_theorems%} to make the built-in monotonicity
prover more powerful.

\SEEALSO
new_inductive_definition, prove_inductive_relations_exist,
prove_monotonicity_hyps.

\ENDDOC
\DOC{DESTRUCT{\_}TAC}

\TYPE {\small\verb%DESTRUCT_TAC : string -> thm_tactic%}\egroup

\SYNOPSIS
Performs elimination on a theorem within a tactic proof.

\DESCRIBE
Given a string {\small\verb%s%} and a theorem {\small\verb%th%}, {\small\verb%DESTRUCT_TAC s th%} performs the
elimination of {\small\verb%th%} according with the pattern given in {\small\verb%s%}. The
syntax of the pattern {\small\verb%s%} is the following:

\begin{itemize}

\item An identifier {\small\verb%l%} other than {\small\verb%`_`%} and {\small\verb%`+`%} assumes a hypothesis
  with label {\small\verb%l%}

\item The identifier {\small\verb%`_'%} does nothing (discard the hypothesis)

\item The identifier {\small\verb%`+'%} adds the theorem as antecedent as with MP\_TAC

\item A sequence of patterns (separated by spaces) destructs a conjunction

\item A sequence of pattern separated by {\small\verb%|%} destructs a disjunction

\item A prefix {\small\verb%@x.%} introduces an existential

\end{itemize}

\FAILURE
Fails if the pattern is ill-formed or does not match the form of the theorem.

\EXAMPLE
Here we use the cases theorem for numerals, performing a disjunctive split and
introducing names for the resulting hypotheses:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC `n:num` (cases "num");;
  # g `n = 0 \/ (1 <= n /\ ?m. n = m + 1)`;;
  # e (DESTRUCT_TAC "neq0 | @m. neqsuc" th);;
  val it : goalstack = 2 subgoals (2 total)

    0 [`n = SUC m`] (neqsuc)

  `n = 0 \/ 1 <= n /\ (?m. n = m + 1)`

    0 [`n = 0`] (neq0)

  `n = 0 \/ 1 <= n /\ (?m. n = m + 1)`
\end{verbatim}
}

Here we use the theorem
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC `n+2` EVEN_EXISTS_LEMMA;;
  val th : thm =
    |- (EVEN (n + 2) ==> (?m. n + 2 = 2 * m)) /\
       (~EVEN (n + 2) ==> (?m. n + 2 = SUC (2 * m)))
\end{verbatim}
}
\noindent
adding as antecedent the right-hand side of the disjunction
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!n. ~EVEN n ==> ?a. n + 2 = 2 * a + 1`;;
  # e (REPEAT STRIP_TAC THEN DESTRUCT_TAC "_ +" th);;

  val it : goalstack = 1 subgoal (1 total)

    0 [`~EVEN n`]

  `(~EVEN (n + 2) ==> (?m. n + 2 = SUC (2 * m))) ==> (?a. n + 2 = 2 * a + 1)`
\end{verbatim}
}

\SEEALSO
ASSUME_TAC, CLAIM_TAC, FIX_TAC, GEN_TAC, INTRO_TAC, LABEL_TAC, MP_TAC,
REMOVE_THEN, STRIP_TAC, USE_THEN.

\ENDDOC
\DOC{dest{\_}abs}

\TYPE {\small\verb%dest_abs : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart an abstraction into abstracted variable and body.

\DESCRIBE
{\small\verb%dest_abs%} is a term destructor for abstractions:
{\small\verb%dest_abs `\var. t`%} returns {\small\verb%(`var`,`t`)%}.

\FAILURE
Fails with {\small\verb%dest_abs%} if term is not an abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_abs `\x. x + 1`;;
  val it : term * term = (`x`, `x + 1`)
\end{verbatim}
}

\SEEALSO
dest_comb, dest_const, dest_var, is_abs, mk_abs, strip_abs.

\ENDDOC
\DOC{dest{\_}binary}

\TYPE {\small\verb%dest_binary : string -> term -> term * term%}\egroup

\SYNOPSIS
Breaks apart an instance of a binary operator with given name.

\DESCRIBE
The call {\small\verb%dest_binary s tm%} will, if {\small\verb%tm%} is a binary operator application
{\small\verb%(op l) r%} where {\small\verb%op%} is a constant with name {\small\verb%s%}, return the two arguments to
which it is applied as a pair {\small\verb%l,r%}. Otherwise, it fails. Note that {\small\verb%op%} is
required to be a constant.

\FAILURE
Never fails.

\EXAMPLE
This one succeeds:
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_binary "+" `1 + 2`;;
  val it : term * term = (`1`, `2`)
\end{verbatim}
}

\SEEALSO
dest_binop, is_binary, is_comb, mk_binary.

\ENDDOC
\DOC{dest{\_}binder}

\TYPE {\small\verb%dest_binder : string -> term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a ``binder''.

\DESCRIBE
Applied to a term {\small\verb%tm%} of the form {\small\verb%`c (\x. t)`%} where {\small\verb%c%} is a constant whose
name is {\small\verb%"s"%}, the call {\small\verb%dest_binder "c" tm%} returns {\small\verb%(`x`,`t`)%}. Note that
this is actually independent of whether the name parses as a binder, but the
usual application is where it does.

\FAILURE
Fails if the term is not of the appropriate form with a constant of the same
name.

\EXAMPLE
The call {\small\verb%dest_binder "!"%} is the same as {\small\verb%dest_forall%}, and is in fact how
that function is implemented.

\SEEALSO
dest_abs, dest_comb, dest_const, dest_var.

\ENDDOC
\DOC{dest{\_}binop}

\TYPE {\small\verb%dest_binop : term -> term -> term * term%}\egroup

\SYNOPSIS
Breaks apart an application of a given binary operator to two arguments.

\DESCRIBE
The call {\small\verb%dest_binop op t%}, where {\small\verb%t%} is of the form {\small\verb%(op l) r%}, will return
the pair {\small\verb%l,r%}. If {\small\verb%t%} is not of that form, it fails. Note that {\small\verb%op%} can be any
term; it need not be a constant nor parsed infix.

\FAILURE
Fails if the term is not a binary application of operator {\small\verb%op%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_binop `(+):num->num->num` `1 + 2 + 3`;;
  val it : term * term = (`1`, `2 + 3`)
\end{verbatim}
}

\SEEALSO
dest_binary, is_binary, is_binop, mk_binary, mk_binop.

\ENDDOC
\DOC{dest{\_}char}

\TYPE {\small\verb%dest_char : term -> char%}\egroup

\SYNOPSIS
Produces OCaml character corresponding to object-level character.

\DESCRIBE
{\small\verb%dest_char t%} where {\small\verb%t%} is a term of HOL type {\small\verb%char%}, produces the
corresponding OCaml character.

\FAILURE
Fails if the term is not of type {\small\verb%char%}

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # lhand `"hello"`;;
  val it : term = `ASCII F T T F T F F F`

  # dest_char it;;
  val it : char = 'h'
\end{verbatim}
}

\COMMENTS
There is no particularly convenient parser/printer support for the HOL {\small\verb%char%}
type, but when combined into lists they are considered as strings and provided
with more intuitive parser/printer support.

\SEEALSO
dest_string, mk_char, mk_string.

\ENDDOC
\DOC{dest{\_}comb}

\TYPE {\small\verb%dest_comb : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a combination (function application) into rator and rand.

\DESCRIBE
{\small\verb%dest_comb%} is a term destructor for combinations:
{\par\samepage\setseps\small
\begin{verbatim}
   dest_comb `t1 t2`
\end{verbatim}
}
\noindent returns {\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_comb%} if term is not a combination.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_comb `SUC 0`;;
  val it : term * term = (`SUC`, `0`)
\end{verbatim}
}
We can use {\small\verb%dest_comb%} to reveal more about the internal representation of
numerals:
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_comb `12`;;
  val it : term * term = (`NUMERAL`, `BIT0 (BIT0 (BIT1 (BIT1 _0)))`)
\end{verbatim}
}

\SEEALSO
dest_abs, dest_const, dest_var, is_comb, list_mk_comb, mk_comb, strip_comb.

\ENDDOC
\DOC{dest{\_}cond}

\TYPE {\small\verb%dest_cond : term -> term * (term * term)%}\egroup

\SYNOPSIS
Breaks apart a conditional into the three terms involved.

\DESCRIBE
{\small\verb%dest_cond%} is a term destructor for conditionals:
{\par\samepage\setseps\small
\begin{verbatim}
   dest_cond `if t then t1 else t2`
\end{verbatim}
}
\noindent returns {\small\verb%(`t`,`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_cond%} if term is not a conditional.

\SEEALSO
mk_cond, is_cond.

\ENDDOC
\DOC{dest{\_}conj}

\TYPE {\small\verb%dest_conj : term -> term * term%}\egroup

\SYNOPSIS
Term destructor for conjunctions.

\DESCRIBE
{\small\verb%dest_conj(`t1 /\ t2`)%} returns {\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_conj%} if term is not a conjunction.

\SEEALSO
is_conj, mk_conj.

\ENDDOC
\DOC{dest{\_}cons}

\TYPE {\small\verb%dest_cons : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a `CONS pair' into head and tail.

\DESCRIBE
{\small\verb%dest_cons%} is a term destructor for `CONS pairs'. When applied to a term
representing a nonempty list {\small\verb%`[t;t1;...;tn]`%} (which is equivalent to {\small\verb%`CONS t
[t1;...;tn]`%}), it returns the pair of terms {\small\verb%(`t`,`[t1;...;tn]`)%}.

\FAILURE
Fails with {\small\verb%dest_cons%} if the term is not a non-empty list.

\SEEALSO
dest_list, is_cons, is_list, mk_cons, mk_list.

\ENDDOC
\DOC{dest{\_}const}

\TYPE {\small\verb%dest_const : term -> string * hol_type%}\egroup

\SYNOPSIS
Breaks apart a constant into name and type.

\DESCRIBE
{\small\verb%dest_const%} is a term destructor for constants:
{\par\samepage\setseps\small
\begin{verbatim}
   dest_const `const:ty`
\end{verbatim}
}
\noindent returns {\small\verb%("const",`:ty`)%}.

\FAILURE
Fails with {\small\verb%dest_const%} if term is not a constant.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_const `T`;;
  val it : string * hol_type = ("T", `:bool`)
\end{verbatim}
}

\SEEALSO
dest_abs, dest_comb, dest_var, is_const, mk_const, mk_mconst, name_of.

\ENDDOC
\DOC{dest{\_}disj}

\TYPE {\small\verb%dest_disj : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a disjunction into the two disjuncts.

\DESCRIBE
{\small\verb%dest_disj%} is a term destructor for disjunctions:
{\par\samepage\setseps\small
\begin{verbatim}
   dest_disj `t1 \/ t2`
\end{verbatim}
}
\noindent returns {\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_disj%} if term is not a disjunction.

\SEEALSO
is_disj, mk_disj.

\ENDDOC
\DOC{dest{\_}eq}

\TYPE {\small\verb%dest_eq : term -> term * term%}\egroup

\SYNOPSIS
Term destructor for equality.

\DESCRIBE
{\small\verb%dest_eq(`t1 = t2`)%} returns {\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_eq%} if term is not an equality.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_eq `2 + 2 = 4`;;
  val it : term * term = (`2 + 2`, `4`)
\end{verbatim}
}

\SEEALSO
is_eq, mk_eq.

\ENDDOC
\DOC{dest{\_}exists}

\TYPE {\small\verb%dest_exists : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart an existentially quantified term into quantified variable and
body.

\DESCRIBE
{\small\verb%dest_exists%} is a term destructor for existential quantification:
{\small\verb%dest_exists `?var. t`%} returns {\small\verb%(`var`,`t`)%}.

\FAILURE
Fails with {\small\verb%dest_exists%} if term is not an existential quantification.

\SEEALSO
is_exists, mk_exists, strip_exists.

\ENDDOC
\DOC{dest{\_}finty}

\TYPE {\small\verb%dest_finty : hol_type -> num%}\egroup

\SYNOPSIS
Converts a standard finite type to corresponding integer.

\DESCRIBE
Finite types parsed and printed as numerals are provided, and this operation
when applied to such a type gives the corresponding number.

\FAILURE
Fails if the type is not a standard finite type.

\EXAMPLE
Here we use a 32-element type, perhaps useful for indexing the bits of a
word:
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_finty `:32`;;
  val it : num = 32
\end{verbatim}
}

\SEEALSO
dest_type, DIMINDEX_CONV, DIMINDEX_TAC, HAS_SIZE_DIMINDEX_RULE, mk_finty.

\ENDDOC
\DOC{dest{\_}forall}

\TYPE {\small\verb%dest_forall : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a universally quantified term into quantified variable and body.

\DESCRIBE
{\small\verb%dest_forall%} is a term destructor for universal quantification:
{\small\verb%dest_forall `!var. t`%} returns {\small\verb%(`var`,`t`)%}.

\FAILURE
Fails with {\small\verb%dest_forall%} if term is not a universal quantification.

\SEEALSO
is_forall, mk_forall, strip_forall.

\ENDDOC
\DOC{dest{\_}fun{\_}ty}

\TYPE {\small\verb%dest_fun_ty : hol_type -> hol_type * hol_type%}\egroup

\SYNOPSIS
Break apart a function type into domain and range.

\DESCRIBE
The call {\small\verb%dest_fun_ty `:s->t`%} breaks apart the function type {\small\verb%s->t%} and
returns the pair {\small\verb%`:s`,`:t`%}.

\FAILURE
Fails if the type given as argument is not a function type (constructor
{\small\verb%"fun"%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_fun_ty `:A->B`;;
  val it : hol_type * hol_type = (`:A`, `:B`)

  # dest_fun_ty `:num->num->bool`;;
  val it : hol_type * hol_type = (`:num`, `:num->bool`)

  # dest_fun_ty `:A#B`;;
  Exception: Failure "dest_fun_ty".
\end{verbatim}
}

\SEEALSO
dest_type, mk_fun_ty.

\ENDDOC
\DOC{dest{\_}gabs}

\TYPE {\small\verb%dest_gabs : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a generalized abstraction into abstracted varstruct and body.

\DESCRIBE
{\small\verb%dest_pabs%} is a term destructor for generalized abstractions: for example with
a paired varstruct the effect on {\small\verb%dest_pabs `\(v1..(..)..vn). t`%} is to return
the pair {\small\verb%(`(v1..(..)..vn)`,`t`)%}. It will also act as for {\small\verb%dest_abs%} on basic
abstractions.

\FAILURE
Fails unless the term is a basic or generalized abstraction.

\EXAMPLE
These are fairly typical applications:
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_gabs `\(x,y). x + y`;;
  val it : term * term = (`x,y`, `x + y`)

  # dest_gabs `\(CONS h t). h + 1`;;
  val it : term * term = (`CONS h t`, `h + 1`)
\end{verbatim}
}
\noindent while the following shows that it also works on basic abstractions:
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_gabs `\x. x`;;
  Warning: inventing type variables
  val it : term * term = (`x`, `x`)
\end{verbatim}
}

\SEEALSO
GEN_BETA_CONV, is_gabs, mk_gabs, strip_gabs.

\ENDDOC
\DOC{dest{\_}iff}

\TYPE {\small\verb%dest_iff : term -> term * term%}\egroup

\SYNOPSIS
Term destructor for logical equivalence.

\DESCRIBE
{\small\verb%dest_iff(`t1 <=> t2`)%} returns {\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with if term is not a logical equivalence, i.e. an equation between terms
of Boolean type.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_iff `x = y <=> y = 1`;;
  val it : term * term = (`x = y`, `y = 1`)
\end{verbatim}
}

\COMMENTS
The function {\small\verb%dest_eq%} has the same effect, but the present function checks
that the types of the two sides are indeed Boolean, whereas {\small\verb%dest_eq%} will
break apart any equation.

\SEEALSO
dest_eq, is_iff, mk_iff.

\ENDDOC
\DOC{dest{\_}imp}

\TYPE {\small\verb%dest_imp : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart an implication into antecedent and consequent.

\DESCRIBE
{\small\verb%dest_imp%} is a term destructor for implications. Thus
{\par\samepage\setseps\small
\begin{verbatim}
   dest_imp `t1 ==> t2`
\end{verbatim}
}
\noindent returns
{\par\samepage\setseps\small
\begin{verbatim}
   (`t1`,`t2`)
\end{verbatim}
}
\FAILURE
Fails with {\small\verb%dest_imp%} if term is not an implication.

\SEEALSO
is_imp, mk_imp, strip_imp.

\ENDDOC
\DOC{dest{\_}intconst}

\TYPE {\small\verb%dest_intconst : term -> num%}\egroup

\SYNOPSIS
Converts an integer literal of type {\small\verb%:int%} to an OCaml number.

\DESCRIBE
The call {\small\verb%dest_intconst t%} where {\small\verb%t%} is a canonical integer literal of type
{\small\verb%:int%}, returns the corresponding OCaml number (type {\small\verb%num%}). The permissible
forms of integer literals are `{\small\verb%&n%}' for a numeral {\small\verb%n%} or `{\small\verb%-- &n%}' for a
nonzero numeral {\small\verb%n%}.

\FAILURE
Fails if applied to a term that is not a canonical integer literal of type
{\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_intconst `-- &11 :int`;;
  val it : num = -11
\end{verbatim}
}

\SEEALSO
dest_realintconst, is_intconst, mk_intconst.

\ENDDOC
\DOC{dest{\_}let}

\TYPE {\small\verb%dest_let : term -> (term * term) list * term%}\egroup

\SYNOPSIS
Breaks apart a let-expression.

\DESCRIBE
{\small\verb%dest_let%} is a term destructor for general let-expressions:
{\small\verb%dest_let `let x1 = e1 and ... and xn = en in E`%} returns a pair
of the list {\small\verb%[`x1`,`e1`; ... ; `xn`,`en`]%} and {\small\verb%`E`%}.

\FAILURE
Fails with {\small\verb%dest_let%} if term is not a {\small\verb%let%}-expression.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_let `let m = 256 and n = 65536 in (x MOD m + y MOD m) MOD n`;;
  val it : (term * term) list * term =
    ([(`m`, `256`); (`n`, `65536`)], `(x MOD m + y MOD m) MOD n`)
\end{verbatim}
}
\SEEALSO
mk_let, is_let.

\ENDDOC
\DOC{dest{\_}list}

\TYPE {\small\verb%dest_list : term -> term list%}\egroup

\SYNOPSIS
Iteratively breaks apart a list term.

\DESCRIBE
{\small\verb%dest_list%} is a term destructor for lists:
{\small\verb%dest_list(`[t1;...;tn]:(ty)list`)%} returns {\small\verb%[`t1`;...;`tn`]%}.

\FAILURE
Fails with {\small\verb%dest_list%} if the term is not a list.

\SEEALSO
dest_cons, dest_setenum, is_cons, is_list, mk_cons, mk_list.

\ENDDOC
\DOC{dest{\_}neg}

\TYPE {\small\verb%dest_neg : term -> term%}\egroup

\SYNOPSIS
Breaks apart a negation, returning its body.

\DESCRIBE
{\small\verb%dest_neg%} is a term destructor for negations:
{\small\verb%dest_neg `~t`%} returns {\small\verb%`t`%}.

\FAILURE
Fails with {\small\verb%dest_neg%} if term is not a negation.

\SEEALSO
is_neg, mk_neg.

\ENDDOC
\DOC{dest{\_}numeral}

\TYPE {\small\verb%dest_numeral : term -> num%}\egroup

\SYNOPSIS
Converts a HOL numeral term to unlimited-precision integer.

\DESCRIBE
The call {\small\verb%dest_numeral t%} where {\small\verb%t%} is the HOL numeral representation of {\small\verb%n%},
returns {\small\verb%n%} as an unlimited-precision intger (type {\small\verb%num%}). It fails if the term
is not a numeral.

\FAILURE
Fails if the term is not a numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_numeral `0`;;
  val it : num = 0

  # dest_numeral `18446744073709551616`;;
  val it : num = 18446744073709551616
\end{verbatim}
}

\COMMENTS
The similar function {\small\verb%dest_small_numeral%} maps to a machine integer, which
means it may overflow. So the use of {\small\verb%dest_numeral%} is better unless you are
very sure of the range.
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_small_numeral `18446744073709551616`;;
  Exception: Failure "int_of_big_int".
\end{verbatim}
}

\SEEALSO
dest_small_numeral, is_numeral, mk_numeral, mk_small_numeral, rat_of_term.

\ENDDOC
\DOC{dest{\_}pair}

\TYPE {\small\verb%dest_pair : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a pair into two separate terms.

\DESCRIBE
{\small\verb%dest_pair%} is a term destructor for pairs: {\small\verb%dest_pair `(t1,t2)`%} returns
{\small\verb%(`t1`,`t2`)%}.

\FAILURE
Fails with {\small\verb%dest_pair%} if term is not a pair.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_pair `(1,2),(3,4),(5,6)`;;
  val it : term * term = (`1,2`, `(3,4),5,6`)
\end{verbatim}
}

\SEEALSO
dest_cons, is_pair, mk_pair.

\ENDDOC
\DOC{dest{\_}realintconst}

\TYPE {\small\verb%dest_realintconst : term -> num%}\egroup

\SYNOPSIS
Converts an integer literal of type {\small\verb%:real%} to an OCaml number.

\DESCRIBE
The call {\small\verb%dest_realintconst t%} where {\small\verb%t%} is a canonical integer literal of type
{\small\verb%:real%}, returns the corresponding OCaml number (type {\small\verb%num%}). The permissible
forms of integer literals are `{\small\verb%&n%}' for a numeral {\small\verb%n%} or `{\small\verb%-- &n%}' for a
nonzero numeral {\small\verb%n%}.

\FAILURE
Fails if applied to a term that is not a canonical integer literal of type
{\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_realintconst `-- &27 :real`;;
  val it : num = -27
\end{verbatim}
}

\SEEALSO
dest_intconst, is_realintconst, mk_realintconst, rat_of_term.

\ENDDOC
\DOC{dest{\_}select}

\TYPE {\small\verb%dest_select : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a choice term into selected variable and body.

\DESCRIBE
{\small\verb%dest_select%} is a term destructor for choice terms:
{\par\samepage\setseps\small
\begin{verbatim}
   dest_select `@var. t`
\end{verbatim}
}
\noindent returns {\small\verb%(`var`,`t`)%}.

\FAILURE
Fails with {\small\verb%dest_select%} if term is not an epsilon-term.

\SEEALSO
mk_select, is_select.

\ENDDOC
\DOC{dest{\_}setenum}

\TYPE {\small\verb%dest_setenum : term -> term list%}\egroup

\SYNOPSIS
Breaks apart a set enumeration.

\DESCRIBE
{\small\verb%dest_setenum%} is a term destructor for set enumerations:
{\small\verb%dest_setenum `{t1,...,tn}`%} returns {\small\verb%[`t1`;...;`tn`]%}. Note that the list
follows the syntactic pattern of the set enumeration, even if it contains
duplicates. (The underlying set is still a set logically, of course, but can be
represented redundantly.)

\FAILURE
Fails if the term is not a set enumeration.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_setenum `{1,2,3,4}`;;
  val it : term list = [`1`; `2`; `3`; `4`]

  # dest_setenum `{1,2,1,2}`;;
  val it : term list = [`1`; `2`; `1`; `2`]
\end{verbatim}
}

\SEEALSO
dest_list, is_setenum, mk_fset, mk_setenum.

\ENDDOC
\DOC{dest{\_}small{\_}numeral}

\TYPE {\small\verb%dest_small_numeral : term -> int%}\egroup

\SYNOPSIS
Converts a HOL numeral term to machine integer.

\DESCRIBE
The call {\small\verb%dest_small_numeral t%} where {\small\verb%t%} is the HOL numeral representation of
{\small\verb%n%}, returns {\small\verb%n%} as an OCaml machine integer. It fails if the term is not a
numeral or the result doesn't fit in a machine integer.

\FAILURE
Fails if the term is not a numeral or if the result doesn't fit in a machine
integer.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_small_numeral `12`;;
  val it : int = 12

  # dest_small_numeral `18446744073709551616`;;
  Exception: Failure "int_of_big_int".
\end{verbatim}
}

\COMMENTS
If overflow is a danger, you may be better off using OCaml type {\small\verb%num%} and the
analogous function {\small\verb%dest_numeral%}. However, none of HOL's inference rules
depend on the behaviour of machine integers, so logical soundness is not an
issue.

\SEEALSO
dest_numeral, is_numeral, mk_numeral, mk_small_numeral, rat_of_term.

\ENDDOC
\DOC{dest{\_}string}

\TYPE {\small\verb%dest_string : term -> string%}\egroup

\SYNOPSIS
Produces OCaml string corresponding to object-level string.

\DESCRIBE
{\small\verb%dest_string t%} where {\small\verb%t%} is a literal string in the HOL object logic of type
{\small\verb%string%} (which is an abbreviation for {\small\verb%char list%}), produces the corresponding
OCaml string.

\FAILURE
Fails if the term is not a literal term of type {\small\verb%string%}

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_string `"HOL"`;;
  val it : string = "HOL"
\end{verbatim}
}

\SEEALSO
dest_char, dest_list, mk_char, mk_list, mk_string.

\ENDDOC
\DOC{dest{\_}thm}

\TYPE {\small\verb%dest_thm : thm -> term list * term%}\egroup

\SYNOPSIS
Breaks a theorem into assumption list and conclusion.

\DESCRIBE
{\small\verb%dest_thm (t1,...,tn |- t)%} returns {\small\verb%([`t1`;...;`tn`],`t`)%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_thm (ASSUME `1 = 0`);;
  val it : term list * term = ([`1 = 0`], `1 = 0`)
\end{verbatim}
}

\SEEALSO
concl, hyp.

\ENDDOC
\DOC{dest{\_}type}

\TYPE {\small\verb%dest_type : hol_type -> string * hol_type list%}\egroup

\SYNOPSIS
Breaks apart a type (other than a variable type).

\DESCRIBE
{\small\verb%dest_type(`:(ty1,...,tyn)op`)%} returns {\small\verb%("op",[`:ty1`;...;`:tyn`])%}.

\FAILURE
Fails with {\small\verb%dest_type%} if the type is a type variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_type `:bool`;;
  val it : string * hol_type list = ("bool", [])

  # dest_type `:(bool)list`;;
  val it : string * hol_type list = ("list", [`:bool`])

  # dest_type `:num -> bool`;;
  val it : string * hol_type list = ("fun", [`:num`; `:bool`])
\end{verbatim}
}

\SEEALSO
mk_type, dest_vartype.

\ENDDOC
\DOC{dest{\_}uexists}

\TYPE {\small\verb%dest_uexists : term -> term * term%}\egroup

\SYNOPSIS
Breaks apart a unique existence term.

\DESCRIBE
If {\small\verb%t%} has the form {\small\verb%?!x. p[x]%} (there exists a unique [x%} such that {\small\verb%p[x]%}
then {\small\verb%dest_uexists t%} returns the pair {\small\verb%x,p[x]%}; otherwise it fails.

\FAILURE
Fails if the term is not a `unique existence' term.

\SEEALSO
dest_exists, dest_forall, is_uexists.

\ENDDOC
\DOC{dest{\_}var}

\TYPE {\small\verb%dest_var : term -> string * hol_type%}\egroup

\SYNOPSIS
Breaks apart a variable into name and type.

\DESCRIBE
{\small\verb%dest_var `var:ty`%} returns {\small\verb%("var",`:ty`)%}.

\FAILURE
Fails with {\small\verb%dest_var%} if term is not a variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_var `x:num`;;
  val it : string * hol_type = ("x", `:num`)
\end{verbatim}
}

\SEEALSO
mk_var, is_var, dest_const, dest_comb, dest_abs, name_of.

\ENDDOC
\DOC{dest{\_}vartype}

\TYPE {\small\verb%dest_vartype : hol_type -> string%}\egroup

\SYNOPSIS
Breaks a type variable down to its name.

\DESCRIBE
{\small\verb%dest_vartype ":A"%} returns {\small\verb%"A"%} when {\small\verb%A%} is a type variable.

\FAILURE
Fails with {\small\verb%dest_vartype%} if the type is not a type variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dest_vartype `:A`;;
  val it : string = "A"

  # dest_vartype `:A->B`;;
  Exception: Failure "dest_vartype: type constructor not a variable".
\end{verbatim}
}
\SEEALSO
mk_vartype, is_vartype, dest_type.

\ENDDOC
\DOC{DIMINDEX{\_}CONV}

\TYPE {\small\verb%DIMINDEX_CONV : conv%}\egroup

\SYNOPSIS
Computes the {\small\verb%dimindex%} for a standard finite type.

\DESCRIBE
Finite types parsed and printed as numerals are provided, and this conversion
when applied to a term of the form {\small\verb%`dimindex (:n)`%} returns the theorem
{\small\verb%|- dimindex(:n) = n%} where the {\small\verb%n%} on the right is a numeral term.

\FAILURE
Fails if the term is not of the form {\small\verb%`dimindex (:n)`%} for a standard finite
type.

\EXAMPLE
Here we use a 32-element type, perhaps useful for indexing the bits of a
word:
{\par\samepage\setseps\small
\begin{verbatim}
  # DIMINDEX_CONV `dimindex(:32)`;;
  val it : thm = |- dimindex (:32) = 32
\end{verbatim}
}

\USES
In conjunction with Cartesian powers such as {\small\verb%real^3%}, where only the size of
the indexing type is relevant and the simple name {\small\verb%n%} is intuitive.

\SEEALSO
dest_finty, DIMINDEX_TAC, HAS_SIZE_DIMINDEX_RULE, mk_finty.

\ENDDOC
\DOC{DIMINDEX{\_}TAC}

\TYPE {\small\verb%DIMINDEX_TAC : tactic%}\egroup

\SYNOPSIS
Solves subterms of a goal by computing the {\small\verb%dimindex%} for standard finite types.

\DESCRIBE
Finite types parsed and printed as numerals are provided, and this tactic
simplfies subterms of a goal of the form {\small\verb%`dimindex (:n)`%} to a simple numeral
{\small\verb%`n`%}.

\FAILURE
Never fails

\EXAMPLE
We set up the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `dimindex(:64) = 2 * dimindex(:32)`;;
\end{verbatim}
}
and simplify it by
{\par\samepage\setseps\small
\begin{verbatim}
# e DIMINDEX_TAC;;
val it : goalstack = 1 subgoal (1 total)

`64 = 2 * 32`
\end{verbatim}
}
after which simply {\small\verb%ARITH_TAC%} would finish the goal.

\SEEALSO
dest_finty, DIMINDEX_CONV, HAS_SIZE_DIMINDEX_RULE, mk_finty.

\ENDDOC
\DOC{DISCH}

\TYPE {\small\verb%DISCH : term -> thm -> thm%}\egroup

\SYNOPSIS
Discharges an assumption.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t
--------------------  DISCH `u`
 A - {u} |- u ==> t
\end{verbatim}
}
\FAILURE
{\small\verb%DISCH%} will fail if {\small\verb%`u`%} is not boolean.

\COMMENTS
The term {\small\verb%`u`%} need not be a hypothesis.  Discharging {\small\verb%`u`%} will remove any
identical and alpha-equivalent hypotheses.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DISCH `p /\ q` (CONJUNCT1(ASSUME `p /\ q`));;
  val it : thm = |- p /\ q ==> p
\end{verbatim}
}

\SEEALSO
DISCH_ALL, DISCH_TAC, DISCH_THEN, STRIP_TAC, UNDISCH, UNDISCH_ALL, UNDISCH_TAC.

\ENDDOC
\DOC{DISCH{\_}ALL}

\TYPE {\small\verb%DISCH_ALL : thm -> thm%}\egroup

\SYNOPSIS
Discharges all hypotheses of a theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
         A1, ..., An |- t
   ----------------------------  DISCH_ALL
    |- A1 ==> ... ==> An ==> t
\end{verbatim}
}

\FAILURE
{\small\verb%DISCH_ALL%} will not fail if there are no hypotheses to discharge, it will
simply return the theorem unchanged.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # end_itlist CONJ (map ASSUME [`p:bool`; `q:bool`; `r:bool`]);;
  val it : thm = p, q, r |- p /\ q /\ r

  # DISCH_ALL it;;
  val it : thm = |- r ==> q ==> p ==> p /\ q /\ r
\end{verbatim}
}

\COMMENTS
Users should not rely on the hypotheses being discharged in any particular
order.  Two or more alpha-convertible hypotheses will be discharged by a
single implication; users should not rely on which hypothesis appears in the
implication.

\SEEALSO
DISCH, DISCH_TAC, DISCH_THEN, STRIP_TAC, UNDISCH, UNDISCH_ALL, UNDISCH_TAC.

\ENDDOC
\DOC{DISCH{\_}TAC}

\TYPE {\small\verb%DISCH_TAC : tactic%}\egroup

\SYNOPSIS
Moves the antecedent of an implicative goal into the assumptions.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- u ==> v
   ==============  DISCH_TAC
    A u {u} ?- v
\end{verbatim}
}
\noindent Note that {\small\verb%DISCH_TAC%} treats {\small\verb%`~u`%} as {\small\verb%`u ==> F`%}, so will also work
when applied to a goal with a negated conclusion.

\FAILURE
{\small\verb%DISCH_TAC%} will fail for goals which are not implications or negations.

\USES
Solving goals of the form {\small\verb%`u ==> v`%} by rewriting {\small\verb%`v`%} with {\small\verb%`u`%}, although
the use of {\small\verb%DISCH_THEN%} is usually more elegant in such cases.

\COMMENTS
If the antecedent already appears in the assumptions, it will be duplicated.

\SEEALSO
DISCH, DISCH_ALL, DISCH_THEN, STRIP_TAC, UNDISCH, UNDISCH_ALL, UNDISCH_TAC.

\ENDDOC
\DOC{DISCH{\_}THEN}

\TYPE {\small\verb%DISCH_THEN : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Undischarges an antecedent of an implication and passes it to a theorem-tactic.

\DESCRIBE
{\small\verb%DISCH_THEN%} removes the antecedent and then creates a theorem by {\small\verb%ASSUME%}ing
it. This new theorem is passed to the theorem-tactic given as {\small\verb%DISCH_THEN%}'s
argument. The consequent tactic is then applied. Thus:
{\par\samepage\setseps\small
\begin{verbatim}
   DISCH_THEN ttac (asl ?- t1 ==> t2) = ttac (ASSUME `t1`) (asl ?- t2)
\end{verbatim}
}
\noindent For example, if
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   ========  ttac (ASSUME `u`)
    B ?- v
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- u ==> t
   ==============  DISCH_THEN ttac
       B ?- v
\end{verbatim}
}
\noindent Note that {\small\verb%DISCH_THEN%} treats {\small\verb%`~u`%} as {\small\verb%`u ==> F`%}.

\FAILURE
{\small\verb%DISCH_THEN%} will fail for goals that are not implications or negations.

\EXAMPLE
Given the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x. x = 0 ==> f(x) * x = x + 2 * x`;;
\end{verbatim}
}
\noindent we can discharge the antecedent and substitute with it immediately
by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(GEN_TAC THEN DISCH_THEN SUBST1_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `f 0 * 0 = 0 + 2 * 0`
\end{verbatim}
}
\noindent and now {\small\verb%REWRITE_TAC[ADD_CLAUSES; MULT_CLAUSES]%} will finish the job.

\COMMENTS
The tactical {\small\verb%REFUTE_THEN%} provides a more general classical `assume otherwise'
function.

\SEEALSO
DISCH, DISCH_ALL, DISCH_TAC, REFUTE_THEN, STRIP_TAC, UNDISCH, UNDISCH_ALL,
UNDISCH_TAC.

\ENDDOC
\DOC{DISJ1}

\TYPE {\small\verb%DISJ1 : thm -> term -> thm%}\egroup

\SYNOPSIS
Introduces a right disjunct into the conclusion of a theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
       A |- t1
   ---------------  DISJ1 (A |- t1) `t2`
    A |- t1 \/ t2
\end{verbatim}
}
\FAILURE
Fails unless the term argument is boolean.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DISJ1 TRUTH `F`;;
  val it : thm = |- T \/ F
\end{verbatim}
}

\SEEALSO
DISJ1_TAC, DISJ2, DISJ2_TAC, DISJ_CASES.

\ENDDOC
\DOC{DISJ1{\_}TAC}

\TYPE {\small\verb%DISJ1_TAC : tactic%}\egroup

\SYNOPSIS
Selects the left disjunct of a disjunctive goal.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
   A ?- t1 \/ t2
  ===============  DISJ1_TAC
     A ?- t1
\end{verbatim}
}

\FAILURE
Fails if the goal is not a disjunction.

\SEEALSO
DISJ1, DISJ2, DISJ2_TAC.

\ENDDOC
\DOC{DISJ2}

\TYPE {\small\verb%DISJ2 : term -> thm -> thm%}\egroup

\SYNOPSIS
Introduces a left disjunct into the conclusion of a theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
      A |- t2
   ---------------  DISJ2 `t1`
    A |- t1 \/ t2
\end{verbatim}
}
\FAILURE
Fails if the term argument is not boolean.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DISJ2 `F` TRUTH;;
  val it : thm = |- F \/ T
\end{verbatim}
}

\SEEALSO
DISJ1, DISJ1_TAC, DISJ2_TAC, DISJ_CASES.

\ENDDOC
\DOC{DISJ2{\_}TAC}

\TYPE {\small\verb%DISJ2_TAC : tactic%}\egroup

\SYNOPSIS
Selects the right disjunct of a disjunctive goal.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t1 \/ t2
   ===============  DISJ2_TAC
       A ?- t2
\end{verbatim}
}

\FAILURE
Fails if the goal is not a disjunction.

\SEEALSO
DISJ1, DISJ1_TAC, DISJ2.

\ENDDOC
\DOC{disjuncts}

\TYPE {\small\verb%disjuncts : term -> term list%}\egroup

\SYNOPSIS
Iteratively breaks apart a disjunction.

\DESCRIBE
If a term {\small\verb%t%} is a disjunction {\small\verb%p \/ q%}, then {\small\verb%disjuncts t%} will recursively
break down {\small\verb%p%} and {\small\verb%q%} into disjuncts and append the resulting lists. Otherwise
it will return the singleton list {\small\verb%[t]%}. So if {\small\verb%t%} is of the form
{\small\verb%t1 \/ ... \/ tn%} with any reassociation, no {\small\verb%ti%} itself being a disjunction,
the list returned will be {\small\verb%[t1; ...; tn]%}. But
{\par\samepage\setseps\small
\begin{verbatim}
   disjuncts(list_mk_disj([t1;...;tn]))
\end{verbatim}
}
\noindent will not return {\small\verb%[t1;...;tn]%} if any of {\small\verb%t1%},...,{\small\verb%tn%} is a
disjunction.

\FAILURE
Never fails, even if the term is not boolean.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_disj [`a \/ b`;`c \/ d`;`e \/ f`];;
  val it : term = `(a \/ b) \/ (c \/ d) \/ e \/ f`

  # disjuncts it;;
  val it : term list = [`a`; `b`; `c`; `d`; `e`; `f`]

  # disjuncts `1`;;
  val it : term list = [`1`]
\end{verbatim}
}

\COMMENTS
Because {\small\verb%disjuncts%} splits both the left and right sides of a disjunction,
this operation is not the inverse of {\small\verb%list_mk_disj%}. You can also use
{\small\verb%splitlist dest_disj%} to split in a right-associated way only.

\SEEALSO
conjuncts, dest_disj, list_mk_disj.

\ENDDOC
\DOC{DISJ{\_}ACI{\_}RULE}

\TYPE {\small\verb%DISJ_ACI_RULE : term -> thm%}\egroup

\SYNOPSIS
Proves equivalence of two disjunctions containing same set of disjuncts.

\DESCRIBE
The call {\small\verb%DISJ_ACI_RULE `t1 \/ ... \/ tn <=> u1 \/ ... \/ um`%}, where both
sides of the equation are disjunctions of exactly the same set of disjuncts,
(with arbitrary ordering, association, and repetitions), will return the
corresponding theorem {\small\verb%|- t1 \/ ... \/ tn <=> u1 \/ ... \/ um%}.

\FAILURE
Fails if applied to a term that is not a Boolean equation or the two sets of
disjuncts are different.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DISJ_ACI_RULE `(p \/ q) \/ (q \/ r) <=> r \/ q \/ p`;;
  val it : thm = |- (p \/ q) \/ q \/ r <=> r \/ q \/ p
\end{verbatim}
}

\COMMENTS
The same effect can be had with the more general {\small\verb%AC%} construct. However, for
the special case of disjunction, {\small\verb%DISJ_ACI_RULE%} is substantially more
efficient when there are many disjuncts involved.

\SEEALSO
AC, CONJ_ACI_RULE, DISJ_CANON_CONV.

\ENDDOC
\DOC{DISJ{\_}CANON{\_}CONV}

\TYPE {\small\verb%DISJ_CANON_CONV : term -> thm%}\egroup

\SYNOPSIS
Puts an iterated disjunction in canonical form.

\DESCRIBE
When applied to a term, {\small\verb%DISJ_CANON_CONV%} splits it into the set of disjuncts
and produces a theorem asserting the equivalence of the term and the new term
with the disjuncts right-associated without repetitions and in a canonical
order.

\FAILURE
Fails if applied to a non-Boolean term. If applied to a term that is not a
disjunction, it will trivially work in the sense of regarding it as a single
disjunct and returning a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DISJ_CANON_CONV `(c \/ a \/ b) \/ (b \/ a \/ d)`;;
  val it : thm = |- (c \/ a \/ b) \/ b \/ a \/ d <=> a \/ b \/ c \/ d
\end{verbatim}
}

\SEEALSO
AC, CONJ_CANON_CONV, DISJ_ACI_CONV.

\ENDDOC
\DOC{DISJ{\_}CASES}

\TYPE {\small\verb%DISJ_CASES : thm -> thm -> thm -> thm%}\egroup

\SYNOPSIS
Eliminates disjunction by cases.

\DESCRIBE
The rule {\small\verb%DISJ_CASES%} takes a disjunctive theorem, and two `case'
theorems, each with one of the disjuncts as a hypothesis while sharing
alpha-equivalent conclusions.  A new theorem is returned with the same
conclusion as the `case' theorems, and the union of all assumptions
excepting the disjuncts.
{\par\samepage\setseps\small
\begin{verbatim}
         A |- t1 \/ t2     A1 |- t      A2 |- t
   --------------------------------------------------  DISJ_CASES
         A u (A1 - {t1}) u (A2 - {t2}) |- t
\end{verbatim}
}
\FAILURE
Fails if the first argument is not a disjunctive theorem, or if the
conclusions of the other two theorems are not alpha-convertible.

\EXAMPLE
Let us create several theorems. Note that {\small\verb%th1%} and {\small\verb%th2%} draw the same
conclusion from different hypotheses, while {\small\verb%th%} proves the disjunction of the
two hypotheses:
{\par\samepage\setseps\small
\begin{verbatim}
  # let [th; th1; th2] = map (UNDISCH_ALL o REAL_FIELD)
      [`~(x = &0) \/ x = &0`;
       `~(x = &0) ==> x * (inv(x) * x - &1) = &0`;
       `x = &0 ==> x * (inv(x) * x - &1) = &0`];;
    ...
  val th : thm = |- ~(x = &0) \/ x = &0
  val th1 : thm = ~(x = &0) |- x * (inv x * x - &1) = &0
  val th2 : thm = x = &0 |- x * (inv x * x - &1) = &0
\end{verbatim}
}
\noindent so we can apply {\small\verb%DISJ_CASES%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # DISJ_CASES th th1 th2;;
  val it : thm = |- x * (inv x * x - &1) = &0
\end{verbatim}
}

\COMMENTS
Neither of the `case' theorems is required to have either disjunct as a
hypothesis, but otherwise {\small\verb%DISJ_CASES%} is pointless.

\SEEALSO
DISJ_CASES_TAC, DISJ_CASES_THEN, DISJ_CASES_THEN2, DISJ1, DISJ2,
SIMPLE_DISJ_CASES.

\ENDDOC
\DOC{DISJ{\_}CASES{\_}TAC}

\TYPE {\small\verb%DISJ_CASES_TAC : thm_tactic%}\egroup

\SYNOPSIS
Produces a case split based on a disjunctive theorem.

\DESCRIBE
Given a theorem {\small\verb%th%} of the form {\small\verb%A |- u \/ v%}, {\small\verb%DISJ_CASES_TAC th%}
applied to a goal
produces two subgoals, one with {\small\verb%u%} as an assumption and one with {\small\verb%v%}:
{\par\samepage\setseps\small
\begin{verbatim}
              A ?- t
   =================================  DISJ_CASES_TAC (A |- u \/ v)
    A u {u} ?- t   A u {v}?- t
\end{verbatim}
}

\FAILURE
Fails if the given theorem does not have a disjunctive conclusion.

\EXAMPLE
Given the simple fact about arithmetic {\small\verb%th%}, {\small\verb%|- m = 0 \/ (?n. m = SUC n)%},
the tactic {\small\verb%DISJ_CASES_TAC th%} can be used to produce a case split:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC `m:num` num_CASES;;
  val th : thm = |- m = 0 \/ (?n. m = SUC n)

  # g `(P:num -> bool) m`;;
  Warning: Free variables in goal: P, m
  val it : goalstack = 1 subgoal (1 total)

  `P m`

  # e(DISJ_CASES_TAC th);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`?n. m = SUC n`]

  `P m`

   0 [`m = 0`]

  `P m`
\end{verbatim}
}

\USES
Performing a case analysis according to a disjunctive theorem.

\SEEALSO
ASSUME_TAC, ASM_CASES_TAC, COND_CASES_TAC, DISJ_CASES_THEN, STRUCT_CASES_TAC.

\ENDDOC
\DOC{DISJ{\_}CASES{\_}THEN}

\TYPE {\small\verb%DISJ_CASES_THEN : thm_tactical%}\egroup

\SYNOPSIS
Applies a theorem-tactic to each disjunct of a disjunctive theorem.

\DESCRIBE
If the theorem-tactic {\small\verb%f:thm->tactic%} applied to either
{\small\verb%ASSUME%}d disjunct produces results as follows when applied to a goal
{\small\verb%(A ?- t)%}:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t                                A ?- t
   =========  f (u |- u)      and        =========  f (v |- v)
    A ?- t1                               A ?- t2
\end{verbatim}
}
\noindent then applying {\small\verb%DISJ_CASES_THEN f (|- u \/ v)%}
to the goal {\small\verb%(A ?- t)%} produces two subgoals.
{\par\samepage\setseps\small
\begin{verbatim}
           A ?- t
   ======================  DISJ_CASES_THEN f (|- u \/ v)
    A ?- t1      A ?- t2
\end{verbatim}
}
\FAILURE
Fails if the theorem is not a disjunction.  An invalid tactic is
produced if the theorem has any hypothesis which is not
alpha-convertible to an assumption of the goal.

\EXAMPLE
Given the theorem
{\par\samepage\setseps\small
\begin{verbatim}
   th = |- (m = 0) \/ (?n. m = SUC n)
\end{verbatim}
}
\noindent and a goal of the form {\small\verb%?- (PRE m = m) = (m = 0)%},
applying the tactic
{\par\samepage\setseps\small
\begin{verbatim}
   DISJ_CASES_THEN MP_TAC th
\end{verbatim}
}
\noindent produces two subgoals, each with one disjunct as an added
antecedent
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC `m:num` num_CASES;;
  val th : thm = |- m = 0 \/ (?n. m = SUC n)
  # g `PRE m = m <=> m = 0`;;
  Warning: Free variables in goal: m
  val it : goalstack = 1 subgoal (1 total)

  `PRE m = m <=> m = 0`

  # e(DISJ_CASES_THEN MP_TAC th);;
  val it : goalstack = 2 subgoals (2 total)

  `(?n. m = SUC n) ==> (PRE m = m <=> m = 0)`

  `m = 0 ==> (PRE m = m <=> m = 0)`
\end{verbatim}
}

\USES
Building cases tactics. For example, {\small\verb%DISJ_CASES_TAC%} could be defined by:
{\par\samepage\setseps\small
\begin{verbatim}
   let DISJ_CASES_TAC = DISJ_CASES_THEN ASSUME_TAC
\end{verbatim}
}
\COMMENTS
Use {\small\verb%DISJ_CASES_THEN2%} to apply different tactic generating functions
to each case.

\SEEALSO
STRIP_THM_THEN, CHOOSE_THEN, CONJUNCTS_THEN, CONJUNCTS_THEN2,
DISJ_CASES_TAC, DISJ_CASES_THEN2.

\ENDDOC
\DOC{DISJ{\_}CASES{\_}THEN2}

\TYPE {\small\verb%DISJ_CASES_THEN2 : thm_tactic -> thm_tactic -> thm_tactic%}\egroup

\SYNOPSIS
Applies separate theorem-tactics to the two disjuncts of a theorem.

\DESCRIBE
If the theorem-tactics {\small\verb%ttac1%} and {\small\verb%ttac2%}, applied to the {\small\verb%ASSUME%}d left and right
disjunct of a theorem {\small\verb%|- u \/ v%} respectively, produce results as follows when
applied to a goal {\small\verb%(A ?- t)%}:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t                                    A ?- t
   =========  ttac1 (u |- u)      and        =========  ttac2 (v |- v)
    A ?- t1                                   A ?- t2
\end{verbatim}
}
\noindent then applying {\small\verb%DISJ_CASES_THEN2 ttac1 ttac2 (|- u \/ v)%} to the
goal {\small\verb%(A ?- t)%} produces two subgoals.
{\par\samepage\setseps\small
\begin{verbatim}
           A ?- t
   ======================  DISJ_CASES_THEN2 ttac1 ttac2 (|- u \/ v)
    A ?- t1      A ?- t2
\end{verbatim}
}

\FAILURE
Fails if the theorem is not a disjunction.  An invalid tactic is produced if
the theorem has any hypothesis which is not alpha-convertible to an assumption
of the goal.

\EXAMPLE
Given the theorem
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC `m:num` num_CASES;;
  val th : thm = |- m = 0 \/ (?n. m = SUC n)
\end{verbatim}
}
\noindent and a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `PRE m = m <=> m = 0`;;
\end{verbatim}
}
\noindent the following produces two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISJ_CASES_THEN2 SUBST1_TAC MP_TAC th);;
  val it : goalstack = 2 subgoals (2 total)

  `(?n. m = SUC n) ==> (PRE m = m <=> m = 0)`

  `PRE 0 = 0 <=> 0 = 0`
\end{verbatim}
}
\noindent The first subgoal has had the disjunct {\small\verb%m = 0%} used
for a substitution, and the second has added the disjunct as
an antecedent. Alternatively, we can make the second theorem-tactic
also choose a witness for the existential quantifier and follow by
also substituting:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISJ_CASES_THEN2 SUBST1_TAC (CHOOSE_THEN SUBST1_TAC) th);;
  val it : goalstack = 2 subgoals (2 total)

  `PRE (SUC n) = SUC n <=> SUC n = 0`

  `PRE 0 = 0 <=> 0 = 0`
\end{verbatim}
}
\noindent Either subgoal can be finished with {\small\verb%ARITH_TAC%}, but the way, but so
could the initial goal.

\USES
Building cases tacticals. For example, {\small\verb%DISJ_CASES_THEN%} could be defined by:
{\par\samepage\setseps\small
\begin{verbatim}
  let DISJ_CASES_THEN f = DISJ_CASES_THEN2 f f
\end{verbatim}
}

\SEEALSO
STRIP_THM_THEN, CHOOSE_THEN, CONJUNCTS_THEN, CONJUNCTS_THEN2, DISJ_CASES_THEN.

\ENDDOC
\DOC{distinctness}

\TYPE {\small\verb%distinctness : string -> thm%}\egroup

\SYNOPSIS
Produce distinctness theorem for an inductive type.

\DESCRIBE
A call {\small\verb%distinctness "ty"%} where {\small\verb%"ty"%} is the name of a recursive type defined
with {\small\verb%define_type%}, returns a ``distinctness'' theorem asserting that elements
constructed by different type constructors are always different. The effect is
exactly the same as if {\small\verb%prove_constructors_distinct%} were applied to the
recursion theorem produced by {\small\verb%define_type%}, and the documentation for
{\small\verb%prove_constructors_distinct%} gives a lengthier discussion.

\FAILURE
Fails if {\small\verb%ty%} is not the name of a recursive type, or if the type has only one
constructor.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # distinctness "num";;
  val it : thm = |- !n'. ~(0 = SUC n')

  # distinctness "list";;
  val it : thm = |- !a0' a1'. ~([] = CONS a0' a1')
\end{verbatim}
}

\SEEALSO
cases, define_type, injectivity, prove_constructors_distinct.

\ENDDOC
\DOC{distinctness{\_}store}

\TYPE {\small\verb%distinctness_store : (string * thm) list ref%}\egroup

\SYNOPSIS
Internal theorem list of distinctness theorems.

\DESCRIBE
This list contains all the distinctness theorems (see {\small\verb%distinct%}) for the
recursive types defined so far. It is automatically extended by {\small\verb%define_type%}
and used as a cache by {\small\verb%distinct%}.

\FAILURE
Not applicable.

\SEEALSO
define_type, distinctness, extend_rectype_net, injectivity_store.

\ENDDOC
\DOC{DNF{\_}CONV}

\TYPE {\small\verb%DNF_CONV : conv%}\egroup

\SYNOPSIS
Converts a term already in negation normal form into disjunctive normal form.

\DESCRIBE
When applied to a term already in negation normal form (see {\small\verb%NNF_CONV%}),
meaning that all other propositional connectives have been eliminated in favour
of disjunction, disjunction and negation, and negation is only applied to
atomic formulas, {\small\verb%DNF_CONV%} puts the term into an equivalent disjunctive normal
form, which is a right-associated disjunction of conjunctions without
repetitions. No reduction by subsumption is performed, however, e.g. from
{\small\verb%a \/ a /\ b%} to just {\small\verb%a%}).

\FAILURE
Never fails; non-Boolean terms will just yield a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # DNF_CONV `(a \/ b) /\ (a \/ c /\ e)`;;
  val it : thm =
    |- (a \/ b) /\ (a \/ c /\ e) <=> a \/ a /\ b \/ a /\ c /\ e \/ b /\ c /\ e
\end{verbatim}
}

\SEEALSO
CNF_CONV, NNF_CONV, WEAK_CNF_CONV, WEAK_DNF_CONV.

\ENDDOC
\DOC{dom}

\TYPE {\small\verb%dom : ('a, 'b) func -> 'a list%}\egroup

\SYNOPSIS
Returns domain of a finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The {\small\verb%dom%} operation returns the domain of such a function, i.e. the set of
points on which it is defined.

\FAILURE
Attempts to sort the resulting list, so may fail if the domain type does
not admit comparisons.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # dom (1 |=> "1");;
  val it : int list = [1]
  # dom(itlist I [2|->4; 3|->6] undefined);;
  val it : int list = [2; 3]
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{do{\_}list}

\TYPE {\small\verb%do_list : ('a -> 'b) -> 'a list -> unit%}\egroup

\SYNOPSIS
Apply imperative function to each element of a list.

\DESCRIBE
The call {\small\verb%do_list f [x1; ... ; xn]%} evaluates in sequence the expressions
{\small\verb%f x1%}, ..., {\small\verb%f xn%} in that order, discarding the results. Presumably the
applications will have some side-effect, such as printing something to the
terminal.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # do_list (fun x -> print_string x; print_newline()) (explode "john");;
  j
  o
  h
  n
  val it : unit = ()

  # do_list (fun x -> print_string x) (rev(explode "nikolas"));;
  salokinval it : unit = ()
\end{verbatim}
}

\USES
Running imperative code parametrized by list members.

\SEEALSO
map.

\ENDDOC
\DOC{dpty}

\TYPE {\small\verb%dpty : pretype%}\egroup

\SYNOPSIS
Dummy pretype.

\DESCRIBE
This is a dummy pretype, intended as a placeholder until the correct one is
discovered.

\FAILURE
Not applicable.

\SEEALSO
pretype_of_type, type_of_pretype.

\ENDDOC
\DOC{e}

\TYPE {\small\verb%e : tactic -> goalstack%}\egroup

\SYNOPSIS
Applies a tactic to the current goal, stacking the resulting subgoals.

\DESCRIBE
The function {\small\verb%e%} is part of the subgoal package. It applies a tactic to the
current goal to give a new proof state. The previous state is stored on the
backup list. If the tactic produces subgoals, the new proof state is formed
from the old one by adding a new level consisting of its subgoals.

The tactic applied is a validating version of the tactic given. It ensures that
the justification of the tactic does provide a proof of the goal from the
subgoals generated by the tactic. It will cause failure if this is not so. The
tactical {\small\verb%VALID%} performs this validation.

For a description of the subgoal package, see {\small\verb%set_goal%}.

\FAILURE
{\small\verb%e tac%} fails if the tactic {\small\verb%tac%} fails for the top goal. It will diverge if
the tactic diverges for the goal. It will fail if there are no unproven goals.
This could be because no goal has been set using {\small\verb%set_goal%} or because the last
goal set has been completely proved. It will also fail in cases when the tactic
is invalid.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3]`

  # e CONJ_TAC;;
  val it : goalstack = 2 subgoals (2 total)

  `TL [1; 2; 3] = [2; 3]`

  `HD [1; 2; 3] = 1`

  # e (REWRITE_TAC[HD]);;
  val it : goalstack = 1 subgoal (1 total)

  `TL [1; 2; 3] = [2; 3]`

  # e (REWRITE_TAC[TL]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Doing a step in an interactive goal-directed proof.

\SEEALSO
b, er, g, p, r, set_goal, top_goal, top_thm.

\ENDDOC
\DOC{el}

\TYPE {\small\verb%el : int -> 'a list -> 'a%}\egroup

\SYNOPSIS
Extracts a specified element from a list.

\DESCRIBE
{\small\verb%el i [x0;x1;...;xn]%} returns {\small\verb%xi%}. Note that the elements are numbered
starting from {\small\verb%0%}, not {\small\verb%1%}.

\FAILURE
Fails with {\small\verb%el%} if the integer argument is negative or greater than the
length of the list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # el 3 [1;2;7;1];;
  val it : int = 1
\end{verbatim}
}

\SEEALSO
hd, tl.

\ENDDOC
\DOC{elistof}

\TYPE {\small\verb%elistof : ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> string -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Parses a possibly empty separated list of items.

\DESCRIBE
If {\small\verb%p%} is a parser for ``items'' of some kind, {\small\verb%s%} is a parser for a
``separator'', and {\small\verb%e%} is an error message, then {\small\verb%elistof p s e%} parses a
possibly empty list of successive items using {\small\verb%p%}, where adjacent items are
separated by something parseable by {\small\verb%s%}. If a separator is parsed successfully
but there is no following item that can be parsed by {\small\verb%s%}, an exception {\small\verb%Failure
e%} is raised. (So note that the separator must not terminate the final
element.)

\FAILURE
The call {\small\verb%elistof p s e%} itself never fails, though the resulting parser may.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{EL{\_}CONV}

\TYPE {\small\verb%EL_CONV : conv%}\egroup

\SYNOPSIS
Evaluate the list nth-element element function applied to a specific list.

\DESCRIBE
When applied to a term {\small\verb%`EL k [t1; ...; tn]`%} where {\small\verb%k%} is a specific
numeral and the list a concrete list (though not necessarily with constant
or ground elements) the conversion {\small\verb%EL_CONV%} returns the appropriate
theorem {\small\verb%|- EL k [t1; ...; tn] = tk%}.

\FAILURE
Fails if the term is not of the expected form or if the numeral {\small\verb%k%} is greater
than or equal to the list length (equal because the numbering is from zero).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # EL_CONV `EL 4 [1;2;3;4;5]`;;
  val it : thm = |- EL 4 [1; 2; 3; 4; 5] = 5

  # EL_CONV `EL 0 [a;one;c]`;;
  val it : thm = |- EL 0 [a; one; c] = a
\end{verbatim}
}

\SEEALSO
LENGTH_CONV, LIST_CONV, LIST_OF_SEQ_CONV, REVERSE_CONV.

\ENDDOC
\DOC{empty{\_}net}

\TYPE {\small\verb%empty_net : 'a net%}\egroup

\SYNOPSIS
Empty term net.

\DESCRIBE
Term nets (type {\small\verb%'a net%}) are a lookup structure associating objects of type
{\small\verb%'a%}, e.g. conversions, with a corresponding `pattern' term. For a given term,
one can then relatively quickly look up all objects whose pattern terms might
possibly match to it. This is used, for example, in rewriting to quickly filter
out obviously inapplicable rewrites rather than attempting each one in turn.
The (polymorphic) object {\small\verb%empty_net%} is the term net with no objects defined;
it can then be augmented by {\small\verb%enter%} or {\small\verb%merge_nets%} and used in {\small\verb%lookup%}.

\FAILURE
Not applicable.

\SEEALSO
enter, lookup, merge_nets.

\ENDDOC
\DOC{empty{\_}ss}

\TYPE {\small\verb%empty_ss : simpset%}\egroup

\SYNOPSIS
Simpset consisting of only the default rewrites and conversions.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset'. The simpset {\small\verb%empty_ss%} has just
the basic rewrites and conversions (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}),
and no other provers.

\FAILURE
Not applicable.

\SEEALSO
basic_convs, basic_rewrites, basic_ss, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{end{\_}itlist}

\TYPE {\small\verb%end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a%}\egroup

\SYNOPSIS
List iteration function. Applies a binary function between adjacent elements
of a list.

\DESCRIBE
{\small\verb%end_itlist f [x1;...;xn]%} returns {\small\verb%f x1 ( ... (f x(n-1) xn)...)%}.
Returns {\small\verb%x%} for a one-element list {\small\verb%[x]%}.

\FAILURE
Fails with {\small\verb%end_itlist%} if list is empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # end_itlist (+) [1;2;3;4];;
  val it : int = 10
\end{verbatim}
}

\SEEALSO
itlist, rev_itlist.

\ENDDOC
\DOC{enter}

\TYPE {\small\verb%enter : term list -> term * 'a -> 'a net -> 'a net%}\egroup

\SYNOPSIS
Enter an object and its pattern term into a term net.

\DESCRIBE
Term nets (type {\small\verb%'a net%}) are a lookup structure
associating objects of type {\small\verb%'a%}, e.g. conversions, with a corresponding
`pattern' term. For a given term, one can then relatively quickly look up all
objects whose pattern terms might possibly match to it. This is used, for
example, in rewriting to quickly filter out obviously inapplicable rewrites
rather than attempting each one in turn. The call {\small\verb%enter lconsts (pat,obj) net%}
enters the item {\small\verb%obj%} into a net {\small\verb%obj%} with indexing pattern term {\small\verb%pat%}. The
list {\small\verb%lconsts%} lists variables that should be considered `local constants' when
matching, so will only match terms with exactly the same variable in
corresponding places.

\FAILURE
Never fails.

\EXAMPLE
Here we construct a net with the conversions for various arithmetic operations
on numerals, each with a pattern term to identify the class of terms to which
it might apply:
{\par\samepage\setseps\small
\begin{verbatim}
  let arithnet = itlist (enter [])
     [`SUC n`,NUM_SUC_CONV;
      `m + n:num`,NUM_ADD_CONV;
      `m - n:num`,NUM_SUB_CONV;
      `m * n:num`,NUM_MULT_CONV;
      `m EXP n`,NUM_EXP_CONV;
      `m DIV n`,NUM_DIV_CONV;
      `m MOD n`,NUM_MOD_CONV]
     empty_net;;
\end{verbatim}
}
Now we can define a conversion that uses lookup in this net as a first-stage
filter and tries to apply the results.
{\par\samepage\setseps\small
\begin{verbatim}
  let NUM_ARITH_CONV tm = FIRST_CONV (lookup tm arithnet) tm;;
\end{verbatim}
}

Note that this is functionally not really different from just
{\par\samepage\setseps\small
\begin{verbatim}
 let NUM_ARITH_CONV' =
   FIRST_CONV [NUM_SUC_CONV; NUM_ADD_CONV; NUM_SUB_CONV; NUM_MULT_CONV;
               NUM_EXP_CONV; NUM_DIV_CONV; NUM_MOD_CONV];;
\end{verbatim}
}
\noindent but it may be significantly more efficient because instead of
successive attempts to apply the conversions, each one is only invoked when
the term has the right pattern.
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = funpow 5 (fun x -> mk_binop `(*):num->num->num` x x) `12`;;
  ...
  time (DEPTH_CONV NUM_ARITH_CONV) term;;
  CPU time (user): 0.12
  ...
  time (DEPTH_CONV NUM_ARITH_CONV') term;;
  CPU time (user): 0.22
  ...
\end{verbatim}
}
In situations with very many conversions, each one quite fast, the difference
can be much more striking.

\SEEALSO
empty_net, lookup, merge_nets.

\ENDDOC
\DOC{EQF{\_}ELIM}

\TYPE {\small\verb%EQF_ELIM : thm -> thm%}\egroup

\SYNOPSIS
Replaces equality with {\small\verb%F%} by negation.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- tm <=> F
   ---------------  EQF_ELIM
     A |- ~tm
\end{verbatim}
}

\FAILURE
Fails if the argument theorem is not of the form {\small\verb%A |- tm <=> F%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # EQF_ELIM(REFL `F`);;
  val it : thm = |- ~F
\end{verbatim}
}

\SEEALSO
EQF_INTRO, EQT_ELIM, EQT_INTRO, NOT_ELIM, NOT_INTRO.

\ENDDOC
\DOC{EQF{\_}INTRO}

\TYPE {\small\verb%EQF_INTRO : thm -> thm%}\egroup

\SYNOPSIS
Converts negation to equality with {\small\verb%F%}.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
     A |- ~tm
   ---------------  EQF_INTRO
    A |- tm <=> F
\end{verbatim}
}

\FAILURE
Fails if the argument theorem is not a negation.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ASSUME `~p`;;
  val th : thm = ~p |- ~p

  # EQF_INTRO th;;
  val it : thm = ~p |- p <=> F
\end{verbatim}
}

\SEEALSO
EQF_ELIM, EQT_ELIM, EQT_INTRO, NOT_ELIM, NOT_INTRO.

\ENDDOC
\DOC{EQT{\_}ELIM}

\TYPE {\small\verb%EQT_ELIM : thm -> thm%}\egroup

\SYNOPSIS
Eliminates equality with {\small\verb%T%}.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- tm <=> T
   ---------------  EQT_ELIM
      A |- tm
\end{verbatim}
}
\FAILURE
Fails if the argument theorem is not of the form {\small\verb%A |- tm <=> T%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REFL `T`;;
  val it : thm = |- T <=> T

  # EQT_ELIM it;;
  val it : thm = |- T
\end{verbatim}
}

\SEEALSO
EQF_ELIM, EQF_INTRO, EQT_INTRO.

\ENDDOC
\DOC{EQT{\_}INTRO}

\TYPE {\small\verb%EQT_INTRO : thm -> thm%}\egroup

\SYNOPSIS
Introduces equality with {\small\verb%T%}.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
      A |- tm
   ---------------  EQF_INTRO
    A |- tm <=> T
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # EQT_INTRO (REFL `2`);;
  val it : thm = |- 2 = 2 <=> T
\end{verbatim}
}

\SEEALSO
EQF_ELIM, EQF_INTRO, EQT_ELIM.

\ENDDOC
\DOC{equals{\_}goal}

\TYPE {\small\verb%equals_goal : goal -> goal -> bool%}\egroup

\SYNOPSIS
Equality test on goals.

\DESCRIBE
The relation {\small\verb%equals_goal%} tests if two goals have exactly the same structure,
with the same assumptions, conclusions and even labels, with the assumptions in
the same order. The only respect in which this differs from a pure equality
tests is that the various term components are tested modulo alpha-conversion.

\FAILURE
Never fails.

\COMMENTS
Probably not generally useful. Used inside {\small\verb%CHANGED_TAC%}.

\SEEALSO
CHANGED_TAC, equals_thm.

\ENDDOC
\DOC{equals{\_}thm}

\TYPE {\small\verb%equals_thm : thm -> thm -> bool%}\egroup

\SYNOPSIS
Equality test on theorems.

\DESCRIBE
The call {\small\verb%equals_thm th1 th2%} returns {\small\verb%true%} if and only if both the
conclusions and assumptions of the two theorems {\small\verb%th1%} and {\small\verb%th2%} are exactly the
same. The same can be achieved by a simple equality test, but it is better
practice to use this function because it will also work in the proof recording
version of HOL Light (see the {\small\verb%Proofrecording%} subdirectory).

\FAILURE
Never fails.

\SEEALSO
=?.

\ENDDOC
\DOC{EQ{\_}IMP{\_}RULE}

\TYPE {\small\verb%EQ_IMP_RULE : thm -> thm * thm%}\egroup

\SYNOPSIS
Derives forward and backward implication from equality of boolean terms.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t1 <=> t2%}, where {\small\verb%t1%} and {\small\verb%t2%} both have
type {\small\verb%bool%}, the inference rule {\small\verb%EQ_IMP_RULE%} returns the
theorems {\small\verb%A |- t1 ==> t2%} and {\small\verb%A |- t2 ==> t1%}.
{\par\samepage\setseps\small
\begin{verbatim}
              A |- t1 <=> t2
   -----------------------------------  EQ_IMP_RULE
    A |- t1 ==> t2     A |- t2 ==> t1
\end{verbatim}
}

\FAILURE
Fails unless the conclusion of the given theorem is an equation between
boolean terms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SPEC_ALL CONJ_SYM;;
  val it : thm = |- t1 /\ t2 <=> t2 /\ t1

  # EQ_IMP_RULE it;;
  val it : thm * thm = (|- t1 /\ t2 ==> t2 /\ t1, |- t2 /\ t1 ==> t1 /\ t2)
\end{verbatim}
}

\SEEALSO
EQ_MP, EQ_TAC, IMP_ANTISYM_RULE.

\ENDDOC
\DOC{EQ{\_}MP}

\TYPE {\small\verb%EQ_MP : thm -> thm -> thm%}\egroup

\SYNOPSIS
Equality version of the Modus Ponens rule.

\DESCRIBE
When applied to theorems {\small\verb%A1 |- t1 <=> t2%} and {\small\verb%A2 |- t1'%} where {\small\verb%t1%} and {\small\verb%t1'%}
are alpha-equivalent (for example, identical), the inference rule {\small\verb%EQ_MP%}
returns the theorem {\small\verb%A1 u A2 |- t2%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- t1 <=> t2   A2 |- t1'
   -----------------------------  EQ_MP
         A1 u A2 |- t2
\end{verbatim}
}
\FAILURE
Fails unless the first theorem is equational and its left side is the same as
the conclusion of the second theorem (and is therefore of type {\small\verb%bool%}), up to
alpha-conversion.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = SPECL [`p:bool`; `q:bool`] CONJ_SYM
    and th2 = ASSUME `p /\ q`;;
  val th1 : thm = |- p /\ q <=> q /\ p
  val th2 : thm = p /\ q |- p /\ q
  # EQ_MP th1 th2;;
  val it : thm = p /\ q |- q /\ p
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
EQ_IMP_RULE, IMP_ANTISYM_RULE, MP, PROVE_HYP.

\ENDDOC
\DOC{EQ{\_}TAC}

\TYPE {\small\verb%EQ_TAC : tactic%}\egroup

\SYNOPSIS
Reduces goal of equality of boolean terms to forward and backward implication.

\DESCRIBE
When applied to a goal {\small\verb%A ?- t1 <=> t2%}, where {\small\verb%t1%} and {\small\verb%t2%} have type {\small\verb%bool%},
the tactic {\small\verb%EQ_TAC%} returns the subgoals {\small\verb%A ?- t1 ==> t2%} and
{\small\verb%A ?- t2 ==> t1%}.
{\par\samepage\setseps\small
\begin{verbatim}
             A ?- t1 <=> t2
   =================================  EQ_TAC
    A ?- t1 ==> t2   A ?- t2 ==> t1
\end{verbatim}
}

\FAILURE
Fails unless the conclusion of the goal is an equation between boolean terms.

\SEEALSO
EQ_IMP_RULE, IMP_ANTISYM_RULE.

\ENDDOC
\DOC{er}

\TYPE {\small\verb%er : tactic -> goalstack%}\egroup

\SYNOPSIS
Applies a tactic to the current goal and rotates to the next subgoal.

\DESCRIBE
The function {\small\verb%er%} is part of the subgoal package. It sequentially applies a
tactic to the current goal to give a new proof state using {\small\verb%e%}, then applies
{\small\verb%r%} to rotate to the next subgoal. If {\small\verb%e%} created {\small\verb%n%} subgoals, it rotates
{\small\verb%n%} times. When {\small\verb%verbose%} is set to true, {\small\verb%er%} prints the goal state after
{\small\verb%e%}, prints the number of subgoals to rotate, then returns the final goalstate.

This command is useful when you want to interactively try a list of tactics
after {\small\verb%THENL%}. For example, given a proof `{\small\verb%TAC THENL [ TAC_A; TAC_B; .. ]%}',
statements `{\small\verb%e TAC;; er TAC_A;;%}' will execute {\small\verb%TAC%}, execute {\small\verb%TAC_A%}, then
switch to the second subgoal of `{\small\verb%e TAC%}' which will be the input goalstate of
{\small\verb%TAC_B%}.

If the proof of {\small\verb%THEN%} form does not have any `{\small\verb%a THEN b%}' where {\small\verb%a%} generates
multiple subgoals (which can be checked by enabling
{\small\verb%unset_then_multiple_subgoals%} and running the proof), the whole {\small\verb%THEN%} proof
can be easily converted to a series of {\small\verb%e%} and {\small\verb%er%}.

\FAILURE
{\small\verb%er tac%} fails if its internal invoation {\small\verb%e tac%} failed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}

  # prove(`x + 1 = 1 + x /\ 1 + 1 = 2`,
      CONJ_TAC THENL [ALL_TAC; ARITH_TAC] THEN REWRITE_TAC[ADD_SYM]);;
  val it : thm = |- x + 1 = 1 + x /\ 1 + 1 = 2

  # g `x + 1 = 1 + x /\ 1 + 1 = 2`;;
  Warning: Free variables in goal: x
  val it : goalstack = 1 subgoal (1 total)

  `x + 1 = 1 + x /\ 1 + 1 = 2`

  # e(CONJ_TAC);;
  val it : goalstack = 2 subgoals (2 total)

  `1 + 1 = 2`

  `x + 1 = 1 + x`

  # er(ALL_TAC);; (* rotates 1 subgoal *)
  1 subgoal (2 total)

  `x + 1 = 1 + x`

  (Rotating 1 subgoal...)

  val it : goalstack = 1 subgoal (2 total)

  `1 + 1 = 2`

  # e(ARITH_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `x + 1 = 1 + x`

  # e(REWRITE_TAC[ADD_SYM]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Doing a step in an interactive goal-directed proof.

\SEEALSO
b, e, g, p, r, set_goal, top_goal, top_thm, unset_then_multiple_subgoals.

\ENDDOC
\DOC{ETA{\_}CONV}

\TYPE {\small\verb%ETA_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs a toplevel eta-conversion.

\DESCRIBE
{\small\verb%ETA_CONV%} maps an eta-redex {\small\verb%`\x. t x`%}, where {\small\verb%x%} does not occur free in {\small\verb%t%},
to the theorem {\small\verb%|- (\x. t x) = t%}.

\FAILURE
Fails if the input term is not an eta-redex.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ETA_CONV `\n. SUC n`;;
  val it : thm = |- (\n. SUC n) = SUC

  # ETA_CONV `\n. 1 + n`;;
  val it : thm = |- (\n. 1 + n) = (+) 1

  # ETA_CONV `\n. n + 1`;;
  Exception: Failure "ETA_CONV".
\end{verbatim}
}

\COMMENTS
The same basic effect can be achieved by rewriting with {\small\verb%ETA_AX%}. The theorem
{\small\verb%ETA_AX%} is one of HOL Light's three mathematical axioms.

\ENDDOC
\DOC{EVERY}

\TYPE {\small\verb%EVERY : tactic list -> tactic%}\egroup

\SYNOPSIS
Sequentially applies all the tactics in a given list of tactics.

\DESCRIBE
When applied to a list of tactics {\small\verb%[t1; ... ;tn]%}, and a goal {\small\verb%g%}, the tactical
{\small\verb%EVERY%} applies each tactic in sequence to every
subgoal generated by the previous one. This can be represented as:
{\par\samepage\setseps\small
\begin{verbatim}
   EVERY [t1;...;tn] = t1 THEN ... THEN tn
\end{verbatim}
}
\noindent If the tactic list is empty, the resulting tactic has no effect.

\FAILURE
The application of {\small\verb%EVERY%} to a tactic list never fails. The resulting
tactic fails iff any of the component tactics do.

\COMMENTS
It is possible to use {\small\verb%EVERY%} instead of {\small\verb%THEN%}, but probably
stylistically inferior. {\small\verb%EVERY%} is more useful when applied to a list of
tactics generated by a function.

\SEEALSO
FIRST, MAP_EVERY, THEN.

\ENDDOC
\DOC{EVERY{\_}ASSUM}

\TYPE {\small\verb%EVERY_ASSUM : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Sequentially applies all tactics given by mapping a function over the
assumptions of a goal.

\DESCRIBE
When applied to a theorem-tactic {\small\verb%f%} and a goal {\small\verb%({A1;...;An} ?- C)%}, the
{\small\verb%EVERY_ASSUM%} tactical maps {\small\verb%f%} over the list of assumptions then
applies the resulting tactics, in sequence, to the goal:
{\par\samepage\setseps\small
\begin{verbatim}
   EVERY_ASSUM f ({A1;...;An} ?- C)
    = (f(.. |- A1) THEN ... THEN f(.. |- An)) ({A1;...;An} ?- C)
\end{verbatim}
}
\noindent If the goal has no assumptions, then {\small\verb%EVERY_ASSUM%} has no effect.

\FAILURE
The application of {\small\verb%EVERY_ASSUM%} to a theorem-tactic and a goal fails
if the theorem-tactic fails when applied to any of the assumptions of the goal,
or if any of the resulting tactics fail when applied sequentially.

\SEEALSO
ASSUM_LIST, MAP_EVERY, MAP_FIRST, THEN.

\ENDDOC
\DOC{EVERY{\_}CONV}

\TYPE {\small\verb%EVERY_CONV : conv list -> conv%}\egroup

\SYNOPSIS
Applies in sequence all the conversions in a given list of conversions.

\DESCRIBE
{\small\verb%EVERY_CONV [c1;...;cn] `t`%} returns the result of applying the conversions
{\small\verb%c1%}, ..., {\small\verb%cn%} in sequence to the term {\small\verb%`t`%}. The conversions are applied in
the order in which they are given in the list. In particular, if {\small\verb%ci `ti`%}
returns {\small\verb%|- ti=ti+1%} for {\small\verb%i%} from {\small\verb%1%} to {\small\verb%n%}, then
{\small\verb%EVERY_CONV [c1;...;cn] `t1`%} returns {\small\verb%|- t1=t(n+1)%}.  If the supplied list of
conversions is empty, then {\small\verb%EVERY_CONV%} returns the identity conversion.  That
is, {\small\verb%EVERY_CONV [] `t`%} returns {\small\verb%|- t=t%}.

\FAILURE
{\small\verb%EVERY_CONV [c1;...;cn] `t`%} fails if any one of the conversions {\small\verb%c1%}, ...,
{\small\verb%cn%} fails when applied in sequence as specified above.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # EVERY_CONV [BETA_CONV; NUM_ADD_CONV] `(\x. x + 2) 5`;;
  val it : thm = |- (\x. x + 2) 5 = 7
\end{verbatim}
}

\SEEALSO
THENC.

\ENDDOC
\DOC{EVERY{\_}TCL}

\TYPE {\small\verb%EVERY_TCL : thm_tactical list -> thm_tactical%}\egroup

\SYNOPSIS
Composes a list of theorem-tacticals.

\DESCRIBE
When given a list of theorem-tacticals and a theorem, {\small\verb%EVERY_TCL%} simply
composes their effects on the theorem. The effect is:
{\par\samepage\setseps\small
\begin{verbatim}
   EVERY_TCL [ttl1;...;ttln] = ttl1 THEN_TCL ... THEN_TCL ttln
\end{verbatim}
}
\noindent In other words, if:
{\par\samepage\setseps\small
\begin{verbatim}
   ttl1 ttac th1 = ttac th2  ...  ttln ttac thn = ttac thn'
\end{verbatim}
}
\noindent then:
{\par\samepage\setseps\small
\begin{verbatim}
   EVERY_TCL [ttl1;...;ttln] ttac th1 = ttac thn'
\end{verbatim}
}
\noindent If the theorem-tactical list is empty, the resulting theorem-tactical
behaves in the same way as {\small\verb%ALL_THEN%}, the identity theorem-tactical.

\FAILURE
The application to a list of theorem-tacticals never fails.

\SEEALSO
FIRST_TCL, ORELSE_TCL, REPEAT_TCL, THEN_TCL.

\ENDDOC
\DOC{exactly}

\TYPE {\small\verb%exactly : term -> term%}\egroup

\SYNOPSIS
Query to {\small\verb%search%} for a term alpha-equivalent to pattern.

\DESCRIBE
The function {\small\verb%exactly%} is intended for use solely with the {\small\verb%search%} function.

\FAILURE
Never fails.

\SEEALSO
search.

\ENDDOC
\DOC{EXISTENCE}

\TYPE {\small\verb%EXISTENCE : thm -> thm%}\egroup

\SYNOPSIS
Deduces existence from unique existence.

\DESCRIBE
When applied to a theorem with a unique-existentially quantified
conclusion, {\small\verb%EXISTENCE%} returns the same theorem with normal existential
quantification over the same variable.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- ?!x. p
   -------------  EXISTENCE
    A |- ?x. p
\end{verbatim}
}

\FAILURE
Fails unless the conclusion of the theorem is unique-existentially quantified.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = MESON[] `?!n. n = m`;;
  ...
  val th : thm = |- ?!n. n = m

  # EXISTENCE th;;
  val it : thm = |- ?n. n = m
\end{verbatim}
}

\SEEALSO
EXISTS, SIMPLE_EXISTS.

\ENDDOC
\DOC{exists}

\TYPE {\small\verb%exists : ('a -> bool) -> 'a list -> bool%}\egroup

\SYNOPSIS
Tests a list to see if some element satisfy a predicate.

\DESCRIBE
{\small\verb%exists p [x1;...;xn]%} returns {\small\verb%true%} if {\small\verb%(p xi)%} is true for some {\small\verb%xi%} in the
list. Otherwise, for example if the list is empty, it returns {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # exists (fun n -> n mod 2 = 0) [2;3;5;7;11;13;17];;
  val it : bool = true
  # exists (fun n -> n mod 2 = 0) [3;5;7;9;11;13;15];;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
find, forall, tryfind, mem, assoc, rev_assoc.

\ENDDOC
\DOC{EXISTS{\_}EQUATION}

\TYPE {\small\verb%EXISTS_EQUATION : term -> thm -> thm%}\egroup

\SYNOPSIS
Derives existence from explicit equational constraint.

\DESCRIBE
Given a term {\small\verb%`x = t`%} where {\small\verb%x%} does not occur free in {\small\verb%t%}, and a
theorem {\small\verb%A |- p[x]%}, the rule {\small\verb%EXISTS_EQUATION%} returns
{\small\verb%A - {x = t} |- ?x. p[x]%}. Normally, the equation {\small\verb%x = t%} is one of the
hypotheses of the theorem, so this rule allows one to derive an existence
assertion ignoring the actual ``definition''.

\FAILURE
Fails if the term is not an equation, if the LHS is not a variable, or if the
variable occurs free in the RHS.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = (UNDISCH o EQT_ELIM o SIMP_CONV[ARITH])
     `x = 3 ==> ODD(x) /\ x > 2`;;
  val th : thm = x = 3 |- ODD x /\ x > 2

  # EXISTS_EQUATION `x = 3` th;;
  val it : thm = |- ?x. ODD x /\ x > 2
\end{verbatim}
}
\noindent Note that it is not obligatory for the term to be an assumption:
{\par\samepage\setseps\small
\begin{verbatim}
  # EXISTS_EQUATION `x = 1` (REFL `x:num`);;
  val it : thm = |- ?x. x = x
\end{verbatim}
}

\SEEALSO
EXISTS, SIMPLE_EXISTS.

\ENDDOC
\DOC{EXISTS{\_}TAC}

\TYPE {\small\verb%EXISTS_TAC : term -> tactic%}\egroup

\SYNOPSIS
Reduces existentially quantified goal to one involving a specific witness.

\DESCRIBE
When applied to a term {\small\verb%u%} and a goal {\small\verb%A ?- ?x. t%}, the tactic
{\small\verb%EXISTS_TAC%} reduces the goal to {\small\verb%A ?- t[u/x]%} (substituting {\small\verb%u%}
for all free instances of {\small\verb%x%} in {\small\verb%t%}, with variable renaming if
necessary to avoid free variable capture).
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- ?x. t
   =============  EXISTS_TAC `u`
    A ?- t[u/x]
\end{verbatim}
}

\FAILURE
Fails unless the goal's conclusion is existentially quantified and the
term supplied has the same type as the quantified variable in the goal.

\EXAMPLE
The goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `?x. 1 < x /\ x < 3`;;
\end{verbatim}
}
\noindent can be solved by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(EXISTS_TAC `2` THEN ARITH_TAC);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
EXISTS, HINT_EXISTS_TAC.

\ENDDOC
\DOC{EXISTS}

\TYPE {\small\verb%EXISTS : term * term -> thm -> thm%}\egroup

\SYNOPSIS
Introduces existential quantification given a particular witness.

\DESCRIBE
When applied to a pair of terms and a theorem, the first term an existentially
quantified pattern indicating the desired form of the result, and the second a
witness whose substitution for the quantified variable gives a term which is
the same as the conclusion of the theorem, {\small\verb%EXISTS%} gives the desired theorem.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- p[u/x]
   -------------  EXISTS (`?x. p`,`u`)
    A |- ?x. p
\end{verbatim}
}
\FAILURE
Fails unless the substituted pattern is the same as the conclusion of the
theorem.

\EXAMPLE
The following examples illustrate how it is possible to deduce different
things from the same theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # EXISTS (`?x. x <=> T`,`T`) (REFL `T`);;
  val it : thm = |- ?x. x <=> T

  # EXISTS (`?x:bool. x = x`,`T`) (REFL `T`);;
  val it : thm = |- ?x. x <=> x
\end{verbatim}
}

\SEEALSO
CHOOSE, EXISTS_TAC, SIMPLE_EXISTS.

\ENDDOC
\DOC{EXPAND{\_}CASES{\_}CONV}

\TYPE {\small\verb%EXPAND_CASES_CONV : conv%}\egroup

\SYNOPSIS
Expand a numerical range {\small\verb%`!i. i < n ==> P[i]`%}.

\DESCRIBE
When applied to a term of the form {\small\verb%`!i. i < n ==> P[i]`%} for some {\small\verb%P[i]%} and a
numeral {\small\verb%n%}, the conversion {\small\verb%EXPAND_CASES_CONV%} returns
{\par\samepage\setseps\small
\begin{verbatim}
  |- (!i. i < n ==> P[i]) <=> P[0] /\ ... /\ P[n-1]
\end{verbatim}
}

\FAILURE
Fails if applied to a term that is not of the right form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # EXPAND_CASES_CONV `(!n. n < 5 ==> ~(n = 0) ==> 12 MOD n = 0)`;;
  val it : thm =
    |- (!n. n < 5 ==> ~(n = 0) ==> 12 MOD n = 0) <=>
       (~(1 = 0) ==> 12 MOD 1 = 0) /\
       (~(2 = 0) ==> 12 MOD 2 = 0) /\
       (~(3 = 0) ==> 12 MOD 3 = 0) /\
       (~(4 = 0) ==> 12 MOD 4 = 0)

  # (EXPAND_CASES_CONV THENC NUM_REDUCE_CONV)
      `(!n. n < 5 ==> ~(n = 0) ==> 12 MOD n = 0)`;;
  val it : thm = |- (!n. n < 5 ==> ~(n = 0) ==> 12 MOD n = 0) <=> T
\end{verbatim}
}

\SEEALSO
EXPAND_SUM_CONV, EXPAND_NSUM_CONV, NUMSEG_CONV, NUM_REDUCE_CONV.

\ENDDOC
\DOC{EXPAND{\_}NSUM{\_}CONV}

\TYPE {\small\verb%EXPAND_NSUM_CONV : conv%}\egroup

\SYNOPSIS
Expands a natural number sum over an explicit interval of numerals

\DESCRIBE
The conversion {\small\verb%EXPAND_NSUM_CONV%} applied to a term of the form
{\small\verb%`nsum (m..n) f`%} where {\small\verb%m%} and {\small\verb%n%} are explicit numerals (the double-dot being
an infix set construction for a range), returns an expansion theorem
{\small\verb%|- nsum (m..n) f = f(m) + ... + f(n)%}. In the common case where {\small\verb%f%} is a
lambda-term, each application {\small\verb%f(i)%} will be beta-reduced at the top level.

\FAILURE
{\small\verb%EXPAND_NSUM_CONV tm%} fails if {\small\verb%tm%} is not a sum of the specified form.

\EXAMPLE
The following is a typical use of the conversion:
{\par\samepage\setseps\small
\begin{verbatim}
  # EXPAND_NSUM_CONV `nsum (1..5) (\n. n * n)`;;
  val it : thm =
    |- nsum (1..5) (\n. n * n) = 1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5
\end{verbatim}
}

\COMMENTS
As well as the real-number version {\small\verb%EXPAND_SUM_CONV%} in the core HOL Light, the
library file {\small\verb%Library/isum.ml%} contains a corresponding form for integer sums
{\small\verb%EXPAND_ISUM_CONV%}.

\SEEALSO
EXPAND_CASES_CONV, EXPAND_SUM_CONV, NUMSEG_CONV.

\ENDDOC
\DOC{EXPAND{\_}SUM{\_}CONV}

\TYPE {\small\verb%EXPAND_SUM_CONV : conv%}\egroup

\SYNOPSIS
Expands a real number sum over an explicit interval of numerals

\DESCRIBE
The conversion {\small\verb%EXPAND_SUM_CONV%} applied to a term of the form
{\small\verb%`sum (m..n) f`%} where {\small\verb%m%} and {\small\verb%n%} are explicit numerals (the double-dot being
an infix set construction for a range), returns an expansion theorem
{\small\verb%|- sum (m..n) f = f(m) + ... + f(n)%}. In the common case where {\small\verb%f%} is a
lambda-term, each application {\small\verb%f(i)%} will be beta-reduced at the top level.

\FAILURE
{\small\verb%EXPAND_SUM_CONV tm%} fails if {\small\verb%tm%} is not a sum of the specified form.

\EXAMPLE
The following is a typical use of the conversion:
{\par\samepage\setseps\small
\begin{verbatim}
  # EXPAND_SUM_CONV `sum(1..8) f`;;
  val it : thm =
    |- sum (1..8) f = f 1 + f 2 + f 3 + f 4 + f 5 + f 6 + f 7 + f 8
\end{verbatim}
}

\COMMENTS
As well as the natural-number version {\small\verb%EXPAND_NSUM_CONV%} in the core HOL Light,
the library file {\small\verb%Library/isum.ml%} contains a corresponding form for integer
sums {\small\verb%EXPAND_ISUM_CONV%}.

\SEEALSO
EXPAND_CASES_CONV, EXPAND_NSUM_CONV, NUMSEG_CONV.

\ENDDOC
\DOC{EXPAND{\_}TAC}

\TYPE {\small\verb%EXPAND_TAC : string -> tactic%}\egroup

\SYNOPSIS
Expand an abbreviation in the hypotheses.

\DESCRIBE
The tactic {\small\verb%EXPAND_TAC "x"%}, applied to a goal, looks for a hypothesis of the
form {\small\verb%`t = x`%} where {\small\verb%x%} is a variable with the given name. It then replaces
{\small\verb%x%} by {\small\verb%t%} throughout the conclusion of the goal.

\FAILURE
Fails if there is no suitable assumption in the goal.

\EXAMPLE
Consider the final goal in the example given for {\small\verb%ABBREV_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  val it : goalstack = 1 subgoal (1 total)

   0 [`12345 + 12345 = n`]

  `n + f n = f n`
\end{verbatim}
}
\noindent If we expand it, we get:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(EXPAND_TAC "n");;
  val it : goalstack = 1 subgoal (1 total)

   0 [`12345 + 12345 = n`]

  `(12345 + 12345) + f (12345 + 12345) = f (12345 + 12345)`
\end{verbatim}
}

\SEEALSO
ABBREV_TAC.

\ENDDOC
\DOC{explode}

\TYPE {\small\verb%explode : string -> string list%}\egroup

\SYNOPSIS
Converts a string into a list of single-character strings.

\DESCRIBE
{\small\verb%explode s%} returns the list of single-character strings that make up {\small\verb%s%}, in
the order in which they appear in {\small\verb%s%}. If {\small\verb%s%} is the empty string, then an
empty list is returned.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # explode "example";;
  val it : string list = ["e"; "x"; "a"; "m"; "p"; "l"; "e"]
\end{verbatim}
}

\SEEALSO
implode.

\ENDDOC
\DOC{extend{\_}basic{\_}congs}

\TYPE {\small\verb%extend_basic_congs : thm list -> unit%}\egroup

\SYNOPSIS
Extends the set of congruence rules used by the simplifier.

\DESCRIBE
The HOL Light simplifier (as invoked by {\small\verb%SIMP_TAC%} etc.) uses congruence rules
to determine how it uses context when descending through a term. These are
essentially theorems showing how to decompose one equality to a series of other
inequalities in context. A call to {\small\verb%extend_basic_congs thl%} adds the congruence
rules in {\small\verb%thl%} to the defaults.

\FAILURE
Never fails.

\EXAMPLE
By default, the simplifier uses context {\small\verb%p%} when simplifying {\small\verb%q%} within an
implication {\small\verb%p ==> q%}. Some users would like the simplifier to do likewise for
a conjunction {\small\verb%p /\ q%}, which is not done by default:
{\par\samepage\setseps\small
\begin{verbatim}
  # SIMP_CONV[] `x = 1 /\ x < 2`;;
  val it : thm = |- x = 1 /\ x < 2 <=> x = 1 /\ x < 2
\end{verbatim}
}
\noindent You can make it do so with
{\par\samepage\setseps\small
\begin{verbatim}
  # extend_basic_congs
     [TAUT `(p <=> p') ==> (p' ==> (q <=> q')) ==> (p /\ q <=> p' /\ q')`];;
  val it : unit = ()
\end{verbatim}
}
\noindent as you can see:
{\par\samepage\setseps\small
\begin{verbatim}
  # SIMP_CONV[] `x = 1 /\ x < 2`;;
  val it : thm = |- x = 1 /\ x < 2 <=> x = 1 /\ 1 < 2

  # SIMP_CONV[ARITH] `x = 1 /\ x < 2`;;
  val it : thm = |- x = 1 /\ x < 2 <=> x = 1
\end{verbatim}
}

\SEEALSO
basic_congs, set_basic_congs, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{extend{\_}basic{\_}convs}

\TYPE {\small\verb%extend_basic_convs : string * (term * conv) -> unit%}\egroup

\SYNOPSIS
Extend the set of default conversions used by rewriting and simplification.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. The latter are normally
term transformations that cannot be expressed as single (conditional or
unconditional) rewrite rules. A call to
{\par\samepage\setseps\small
\begin{verbatim}
  extend_basic_convs("name",(`pat`,conv))
\end{verbatim}
}
will add the conversion {\small\verb%conv%} into the default set, using the name {\small\verb%name%} to
refer to it and restricting it to subterms encountered that match {\small\verb%pat%}.

\FAILURE
Never fails.

\EXAMPLE
By default, no arithmetic is done in rewriting, though rewriting with the
theorem {\small\verb%ARITH%} gives that effect.
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_CONV[] `x = 1 + 2 + 3 + 4`;;
  val it : thm = |- x = 1 + 2 + 3 + 4 <=> x = 1 + 2 + 3 + 4
\end{verbatim}
}
You can add {\small\verb%NUM_ADD_CONV%} to the set of default conversions by
{\par\samepage\setseps\small
\begin{verbatim}
  # extend_basic_convs("addition on nat",(`m + n:num`,NUM_ADD_CONV));;
  val it : unit = ()
\end{verbatim}
}
\noindent and now it happens by default:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_CONV[] `x = 1 + 2 + 3 + 4`;;
  val it : thm = |- x = 1 + 2 + 3 + 4 <=> x = 10
\end{verbatim}
}

\SEEALSO
basic_convs, extend_basic_rewrites, set_basic_convs.

\ENDDOC
\DOC{extend{\_}basic{\_}rewrites}

\TYPE {\small\verb%extend_basic_rewrites : thm list -> unit%}\egroup

\SYNOPSIS
Extend the set of default rewrites used by rewriting and simplification.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. A call to
{\small\verb%extend_basic_rewrites thl%} extends the former with the list of theorems {\small\verb%thl%},
so they will thereafter happen by default.

\FAILURE
Never fails.

\SEEALSO
basic_rewrites, extend_basic_convs, set_basic_rewrites.

\ENDDOC
\DOC{extend{\_}rectype{\_}net}

\TYPE {\small\verb%extend_rectype_net : string * ('a * 'b * thm) -> unit%}\egroup

\SYNOPSIS
Extends internal store of distinctness and injectivity theorems for a new
inductive type.

\DESCRIBE
HOL Light maintains several data structures based on the current set of
distinctness and injectivity theorems for the inductive data type so far
defined. A call {\small\verb%extend_rectype_net ("tyname",(_,_,rth))%} where {\small\verb%rth%} is the
recursion theorem for the type as returned as the second item from
{\small\verb%define_type%}, extend these structures for a new type. Two arguments are
ignored just for regularity with some other internal data structures.

\FAILURE
Never fails, even if the theorem is malformed.

\COMMENTS
This function is called automatically by {\small\verb%define_type%}, and normally users will
not need to invoke it explicitly.

\SEEALSO
basic_rectype_net, define_type, distinctness_store, injectivity_store.
\ENDDOC
\DOC{fail}

\TYPE {\small\verb%fail : unit -> 'a%}\egroup

\SYNOPSIS
Fail with empty string.

\DESCRIBE
In HOL Light, the class of exceptions {\small\verb%Failure "string"%} is used consistently.
This makes it easy to catch all HOL-related exceptions by a {\small\verb%Failure _%} pattern
without accidentally catching others. In general, the failure can be generated
by {\small\verb%failwith "string"%}, but the special case of an empty string is bound to the
function {\small\verb%fail%}.

\FAILURE
Always fails.

\USES
Useful when there is no intention to propagate helpful information about the
cause of the exception, for example because you know it will be caught and
handled without discrimination.

\SEEALSO

\ENDDOC
\DOC{FAIL{\_}TAC}

\TYPE {\small\verb%FAIL_TAC : string -> tactic%}\egroup

\SYNOPSIS
Tactic that always fails, with the supplied string.

\DESCRIBE
Whatever goal it is applied to, {\small\verb%FAIL_TAC "s"%} always fails with {\small\verb%Failure "s"%}.

\FAILURE
The application of {\small\verb%FAIL_TAC%} to a string never fails; the resulting
tactic always fails.

\EXAMPLE
The following example uses the fact that if a tactic {\small\verb%t1%} solves
a goal, then the tactic {\small\verb%t1 THEN t2%} never results in the application
of {\small\verb%t2%} to anything, because {\small\verb%t1%} produces no subgoals. In attempting
to solve the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `if x then T else T`;;
\end{verbatim}
}
\noindent the tactic
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[] THEN FAIL_TAC "Simple rewriting failed to solve goal");;
  Exception: Failure "Simple rewriting failed to solve goal".
\end{verbatim}
}
\noindent fails with the message provided, whereas the following quietly solves
the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[COND_ID] THEN FAIL_TAC "Using that failed to solve goal");;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ALL_TAC, NO_TAC.

\ENDDOC
\DOC{file{\_}of{\_}string}

\TYPE {\small\verb%file_of_string : string -> string -> unit%}\egroup

\SYNOPSIS
Write out a string to a named file.

\DESCRIBE
Given a filename {\small\verb%fn%} and a string {\small\verb%s%}, the call {\small\verb%file_of_string fn s%} attempts
to open the file {\small\verb%fn%} for writing and writes the string {\small\verb%s%} to it before
closing. If the file exists, it will be overwritten, and otherwise a new file
will be created.

\FAILURE
Fails if the file cannot be opened for writing.

\EXAMPLE
The call
{\par\samepage\setseps\small
\begin{verbatim}
  # file_of_string "/tmp/hello" "Hello world\nGoodbye world";;
  val it : unit = ()
\end{verbatim}
}
will result in a file {\small\verb%/tmp/hello%} containing the text:
{\par\samepage\setseps\small
\begin{verbatim}
Hello world
Goodbye world

\SEEALSO
string_of_file, strings_of_file.

\ENDDOC
\DOC{file{\_}on{\_}path}

\TYPE {\small\verb%file_on_path : string list -> string -> string%}\egroup

\SYNOPSIS
Expands relative filename to first available one in path.

\DESCRIBE
When given an absolute filename, (e.g. on Linux/Unix one starting with a slash
or tilde), this function returns it unchanged. Otherwise it tries to find the
file in one of the directories in the path argument. An initial dollar sign {\small\verb%$%}
in each path is interpreted as a reference to the current setting of {\small\verb%hol_dir%}.
To get an actual {\small\verb%$%} at the start of the filename, actually use two dollar
signs {\small\verb%$$%}.

\FAILURE
Fails if no file is found on the path.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # file_on_path (!load_path) "Library/analysis.ml";;
  val it : string = "/home/johnh/holl/Library/analysis.ml"
  # file_on_path (!load_path) "Library/wibble.ml";;
  Exception: Not_found.
\end{verbatim}
}

\SEEALSO
help_path, hol_dir, load_on_path, load_path, loads, loadt, needs.

\ENDDOC
\DOC{filter}

\TYPE {\small\verb%filter : ('a -> bool) -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Filters a list to the sublist of elements satisfying a predicate.

\DESCRIBE
{\small\verb%filter p l%} applies {\small\verb%p%} to every element of {\small\verb%l%}, returning a list of those
that satisfy {\small\verb%p%}, in the order they appeared in the original list.

\FAILURE
Fails if the predicate fails on any element.

\SEEALSO
mapfilter, partition, remove.

\ENDDOC
\DOC{find}

\TYPE {\small\verb%find : ('a -> bool) -> 'a list -> 'a%}\egroup

\SYNOPSIS
Returns the first element of a list which satisfies a predicate.

\DESCRIBE
{\small\verb%find p [x1;...;xn]%} returns the first {\small\verb%xi%} in the list such that {\small\verb%(p xi)%}
is {\small\verb%true%}.

\FAILURE
Fails with {\small\verb%find%} if no element satisfies the predicate. This will always be
the case if the list is empty.

\SEEALSO
tryfind, mem, exists, forall, assoc, rev_assoc.

\ENDDOC
\DOC{FIND{\_}ASSUM}

\TYPE {\small\verb%FIND_ASSUM : thm_tactic -> term -> tactic%}\egroup

\SYNOPSIS
Apply a theorem-tactic to the the first assumption equal to given term.

\DESCRIBE
The tactic {\small\verb%FIND_ASSUM ttac `t`%} finds the first assumption whose conclusion is
{\small\verb%t%}, and applies {\small\verb%ttac%} to it. If there is no such assumption, the call fails.

\FAILURE
Fails if there is no assumption the same as the given term, or if the
theorem-tactic itself fails on the assumption.

\EXAMPLE
Suppose we set up this goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `0 = x /\ y = 0 ==> f(x + f(y)) = f(f(f(x) * x * y))`;;
\end{verbatim}
}
\noindent and move the hypotheses into the assumption list:
{\par\samepage\setseps\small
\begin{verbatim}
  # e STRIP_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`0 = x`]
   1 [`y = 0`]

  `f (x + f y) = f (f (f x * x * y))`
\end{verbatim}
}
We can't just use {\small\verb%ASM_REWRITE_TAC[]%} to solve the goal, but we can more
directly use the assumptions:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(FIND_ASSUM SUBST1_TAC `y = 0` THEN
      FIND_ASSUM (SUBST1_TAC o SYM) `0 = x`);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`0 = x`]
   1 [`y = 0`]

  `f (0 + f 0) = f (f (f 0 * 0 * 0))`
\end{verbatim}
}
\noindent after which simple rewriting solves the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[ADD_CLAUSES; MULT_CLAUSES]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Identifying an assumption to use by explicitly quoting it.

\COMMENTS
A similar effect can be achieved by {\small\verb%ttac(ASSUME `t`)%}. The use of {\small\verb%FIND_ASSUM%}
may be considered preferable because it immediately fails if there is no
assumption {\small\verb%t%}, whereas the {\small\verb%ASSUME%} construct only generates a validity
failure. Still, the the above example, it would have been a little briefer to
write:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[ASSUME `y = 0`; SYM(ASSUME `0 = x`);
                  ADD_CLAUSES; MULT_CLAUSES]);;
\end{verbatim}
}

\SEEALSO
ASSUME, VALID.

\ENDDOC
\DOC{find{\_}index}

\TYPE {\small\verb%find_index : ('a -> bool) -> 'a list -> int option%}\egroup

\SYNOPSIS
Returns position of an element in list satisfying the predicate.

\DESCRIBE
The call {\small\verb%find_index p l%} where l is a list returns the position number of the
first instance in the list satifying {\small\verb%p%}, or returns {\small\verb%None%} if there is none.
The indices start at zero, corresponding to {\small\verb%el%}.

\SEEALSO
el, find, index.

\ENDDOC
\DOC{find{\_}path}

\TYPE {\small\verb%find_path : (term -> bool) -> term -> string%}\egroup

\SYNOPSIS
Returns a path to some subterm satisfying a predicate.

\DESCRIBE
The call {\small\verb%find_path p t%} traverses the term {\small\verb%t%} top-down until it finds a
subterm satisfying the predicate {\small\verb%p%}. It then returns a path indicating how to
reach it; this is just a string with each character interpreted as:

\begin{itemize}

\item {\small\verb%"b"%}: take the body of an abstraction

\item {\small\verb%"l"%}: take the left (rator) path in an application

\item {\small\verb%"r"%}: take the right (rand) path in an application

\end{itemize}

\FAILURE
Fails if there is no subterm satisfying {\small\verb%p%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # find_path is_list `!x. ~(x = []) ==> CONS (HD x) (TL x) = x`;;
  Warning: inventing type variables
  val it : string = "rblrrr"
\end{verbatim}
}

\SEEALSO
follow_path, PATH_CONV.

\ENDDOC
\DOC{find{\_}term}

\TYPE {\small\verb%find_term : (term -> bool) -> term -> term%}\egroup

\SYNOPSIS
Searches a term for a subterm that satisfies a given predicate.

\DESCRIBE
The largest subterm, in a depth-first, left-to-right search
of the given term, that satisfies the predicate is returned.

\FAILURE
Fails if no subterm of the given term satisfies the predicate.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # find_term is_var `x + y + z`;;
  val it : term = `x`
\end{verbatim}
}

\SEEALSO
find_terms.

\ENDDOC
\DOC{find{\_}terms}

\TYPE {\small\verb%find_terms : (term -> bool) -> term -> term list%}\egroup

\SYNOPSIS
Searches a term for all subterms that satisfy a predicate.

\DESCRIBE
A list of subterms of a given term that satisfy the predicate is returned.

\FAILURE
Never fails.

\EXAMPLE
This is a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # find_terms is_var `x + y + z`;;
  val it : term list = [`z`; `y`; `x`]
\end{verbatim}
}
\noindent while the following shows that the terms returned may overlap or
contain each other:
{\par\samepage\setseps\small
\begin{verbatim}
  # find_terms is_comb `x + y + z`;;
  val it : term list = [`(+) y`; `y + z`; `(+) x`; `x + y + z`]
\end{verbatim}
}

\SEEALSO
find_term.

\ENDDOC
\DOC{finished}

\TYPE {\small\verb%finished : 'a list -> int * 'a list%}\egroup

\SYNOPSIS
Parser that checks emptiness of the input.

\DESCRIBE
The function {\small\verb%finished%} tests if its input is the empty list, and if so returns
a pair of zero and that input. Otherwise it fails.

\FAILURE
Fails on nonempty input.

\USES
This function is intended to check that some parsing operation has absorbed all
the input.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, fix, leftbin, listof, many, nothing, possibly,
rightbin, some.

\ENDDOC
\DOC{FIRST}

\TYPE {\small\verb%FIRST : tactic list -> tactic%}\egroup

\SYNOPSIS
Applies the first tactic in a tactic list that succeeds.

\DESCRIBE
When applied to a list of tactics {\small\verb%[t1;...;tn]%}, and a goal {\small\verb%g%}, the tactical
{\small\verb%FIRST%} tries applying the tactics to the goal until one succeeds. If the
first tactic which succeeds is {\small\verb%tm%}, then the effect is the same as just {\small\verb%tm%}.
Thus {\small\verb%FIRST%} effectively behaves as follows:
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST [t1;...;tn] = t1 ORELSE ... ORELSE tn
\end{verbatim}
}

\FAILURE
The application of {\small\verb%FIRST%} to a tactic list never fails. The resulting
tactic fails iff all the component tactics do when applied to the goal,
or if the tactic list is empty.

\SEEALSO
EVERY, ORELSE.

\ENDDOC
\DOC{FIRST{\_}ASSUM}

\TYPE {\small\verb%FIRST_ASSUM : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Applied theorem-tactic to first assumption possible.

\DESCRIBE
The tactic
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_ASSUM ttac ([A1; ...; An], g)
\end{verbatim}
}
\noindent has the effect of applying the first tactic which can be produced by
{\small\verb%ttac%} from the assumptions {\small\verb%(.. |- A1)%}, ..., {\small\verb%(.. |- An)%} and which
succeeds when applied to the goal. Failures of {\small\verb%ttac%} to produce a tactic are
ignored. The similar function {\small\verb%FIRST_X_ASSUM%} is the same except that the
assumption used is then removed from the goal.

\FAILURE
Fails if {\small\verb%ttac (.. |- Ai)%} fails for every assumption {\small\verb%Ai%}, or if the
assumption list is empty, or if all the tactics produced by {\small\verb%ttac%} fail when
applied to the goal.

\EXAMPLE
The tactic
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_ASSUM (fun asm -> CONTR_TAC asm  ORELSE  ACCEPT_TAC asm)
\end{verbatim}
}
\noindent searches the assumptions for either a contradiction or the desired
conclusion. The tactic
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_ASSUM MATCH_MP_TAC
\end{verbatim}
}
\noindent searches the assumption list for an implication whose conclusion
matches the goal, reducing the goal to the antecedent of the corresponding
instance of this implication.

\SEEALSO
ASSUM_LIST, EVERY, EVERY_ASSUM, FIRST, FIRST_X_ASSUM, MAP_EVERY, MAP_FIRST.

\ENDDOC
\DOC{FIRST{\_}CONV}

\TYPE {\small\verb%FIRST_CONV : conv list -> conv%}\egroup

\SYNOPSIS
Apply the first of the conversions in a given list that succeeds.

\DESCRIBE
{\small\verb%FIRST_CONV [c1;...;cn] `t`%} returns the result of applying to the term {\small\verb%`t`%}
the first conversion {\small\verb%ci%} that succeeds when applied to {\small\verb%`t`%}.  The conversions
are tried in the order in which they are given in the list.

\FAILURE
{\small\verb%FIRST_CONV [c1;...;cn] `t`%} fails if all the conversions {\small\verb%c1%}, ..., {\small\verb%cn%} fail
when applied to the term {\small\verb%`t`%}.  {\small\verb%FIRST_CONV cs `t`%} also fails if {\small\verb%cs%} is the
empty list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # FIRST_CONV [NUM_ADD_CONV; NUM_MULT_CONV; NUM_EXP_CONV] `12 * 12`;;
  val it : thm = |- 12 * 12 = 144
\end{verbatim}
}

\SEEALSO
ORELSEC.

\ENDDOC
\DOC{FIRST{\_}TCL}

\TYPE {\small\verb%FIRST_TCL : thm_tactical list -> thm_tactical%}\egroup

\SYNOPSIS
Applies the first theorem-tactical in a list that succeeds.

\DESCRIBE
When applied to a list of theorem-tacticals, a theorem-tactic and a theorem,
{\small\verb%FIRST_TCL%} returns the tactic resulting from the application of the first
theorem-tactical to the theorem-tactic and theorem that succeeds. The effect
is the same as:
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_TCL [ttl1;...;ttln] = ttl1 ORELSE_TCL ... ORELSE_TCL ttln
\end{verbatim}
}

\FAILURE
{\small\verb%FIRST_TCL%} fails iff each tactic in the list fails when applied to the
theorem-tactic and theorem. This is trivially the case if the list is empty.

\SEEALSO
EVERY_TCL, ORELSE_TCL, REPEAT_TCL, THEN_TCL.

\ENDDOC
\DOC{FIRST{\_}X{\_}ASSUM}

\TYPE {\small\verb%FIRST_X_ASSUM : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Applies theorem-tactic to first assumption possible, extracting assumption.

\DESCRIBE
The tactic
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_X_ASSUM ttac ([A1; ...; An], g)
\end{verbatim}
}
\noindent has the effect of applying the first tactic which can be produced by
{\small\verb%ttac%} from the assumptions {\small\verb%(.. |- A1)%}, ..., {\small\verb%(.. |- An)%} and which
succeeds when applied to the goal with that assumption removed. Failures of
{\small\verb%ttac%} to produce a tactic are ignored. The similar function {\small\verb%FIRST_ASSUM%} is
the same except that the assumption used is not removed from the goal.

\FAILURE
Fails if {\small\verb%ttac (.. |- Ai)%} fails for every assumption {\small\verb%Ai%}, or if the
assumption list is empty, or if all the tactics produced by {\small\verb%ttac%} fail when
applied to the goal.

\EXAMPLE
The tactic
{\par\samepage\setseps\small
\begin{verbatim}
   FIRST_X_ASSUM MATCH_MP_TAC
\end{verbatim}
}
\noindent searches the assumption list for an implication whose conclusion
matches the goal, removing that assumption and reducing the goal to the
antecedent of the corresponding instance of this implication.

\SEEALSO
ASSUM_LIST, EVERY, EVERY_ASSUM, FIRST, FIRST_ASSUM, MAP_EVERY, MAP_FIRST.

\ENDDOC
\DOC{fix}

\TYPE {\small\verb%fix : string -> ('a -> 'b) -> 'a -> 'b%}\egroup

\SYNOPSIS
Applies parser and fails if it raises {\small\verb%Noparse%}.

\DESCRIBE
Parsers raise {\small\verb%Noparse%} to indicate that they were not able to make any
progress at all. If {\small\verb%p%} is such a parser, {\small\verb%fix s p%} gives a new parser where
a {\small\verb%Noparse%} exception from {\small\verb%p%} will result in a {\small\verb%Failure s%} exception, but is
otherwise the same as {\small\verb%p%}.

\FAILURE
The immediate call {\small\verb%fix s p%} never fails, but the resulting parser may.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, leftbin, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{FIX{\_}TAC}

\TYPE {\small\verb%FIX_TAC : string -> tactic%}\egroup

\SYNOPSIS
Fixes universally quantified variables in goal.

\DESCRIBE

Given a string {\small\verb%s%} indicating a sequence of variable names, {\small\verb%FIX_TAC s%}
performs the introduction of the indicated universally quantified variables.
It is not required to specify the variables in any particular order. The
syntax for the string argument s allows the following patterns:

\begin{itemize}

\item a variable name {\small\verb%varname%} (meaning introduce the variable varname)

\item a pattern {\small\verb%[newname/varname]%} (meaning introduce {\small\verb%varname%} and call it
   {\small\verb%newname%})

\item a pattern {\small\verb%[newname]%} (meaning introduce the outermost variable and
   call it {\small\verb%newname%})

\item a final {\small\verb%*%} (meaning introduce the remaining outermost universal
   quantified variables)

\end{itemize}

\FAILURE
Fails if the string specifying the variables is ill-formed or if some of the
indicated variables are not present as outer universal quantifiers in the goal.

\EXAMPLE
Here we fix just the variable {\small\verb%a%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x a. a + x = x + a`;;
  # e (FIX_TAC "a");;
  val it : goalstack = 1 subgoal (1 total)

  `!x. a + x = x + a`
\end{verbatim}
}
\noindent while here we rename one of the variables and fix all the others:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a b x. a + b + x = (a + b) + x`;;
  # e (FIX_TAC "[d/x] *");;
  val it : goalstack = 1 subgoal (1 total)

  `a + b + d = (a + b) + d`
\end{verbatim}
}

Here we fix an automatically generated variable and choose a meaningful name
for it
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(@x. x = 0) + 0 = 0`;;
  # e SELECT_ELIM_TAC;;
  val it : goalstack = 1 subgoal (1 total)

  `!_75605. (!x. x = 0 ==> _75605 = 0) ==> _75605 + 0 = 0`

  # e (FIX_TAC "[y]");;
  val it : goalstack = 1 subgoal (1 total)

  `(!x. x = 0 ==> y = 0) ==> y + 0 = 0`
\end{verbatim}
}

\SEEALSO
GEN, GEN_TAC, INTRO_TAC, STRIP_TAC, X_GEN_TAC.

\ENDDOC
\DOC{flat}

\TYPE {\small\verb%flat : 'a list list -> 'a list%}\egroup

\SYNOPSIS
Flattens a list of lists into one long list.

\DESCRIBE
{\small\verb%flat [l1;...;ln]%} returns {\small\verb%(l1 @ ... @ ln)%} where each li is a list and {\small\verb%@%}
is list concatenation.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # flat [[1;2];[3;4;5];[6]];;
  val it : int list = [1; 2; 3; 4; 5; 6]
\end{verbatim}
}
\ENDDOC
\DOC{flush{\_}goalstack}

\TYPE {\small\verb%flush_goalstack : unit -> unit%}\egroup

\SYNOPSIS
Eliminate all but the current goalstate from the current goalstack.

\DESCRIBE
Normally, the current goalstack has the current goalstate at the head and all
previous intermediate states further back in the list. This function
{\small\verb%flush_goalstack()%} keeps just the current goalstate and eliminates all
previous states.

\FAILURE
Fails if there is no current goalstate, i.e. if the goalstack is empty.

\SEEALSO
b, g, r.

\ENDDOC
\DOC{foldl}

\TYPE {\small\verb%foldl : ('a -> 'b -> 'c -> 'a) -> 'a -> ('b, 'c) func -> 'a%}\egroup

\SYNOPSIS
Folds an operation iteratively over the graph of a finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If a finite partial function {\small\verb%p%} has graph {\small\verb%[x1,y1; ...; xn,yn]%} then the
application {\small\verb%foldl f a p%} returns
{\par\samepage\setseps\small
\begin{verbatim}
 f (f ... (f (f a x1 y1) x2 y2) ...) xn yn
\end{verbatim}
}
Note that the order in which the pairs are operated on depends on the internal
structure of the finite partial function, and is often not the most obvious.

\FAILURE
Fails if one of the embedded function applications does.

\EXAMPLE
The {\small\verb%graph%} function is implemented based on the following invocation of
{\small\verb%foldl%}, with an additional sorting phase afterwards:
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = (1 |-> 2) (2 |=> 3);;
  val f : (int, int) func = <func>

  # graph f;;
  val it : (int * int) list = [(1, 2); (2, 3)]

  # foldl (fun a x y -> (x,y)::a) [] f;;
  val it : (int * int) list = [(1, 2); (2, 3)]
\end{verbatim}
}
Note that in this case the order happened to be the same, but this is an
accident.

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{foldr}

\TYPE {\small\verb%foldr : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) func -> 'c -> 'c%}\egroup

\SYNOPSIS
Folds an operation iteratively over the graph of a finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If a finite partial function {\small\verb%p%} has graph {\small\verb%[x1,y1; ...; xn,yn]%} then the
application {\small\verb%foldl f p a%} returns
{\par\samepage\setseps\small
\begin{verbatim}
 f x1 y1 (f x2 y2 (f x3 y3 (f ... (f xn yn a) ... )))
\end{verbatim}
}
Note that the order in which the pairs are operated on depends on the internal
structure of the finite partial function, and is often not the most obvious.

\FAILURE
Fails if one of the embedded function applications does.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = (1 |-> 2) (2 |=> 3);;
  val f : (int, int) func = <func>

  # graph f;;
  val it : (int * int) list = [(1, 2); (2, 3)]

  # foldr (fun x y a -> (x,y)::a) f [];;
  val it : (int * int) list = [(2, 3); (1, 2)]
\end{verbatim}
}
Note how the pairs are actually processed in the opposite order to the order in
which they are presented by {\small\verb%graph%}. The order will in general not be obvious,
and generally this is applied to operations with appropriate commutativity
properties.

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{follow{\_}path}

\TYPE {\small\verb%follow_path : string -> term -> term%}\egroup

\SYNOPSIS
Find the subterm of a given term indicated by a path.

\DESCRIBE
A call {\small\verb%follow_path p t%} follows path {\small\verb%p%} inside {\small\verb%t%} and returns the subterm
encountered. The path is a string with the successive characters interpreted as
follows:

\begin{itemize}

\item {\small\verb%"b"%}: take the body of an abstraction

\item {\small\verb%"l"%}: take the left (rator) path in an application

\item {\small\verb%"r"%}: take the right (rand) path in an application

\end{itemize}

\FAILURE
Fails if the path is not meaningful for the term, e.g. if a {\small\verb%"b"%} is
encountered for a subterm that is not an abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # follow_path "rrlr" `1 + 2 + 3 + 4 + 5`;;
  val it : term = `3`
\end{verbatim}
}

\SEEALSO
find_path, PATH_CONV.

\ENDDOC
\DOC{forall}

\TYPE {\small\verb%forall : ('a -> bool) -> 'a list -> bool%}\egroup

\SYNOPSIS
Tests a list to see if all its elements satisfy a predicate.

\DESCRIBE
{\small\verb%forall p [x1;...;xn]%} returns {\small\verb%true%} if {\small\verb%(p xi)%} is true for all {\small\verb%xi%} in the
list. Otherwise it returns {\small\verb%false%}. If the list is empty, this function always
returns true.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # forall (fun x -> x <= 2) [0;1;2];;
  val it : bool = true
  # forall (fun x -> x <= 2) [1;2;3];;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
exists, find, tryfind, mem, assoc, rev_assoc.

\ENDDOC
\DOC{forall2}

\TYPE {\small\verb%forall2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool%}\egroup

\SYNOPSIS
Tests if corresponding elements of two lists all satisfy a relation.

\DESCRIBE
{\small\verb%forall p [x1;...;xn] [y1;...;yn]%} returns {\small\verb%true%} if {\small\verb%(p xi yi)%} is true for
all corresponding {\small\verb%xi%} and {\small\verb%yi%} in the list. Otherwise, or if the lengths of
the lists are different, it returns {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
Here we check whether all elements of the first list are less than the
corresponding element of the second:
{\par\samepage\setseps\small
\begin{verbatim}
  # forall2 (<) [1;2;3] [2;3;4];;
  val it : bool = true

  # forall2 (<) [1;2;3;4] [5;4;3;2];;
  val it : bool = false

  # forall2 (<) [1] [2;3];;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
exists, forall.

\ENDDOC
\DOC{FORALL{\_}UNWIND{\_}CONV}

\TYPE {\small\verb%FORALL_UNWIND_CONV : term -> thm%}\egroup

\SYNOPSIS
Eliminates universally quantified variables that are equated to something.

\DESCRIBE
The conversion {\small\verb%FORALL_UNWIND_CONV%}, applied to a formula with one or more
universal quantifiers around an implication, eliminates any quantifiers where
the antecedent of the implication contains a conjunct equating its variable to
some other term (with that variable not free in it).

\FAILURE
{\small\verb%FORALL_UNWIND_CONV tm%} fails if {\small\verb%tm%} is not reducible according to that
description.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # FORALL_UNWIND_CONV
     `!a b c d. a + 1 = b /\ b + 1 = c + 1 /\ d = e ==> a + b + c + d + e = 2`;;
  val it : thm =
    |- (!a b c d.
            a + 1 = b /\ b + 1 = c + 1 /\ d = e ==> a + b + c + d + e = 2) <=>
       (!a c. (a + 1) + 1 = c + 1 ==> a + (a + 1) + c + e + e = 2)
  # FORALL_UNWIND_CONV `!a b c. a = b /\ b = c ==> a + b = b + c`;;
  val it : thm =
    |- (!a b c. a = b /\ b = c ==> a + b = b + c) <=> (!c. c + c = c + c)
\end{verbatim}
}

\SEEALSO
UNWIND_CONV.

\ENDDOC
\DOC{frees}

\TYPE {\small\verb%frees : term -> term list%}\egroup

\SYNOPSIS
Returns a list of the variables free in a term.

\DESCRIBE
When applied to a term, {\small\verb%frees%} returns a list of the free variables in
that term. There are no repetitions in the list produced even if there are
multiple free instances of some variables.

\FAILURE
Never fails.

\EXAMPLE
Clearly in the following term, {\small\verb%x%} and {\small\verb%y%} are free, whereas {\small\verb%z%} is bound:
{\par\samepage\setseps\small
\begin{verbatim}
  # frees `x = 1 /\ y = 2 /\ !z. z >= 0`;;
  val it : term list = [`x`; `y`]
\end{verbatim}
}

\SEEALSO
atoms, freesl, free_in, thm_frees, variables.

\ENDDOC
\DOC{freesin}

\TYPE {\small\verb%freesin : term list -> term -> bool%}\egroup

\SYNOPSIS
Tests if all free variables of a term appear in a list.

\DESCRIBE
The call {\small\verb%freesin l t%} tests whether all free variables of {\small\verb%t%} occur in the
list {\small\verb%l%}. The special case where {\small\verb%l = []%} will therefore test whether {\small\verb%t%} is
closed (i.e. contains no free variables).

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # freesin [] `!x y. x + y >= 0`;;
  val it : bool = true
  # freesin [] `x + y >= 0`;;
  val it : bool = false
  # freesin [`x:num`; `y:num`; `z:num`] `x + y >= 0`;;
  val it : bool = true
\end{verbatim}
}

\USES
Can be attractive to fold together some free-variable tests without explicitly
constructing the set of free variables in a term.

\SEEALSO
frees, freesl, vfree_in.

\ENDDOC
\DOC{freesl}

\TYPE {\small\verb%freesl : term list -> term list%}\egroup

\SYNOPSIS
Returns a list of the free variables in a list of terms.

\DESCRIBE
When applied to a list of terms, {\small\verb%freesl%} returns a list of the variables which
are free in any of those terms. There are no repetitions in the list produced
even if several terms contain the same free variable.

\FAILURE
Never fails.

\EXAMPLE
In the following example there are free instances of each of {\small\verb%w%}, {\small\verb%x%} and {\small\verb%y%},
whereas the only instances of {\small\verb%z%} are bound:
{\par\samepage\setseps\small
\begin{verbatim}
  # freesl [`x + y = 2`; `!z. z >= x - w`];;
  val it : term list = [`y`; `x`; `w`]
\end{verbatim}
}

\SEEALSO
frees, free_in, thm_frees.

\ENDDOC
\DOC{FREEZE{\_}THEN}

\TYPE {\small\verb%FREEZE_THEN : thm_tactical%}\egroup

\SYNOPSIS
`Freezes' a theorem to prevent instantiation of its free variables.

\DESCRIBE
{\small\verb%FREEZE_THEN%} expects a tactic-generating function {\small\verb%f:thm->tactic%}
and a theorem {\small\verb%(A1 |- w)%} as arguments.  The tactic-generating function {\small\verb%f%}
is applied to the theorem {\small\verb%(w |- w)%}.  If this tactic generates the subgoal:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   =========  f (w |- w)
    A ?- t1
\end{verbatim}
}
\noindent then applying {\small\verb%FREEZE_THEN f (A1 |- w)%}
to the goal {\small\verb%(A ?- t)%} produces the subgoal:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   =========  FREEZE_THEN f (A1 |- w)
    A ?- t1
\end{verbatim}
}
\noindent Since the term {\small\verb%w%} is a hypothesis of the argument to the
function {\small\verb%f%}, none of the free variables present in {\small\verb%w%} may be
instantiated or generalized.  The hypothesis is discharged by
{\small\verb%PROVE_HYP%} upon the completion of the proof of the subgoal.

\FAILURE
Failures may arise from the tactic-generating function.  An invalid
tactic arises if the hypotheses of the theorem are not
alpha-convertible to assumptions of the goal.

\USES
Used in serious proof hacking to limit the matches achievable by rewriting etc.

\SEEALSO
ASSUME, IMP_RES_TAC, PROVE_HYP, RES_TAC, REWR_CONV.

\ENDDOC
\DOC{free{\_}in}

\TYPE {\small\verb%free_in : term -> term -> bool%}\egroup

\SYNOPSIS
Tests if one term is free in another.

\DESCRIBE
When applied to two terms {\small\verb%t1%} and {\small\verb%t2%}, the function {\small\verb%free_in%} returns
{\small\verb%true%} if {\small\verb%t1%} is free in {\small\verb%t2%}, and {\small\verb%false%} otherwise. It is not necessary
that {\small\verb%t1%} be simply a variable.

\FAILURE
Never fails.

\EXAMPLE
In the following example {\small\verb%free_in%} returns {\small\verb%false%} because the {\small\verb%x%} in {\small\verb%SUC x%}
in the second term is bound:
{\par\samepage\setseps\small
\begin{verbatim}
  # free_in `SUC x` `!x. SUC x = x + 1`;;
  val it : bool = false
\end{verbatim}
}
\noindent whereas the following call returns {\small\verb%true%} because the first instance
of {\small\verb%x%} in the second term is free, even though there is also a bound instance:
{\par\samepage\setseps\small
\begin{verbatim}
  # free_in `x:bool` `x /\ (?x. x=T)`;;
  val it : bool = true
\end{verbatim}
}

\COMMENTS
If the term {\small\verb%t1%} is a variable, the rule {\small\verb%vfree_in%} is more basic and probably
more efficient.

\SEEALSO
frees, freesin, freesl, thm_frees, vfree_in.

\ENDDOC
\DOC{funpow}

\TYPE {\small\verb%funpow : int -> ('a -> 'a) -> 'a -> 'a%}\egroup

\SYNOPSIS
Iterates a function a fixed number of times.

\DESCRIBE
{\small\verb%funpow n f x%} applies {\small\verb%f%} to {\small\verb%x%}, {\small\verb%n%} times, giving the result {\small\verb%f (f ... (f
x)...)%} where the number of {\small\verb%f%}'s is {\small\verb%n%}. {\small\verb%funpow 0 f x%} returns {\small\verb%x%}. If {\small\verb%n%} is
negative, it is treated as zero.

\FAILURE
{\small\verb%funpow n f x%} fails if any of the {\small\verb%n%} applications of f fail.

\EXAMPLE
Apply {\small\verb%tl%} three times to a list:
{\par\samepage\setseps\small
\begin{verbatim}
  # funpow 3 tl [1;2;3;4;5];;
  val it : int list = [4; 5]
\end{verbatim}
}
\noindent Apply {\small\verb%tl%} zero times:
{\par\samepage\setseps\small
\begin{verbatim}
  # funpow 0 tl [1;2;3;4;5];;
  val it : int list = [1; 2; 3; 4; 5]
\end{verbatim}
}
\noindent Apply {\small\verb%tl%} six times to a list of only five elements:
{\par\samepage\setseps\small
\begin{verbatim}
  # funpow 6 tl [1;2;3;4;5];;
  Exception: Failure "tl".
\end{verbatim}
}

\ENDDOC
\DOC{F{\_}F}

\TYPE {\small\verb%(F_F) : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd%}\egroup

\SYNOPSIS

Infix operator. Applies two functions to a pair:
{\small\verb%(f F_F g) (x,y)%} = {\small\verb%(f x, g y)%}.

\DESCRIBE

\FAILURE

Never fails.

\EXAMPLE

\USES

\COMMENTS

\SEEALSO
f_f_

\ENDDOC
\DOC{f{\_}f{\_}}

\TYPE {\small\verb%f_f_ : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%F_F%}.

\SEEALSO
F_F.

\ENDDOC
\DOC{g}

\TYPE {\small\verb%g : term -> goalstack%}\egroup

\SYNOPSIS
Initializes the subgoal package with a new goal which has no assumptions.

\DESCRIBE
The call
{\par\samepage\setseps\small
\begin{verbatim}
   g `tm`
\end{verbatim}
}
\noindent is equivalent to
{\par\samepage\setseps\small
\begin{verbatim}
   set_goal([],`tm`)
\end{verbatim}
}
\noindent and clearly more convenient if a goal has no assumptions.
For a description of the subgoal package, see  {\small\verb%set_goal%}.

\FAILURE
Fails unless the argument term has type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `HD[1;2;3] = 1 /\ TL[1;2;3] = [2;3]`;;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3]`
\end{verbatim}
}

\SEEALSO
b, e, er, p, r, set_goal, top_goal, top_thm.

\ENDDOC
\DOC{GABS{\_}CONV}

\TYPE {\small\verb%GABS_CONV : conv -> term -> thm%}\egroup

\SYNOPSIS
Applies a conversion to the body of a generalized abstraction.

\DESCRIBE
If {\small\verb%c%} is a conversion that maps a term {\small\verb%`t`%} to the theorem {\small\verb%|- t = t'%}, then
the conversion {\small\verb%ABS_CONV c%} maps generalized abstractions of the form
{\small\verb%`\vs. t`%} to theorems of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\vs. t) = (\vs. t')
\end{verbatim}
}
\noindent That is, {\small\verb%ABS_CONV c `\vs. t`%} applies {\small\verb%c%} to the body of the
generalized abstraction {\small\verb%`\vs. t`%}. It is permissible to use it on a basic
abstraction, in which case the effect is the same as {\small\verb%ABS_CONV%}.

\FAILURE
Fails if applied to a term that is not a generalized abstraction (or a basic
one), or if the conversion {\small\verb%c%} fails when applied to the term {\small\verb%t%}, or if the
theorem returned has assumptions in which one of the variables in the
abstraction varstruct is free.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # GABS_CONV SYM_CONV `\(x,y,z). x + y + z = 7`;;
  val it : thm = |- (\(x,y,z). x + y + z = 7) = (\(x,y,z). 7 = x + y + z)
\end{verbatim}
}

\SEEALSO
ABS_CONV, RAND_CONV, RATOR_CONV, SUB_CONV.

\ENDDOC
\DOC{gcd}

\TYPE {\small\verb%gcd : int -> int -> int%}\egroup

\SYNOPSIS
Computes greatest common divisor of two integers.

\DESCRIBE
The call {\small\verb%gcd m n%} for two integers {\small\verb%m%} and {\small\verb%n%} returns the (nonnegative)
greatest common divisor of {\small\verb%m%} and {\small\verb%n%}. If {\small\verb%m%} and {\small\verb%n%} are both zero, it
returns zero.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # gcd 10 12;;
  val it : int = 2

  # gcd 11 27;;
  val it : int = 1

  # gcd (-33) 76;;
  val it : int = 1

  # gcd 0 99;;
  val it : int = 99

  # gcd 0 0;;
  val it : int = 0
\end{verbatim}
}

\SEEALSO
gcd_num, lcm_num.

\ENDDOC
\DOC{gcd{\_}num}

\TYPE {\small\verb%gcd_num : num -> num -> num%}\egroup

\SYNOPSIS
Computes greatest common divisor of two unlimited-precision integers.

\DESCRIBE
The call {\small\verb%gcd_num m n%} for two unlimited-precision (type {\small\verb%num%}) integers {\small\verb%m%}
and {\small\verb%n%} returns the (positive) greatest common divisor of {\small\verb%m%} and {\small\verb%n%}. If
both {\small\verb%m%} and {\small\verb%n%} are zero, it returns zero.

\FAILURE
Fails if either number is not an integer (the type {\small\verb%num%} supports arbitrary
rationals).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # gcd_num (Int 35) (Int(-77));;
  val it : num = 7

  # gcd_num (Int 11) (Int 0);;
  val it : num = 11

  # gcd_num (Int 22 // Int 7) (Int 2);;
  Exception: Failure "big_int_of_ratio".
\end{verbatim}
}

\SEEALSO
gcd, lcm_num.

\ENDDOC
\DOC{GEN}

\TYPE {\small\verb%GEN : term -> thm -> thm%}\egroup

\SYNOPSIS
Generalizes the conclusion of a theorem.

\DESCRIBE
When applied to a term {\small\verb%x%} and a theorem {\small\verb%A |- t%}, the inference rule
{\small\verb%GEN%} returns the theorem {\small\verb%A |- !x. t%}, provided {\small\verb%x%} is a variable not
free in any of the assumptions. There is no compulsion that {\small\verb%x%} should
be free in {\small\verb%t%}.
{\par\samepage\setseps\small
\begin{verbatim}
      A |- t
   ------------  GEN `x`                [where x is not free in A]
    A |- !x. t
\end{verbatim}
}
\FAILURE
Fails if {\small\verb%x%} is not a variable, or if it is free in any of the assumptions.

\EXAMPLE
This is a basic example:
{\par\samepage\setseps\small
\begin{verbatim}
  # GEN `x:num` (REFL `x:num`);;
  val it : thm = |- !x. x = x
\end{verbatim}
}
\noindent while the following example shows how the above side-condition
prevents the derivation of the theorem {\small\verb%x <=> T |- !x. x <=> T%}, which is
invalid.
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = ASSUME `x <=> T`;;
  val t : thm = x <=> T |- x <=> T

  # GEN `x:bool` t;;
  Exception: Failure "GEN".
\end{verbatim}
}

\SEEALSO
GENL, GEN_ALL, GEN_TAC, SPEC, SPECL, SPEC_ALL, SPEC_TAC.

\ENDDOC
\DOC{GENERAL{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%GENERAL_REWRITE_CONV : bool -> (conv -> conv) -> gconv net -> thm list -> conv%}\egroup

\SYNOPSIS
Rewrite with theorems as well as an existing net.

\DESCRIBE
The call {\small\verb%GENERAL_REWRITE_CONV b cnvl net thl%} will regard {\small\verb%thl%} as rewrite
rules, and if {\small\verb%b = true%}, also potentially as conditional rewrite rules. These
extra rules will be incorporated into the existing {\small\verb%net%}, and rewriting applied
with a search strategy {\small\verb%cnvl%} (e.g. {\small\verb%DEPTH_CONV%}).

\COMMENTS
This is mostly for internal use, but it can sometimes be more efficient when
rewriting with large sets of theorems repeatedly if they are first composed
into a net and then augmented like this.

\SEEALSO
GEN_REWRITE_CONV, REWRITES_CONV.

\ENDDOC
\DOC{GENL}

\TYPE {\small\verb%GENL : term list -> thm -> thm%}\egroup

\SYNOPSIS
Generalizes zero or more variables in the conclusion of a theorem.

\DESCRIBE
When applied to a term list {\small\verb%[x1;...;xn]%} and a theorem {\small\verb%A |- t%}, the inference
rule {\small\verb%GENL%} returns the theorem {\small\verb%A |- !x1...xn. t%}, provided none of the
variables {\small\verb%xi%} are free in any of the assumptions. It is not necessary that
any or all of the {\small\verb%xi%} should be free in {\small\verb%t%}.
{\par\samepage\setseps\small
\begin{verbatim}
         A |- t
   ------------------  GENL `[x1;...;xn]`       [where no xi is free in A]
    A |- !x1...xn. t
\end{verbatim}
}

\FAILURE
Fails unless all the terms in the list are variables, none of which are
free in the assumption list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SPEC `m + p:num` ADD_SYM;;
  val it : thm = |- !n. (m + p) + n = n + m + p

  # GENL [`m:num`; `p:num`] it;;
  val it : thm = |- !m p n. (m + p) + n = n + m + p
\end{verbatim}
}

\SEEALSO
GEN, GEN_ALL, GEN_TAC, SPEC, SPECL, SPEC_ALL, SPEC_TAC.

\ENDDOC
\DOC{genvar}

\TYPE {\small\verb%genvar : hol_type -> term%}\egroup

\SYNOPSIS
Returns a `fresh' variable with specified type.

\DESCRIBE
When given a type, {\small\verb%genvar%} returns a variable of that type whose name has not
previously been produced by {\small\verb%genvar%}.

\FAILURE
Never fails.

\EXAMPLE
The following indicates the typical stylized form of the names (this should
not be relied on, of course):
{\par\samepage\setseps\small
\begin{verbatim}
  # genvar `:bool`;;
  val it : term = `_56799`
\end{verbatim}
}
There is no guard against users' own variables clashing, but if the user avoids
names in the same lexical style, that can be guaranteed.

\USES
The unique variables are useful in writing derived rules, for specializing
terms without having to worry about such things as free variable capture.
If the names are to be visible to a typical user, the function {\small\verb%variant%} can
provide rather more meaningful names.

\SEEALSO
variant.

\ENDDOC
\DOC{GEN{\_}ALL}

\TYPE {\small\verb%GEN_ALL : thm -> thm%}\egroup

\SYNOPSIS
Generalizes the conclusion of a theorem over its own free variables.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t%}, the inference rule {\small\verb%GEN_ALL%} returns
the theorem {\small\verb%A |- !x1...xn. t%}, where the {\small\verb%xi%} are all the variables,
if any, which are free in {\small\verb%t%} but not in the assumptions.
{\par\samepage\setseps\small
\begin{verbatim}
         A |- t
   ------------------  GEN_ALL
    A |- !x1...xn. t
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ARITH_RULE `x < y ==> 2 * x + y + 1 < 3 * y`;;
  val th : thm = |- x < y ==> 2 * x + y + 1 < 3 * y

  # GEN_ALL th;;
  val it : thm = |- !x y. x < y ==> 2 * x + y + 1 < 3 * y
\end{verbatim}
}

\SEEALSO
GEN, GENL, GEN_ALL, SPEC, SPECL, SPEC_ALL, SPEC_TAC.

\ENDDOC
\DOC{GEN{\_}ALPHA{\_}CONV}

\TYPE {\small\verb%GEN_ALPHA_CONV : term -> term -> thm%}\egroup

\SYNOPSIS
Renames the bound variable of an abstraction or binder.

\DESCRIBE
The conversion {\small\verb%GEN_ALPHA_CONV%} provides alpha conversion for lambda
abstractions of the form {\small\verb%`\x. t`%}, as well as other terms of the form
{\small\verb%`b (\x. t)`%} such as quantifiers and other binders. (Note that whether {\small\verb%b%} is
a constant or parses as a binder is irrelevant, though this is usually the case
in applications.) The call {\small\verb%GEN_ALPHA_CONV `y` `\x. t`%} returns
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\x. t)  = (\y. t[y/x])
\end{verbatim}
}
\noindent while {\small\verb%GEN_ALPHA_CONV `y` `b (\x. t)`%} returns
{\par\samepage\setseps\small
\begin{verbatim}
   |- b (\x. t)  = b (\y. t[y/x])
\end{verbatim}
}

\FAILURE
{\small\verb%GEN_ALPHA_CONV `y` tm%} fails if {\small\verb%y%} is not a variable, or if {\small\verb%tm%} does not
have one of the forms {\small\verb%`\x. t`%} or {\small\verb%`b (\x. t)`%}, or if the types of {\small\verb%x%} and
{\small\verb%y%} differ, or if {\small\verb%y%} is already free in the body {\small\verb%t%}.

\SEEALSO
alpha, ALPHA, ALPHA_CONV.

\ENDDOC
\DOC{GEN{\_}BETA{\_}CONV}

\TYPE {\small\verb%GEN_BETA_CONV : term -> thm%}\egroup

\SYNOPSIS
Beta-reduces general beta-redexes (e.g. paired ones).

\DESCRIBE
The conversion {\small\verb%GEN_BETA_CONV%} will perform beta-reduction of simple
beta-redexes in the manner of {\small\verb%BETA_CONV%}, or of generalized beta-redexes such
as paired redexes.

\FAILURE
{\small\verb%GEN_BETA_CONV tm%} fails if {\small\verb%tm%} is neither a simple nor a tupled beta-redex.

\EXAMPLE
The following examples show the action of {\small\verb%GEN_BETA_CONV%} on tupled redexes and
others:
{\par\samepage\setseps\small
\begin{verbatim}
  # GEN_BETA_CONV `(\x. x + 1) 2`;;
  val it : thm = |- (\x. x + 1) 2 = 2 + 1

  # GEN_BETA_CONV `(\(x,y,z). x + y + z) (1,2,3)`;;
  val it : thm = |- (\(x,y,z). x + y + z) (1,2,3) = 1 + 2 + 3

  # GEN_BETA_CONV `(\[a;b;c]. b) [1;2;3]`;;
  val it : thm = |- (\[a; b; c]. b) [1; 2; 3] = 2
\end{verbatim}
}
However, it will fail if there is a mismatch between the varstruct and the
argument, or if it is unable to make sense of the generalized abstraction:
{\par\samepage\setseps\small
\begin{verbatim}
  # GEN_BETA_CONV `(\(SUC n). n) 3`;;
  Exception: Failure "term_pmatch".

  # GEN_BETA_CONV `(\(x,y,z). x + y + z) (1,x)`;;
  Exception: Failure "dest_comb: not a combination".
\end{verbatim}
}

\SEEALSO
BETA_CONV, MATCH_CONV.

\ENDDOC
\DOC{GEN{\_}MESON{\_}TAC}

\TYPE {\small\verb%GEN_MESON_TAC : int -> int -> int -> thm list -> tactic%}\egroup

\SYNOPSIS
First-order proof search with specified search limits and increment.

\DESCRIBE
This is a slight generalization of the usual tactics for first-order proof
search. Normally {\small\verb%MESON%}, {\small\verb%MESON_TAC%} and {\small\verb%ASM_MESON_TAC%} explore the search
space by successively increasing a size limit from 0, increasing it by 1 per
step and giving up when a depth of 50 is reached. The more general tactic
{\small\verb%GEN_MESON_TAC%} allows the user to specify the starting, finishing and stepping
value, but is otherwise identical to {\small\verb%ASM_MESON_TAC%}. In fact, that is defined
as:
{\par\samepage\setseps\small
\begin{verbatim}
  # let ASM_MESON_TAC = GEN_MESON_TAC 0 50 1;;
\end{verbatim}
}

\FAILURE
If the goal is unprovable, {\small\verb%GEN_MESON_TAC%} will fail, though not necessarily in
a feasible amount of time.

\USES
Normally, the defaults built into {\small\verb%MESON_TAC%} and {\small\verb%ASM_MESON_TAC%} are
reasonably effective. However, very occasionally a goal exhibits a small search
space yet still requires a deep proof, so you may find {\small\verb%GEN_MESON_TAC%} with a
larger ``maximum'' value than 50 useful. Another potential use is to start the
search at a depth that you know will succeed, to reduce the search time when a
proof is re-run. However, the inconvenience of doing this is seldom repaid by a
dramatic improvement in performance, since exploration is normally at least
exponential with the size bound.

\SEEALSO
ASM_MESON_TAC, MESON, MESON_TAC, METIS_TAC.

\ENDDOC
\DOC{GEN{\_}NNF{\_}CONV}

\TYPE {\small\verb%GEN_NNF_CONV : bool -> conv * (term -> thm * thm) -> conv%}\egroup

\SYNOPSIS
General NNF (negation normal form) conversion.

\DESCRIBE
The function {\small\verb%GEN_NNF_CONV%} is a highly general conversion for putting a term
in `negation normal form' (NNF). This means that other propositional
connectives are eliminated in favour of conjunction (`{\small\verb%/\%}'), disjunction
(`{\small\verb%\/%}') and negation (`{\small\verb%~%}'), and the negations are pushed down to the level
of atomic formulas, also through universal and existential quantifiers, with
double negations eliminated.

This function is very general. The first, boolean, argument determines how
logical equivalences `{\small\verb%p <=> q%}' are split. If the flag is {\small\verb%true%}, toplevel
equivalences are split ``conjunctively'' into `{\small\verb%(p \/ ~q) /\ (~p \/ q)%}', while
if it is false they are split ``disjunctively'' into
`{\small\verb%(p /\ q) \/ (~p /\ ~q)%}'. At subformulas, the effect is modified
appropriately in order to make the resulting formula simpler in conjunctive
normal form (if the flag is true) or disjunctive normal form (if the flag is
false).

The second argument has two components. The first is a conversion to apply to
literals, that is atomic formulas or their negations. The second is a slightly
more elaborate variant of the same thing, taking an atomic formula {\small\verb%p%} and
returning desired equivalences for both {\small\verb%p%} and {\small\verb%~p%} in a pair. This interface
avoids multiple recomputations in terms involving many nested logical
equivalences, where otherwise the core conversion would be called several
times.

\FAILURE
Never fails but may have no effect.

\COMMENTS
The simple functions like {\small\verb%NNF_CONV%} should be adequate most of the time, with
this somewhat intricate interface being reserved for special situations.

\SEEALSO
NNF_CONV, NNFC_CONV.

\ENDDOC
\DOC{GEN{\_}PART{\_}MATCH}

\TYPE {\small\verb%GEN_PART_MATCH : (term -> term) -> thm -> term -> thm%}\egroup

\SYNOPSIS
Instantiates a theorem by matching part of it to a term.

\DESCRIBE
When applied to a `selector' function of type {\small\verb%term -> term%}, a theorem and a
term:
{\par\samepage\setseps\small
\begin{verbatim}
   GEN_PART_MATCH fn (A |- !x1...xn. t) tm
\end{verbatim}
}
\noindent the function {\small\verb%GEN_PART_MATCH%} applies {\small\verb%fn%} to {\small\verb%t'%} (the result of
specializing universally quantified variables in the conclusion of the
theorem), and attempts to match the resulting term to the argument term
{\small\verb%tm%}.  If it succeeds, the appropriately instantiated version of the
theorem is returned. Limited higher-order matching is supported, and some
attempt is made to maintain bound variable names in higher-order matching.
Unlike {\small\verb%PART_MATCH%}, free variables in the initial theorem that are
unconstrained by the instantiation will be renamed if necessary to avoid
clashes with determined free variables.

\FAILURE
Fails if the selector function {\small\verb%fn%} fails when applied to the instantiated
theorem, or if the match fails with the term it has provided.

\EXAMPLE
See {\small\verb%MATCH_MP_TAC%} for more basic examples. The following illustrates the
difference with that function
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ARITH_RULE `m = n ==> m + p = n + p`;;
  val th : thm = |- m = n ==> m + p = n + p

  # PART_MATCH lhand th `n:num = p`;;
  val it : thm = |- n = p ==> n + p = p + p

  # GEN_PART_MATCH lhand th `n:num = p`;;
  val it : thm = |- n = p ==> n + p' = p + p'
\end{verbatim}
}

\SEEALSO
INST_TYPE, MATCH_MP, PART_MATCH, REWR_CONV, term_match.

\ENDDOC
\DOC{GEN{\_}REAL{\_}ARITH}

\TYPE {\small\verb%GEN_REAL_ARITH : ((thm list * thm list * thm list -> positivstellensatz -> thm) -> thm list * thm list * thm list -> thm) -> term -> thm%}\egroup

\SYNOPSIS
Initial normalization and proof reconstruction wrapper for real decision
procedure.

\DESCRIBE
The function {\small\verb%GEN_REAL_ARITH%} takes two arguments, the first of which is an
underlying `prover', and the second a term to prove. This function is mainly
intended for internal use: the function {\small\verb%REAL_ARITH%} is essentially implemented
as
{\par\samepage\setseps\small
\begin{verbatim}
  GEN_REAL_ARITH REAL_LINEAR_PROVER
\end{verbatim}
}
The wrapper {\small\verb%GEN_REAL_ARITH%} performs various initial normalizations, such as
eliminating {\small\verb%max%}, {\small\verb%min%} and {\small\verb%abs%}, and passes to the prover a proof
reconstruction function, say {\small\verb%reconstr%}, and a triple of theorem lists to
refute. The theorem lists are respectively a list of equations of the form {\small\verb%A_i
|- p_i = &0%}, a list of non-strict inequalities of the form {\small\verb%B_j |- q_i >= &0%},
and a list of strict inequalities of the form {\small\verb%C_k |- r_k > &0%}, with both
sides being real in each case. The underlying prover merely needs to find a
``Positivstellensatz'' refutation, and pass the triple of theorems actually
used and the Positivstellensatz refutation back to the reconstruction function
{\small\verb%reconstr%}. A Positivstellensatz refutation is essentially a representation of
how to add and multiply equalities or inequalities chosen from the list to
reach a trivially false equation or inequality such as {\small\verb%&0 > &0%}. Note that the
underlying prover may choose to augment the list of inequalities before
proceeding with the proof, e.g. {\small\verb%REAL_LINEAR_PROVER%} adds theorems {\small\verb%|- &0 <=
&n%} for relevant numeral terms {\small\verb%&n%}. This is why the interface passes in a
reconstruction function rather than simply expecting a Positivstellensatz
refutation back.

\FAILURE
Never fails at this stage, though it may fail when subsequently applied to a
term.

\EXAMPLE
As noted, the built-in decision procedure {\small\verb%REAL_ARITH%} is a simple application.
See also the file {\small\verb%Examples/sos.ml%}, where a more sophisticated nonlinear
prover is plugged into {\small\verb%GEN_REAL_ARITH%} in place of {\small\verb%REAL_LINEAR_PROVER%}.

\COMMENTS
Mainly intended for experts.

\SEEALSO
REAL_ARITH, REAL_LINEAR_PROVER, REAL_POLY_CONV.

\ENDDOC
\DOC{GEN{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%GEN_REWRITE_CONV : (conv -> conv) -> thm list -> conv%}\egroup

\SYNOPSIS
Rewrites a term, selecting terms according to a user-specified strategy.

\DESCRIBE
Rewriting in HOL is based on the use of equational theorems as left-to-right
replacements on the subterms of an object theorem.  This replacement is
mediated by the use of {\small\verb%REWR_CONV%}, which finds matches between left-hand sides
of given equations in a term and applies the substitution.

Equations used in rewriting are obtained from the theorem lists given as
arguments to the function. These are at first transformed into a form suitable
for rewriting. Conjunctions are separated into individual rewrites. Theorems
with conclusions of the form {\small\verb%`~t`%} are transformed into the corresponding
equations {\small\verb%`t = F`%}. Theorems {\small\verb%`t`%} which are not equations are cast as
equations of form {\small\verb%`t = T`%}.

If a theorem is used to rewrite a term, its assumptions are added to the
assumptions of the returned theorem. The matching involved uses variable
instantiation. Thus, all free variables are generalized, and terms are
instantiated before substitution. Theorems may have universally quantified
variables.

The theorems with which rewriting is done are divided into two groups, to
facilitate implementing other rewriting tools. However, they are considered in
an order-independent fashion. (That is, the ordering is an implementation
detail which is not specified.)

The search strategy for finding matching subterms is the first argument to the
rule. Matching and substitution may occur at any level of the term, according
to the specified search strategy: the whole term, or starting from any subterm.
The search strategy also specifies the depth of the search: recursively up to
an arbitrary depth until no matches occur, once over the selected subterm, or
any more complex scheme.

\FAILURE
{\small\verb%GEN_REWRITE_CONV%} fails if the search strategy fails. It may also cause a
non-terminating sequence of rewrites, depending on the search strategy used.

\USES
This conversion is used in the system to implement all other rewritings
conversions, and may provide a user with a method to fine-tune rewriting of
terms.

\EXAMPLE
Suppose we have a term of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   `(1 + 2) + 3 = (3 + 1) + 2`
\end{verbatim}
}
\noindent and we would like to rewrite the left-hand side with the
theorem {\small\verb%ADD_SYM%} without changing the right hand side. This can be
done by using:
{\par\samepage\setseps\small
\begin{verbatim}
   GEN_REWRITE_CONV (RATOR_CONV o ONCE_DEPTH_CONV) [ADD_SYM] mythm
\end{verbatim}
}
\noindent Other rules, such as {\small\verb%ONCE_REWRITE_CONV%}, would match and
substitute on both sides, which would not be the desirable result.

\SEEALSO
ONCE_REWRITE_CONV, PURE_REWRITE_CONV, REWR_CONV, REWRITE_CONV.

\ENDDOC
\DOC{GEN{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%GEN_REWRITE_RULE : (conv -> conv) -> thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem, selecting terms according to a user-specified strategy.

\DESCRIBE
Rewriting in HOL is based on the use of equational theorems as left-to-right
replacements on the subterms of an object theorem.  This replacement is
mediated by the use of {\small\verb%REWR_CONV%}, which finds matches between left-hand sides
of given equations in a term and applies the substitution.

Equations used in rewriting are obtained from the theorem lists given as
arguments to the function. These are at first transformed into a form suitable
for rewriting. Conjunctions are separated into individual rewrites. Theorems
with conclusions of the form {\small\verb%`~t`%} are transformed into the corresponding
equations {\small\verb%`t = F`%}. Theorems {\small\verb%`t`%} which are not equations are cast as
equations of form {\small\verb%`t = T`%}.

If a theorem is used to rewrite the object theorem, its assumptions are added
to the assumptions of the returned theorem, unless they are alpha-convertible
to existing assumptions.  The matching involved uses variable instantiation.
Thus, all free variables are generalized, and terms are instantiated before
substitution. Theorems may have universally quantified variables.

The theorems with which rewriting is done are divided into two groups, to
facilitate implementing other rewriting tools. However, they are considered in
an order-independent fashion. (That is, the ordering is an implementation
detail which is not specified.)

The search strategy for finding matching subterms is the first argument to the
rule. Matching and substitution may occur at any level of the term, according
to the specified search strategy: the whole term, or starting from any subterm.
The search strategy also specifies the depth of the search: recursively up to
an arbitrary depth until no matches occur, once over the selected subterm, or
any more complex scheme.

\FAILURE
{\small\verb%GEN_REWRITE_RULE%} fails if the search strategy fails. It may also cause a
non-terminating sequence of rewrites, depending on the search strategy used.

\USES
This rule is used in the system to implement all other rewriting
rules, and may provide a user with a method to fine-tune rewriting of
theorems.

\EXAMPLE
Suppose we have a theorem of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   mythm = |- (1 + 2) + 3 = (3 + 1) + 2
\end{verbatim}
}
\noindent and we would like to rewrite the left-hand side with the
theorem {\small\verb%ADD_SYM%} without changing the right hand side. This can be
done by using:
{\par\samepage\setseps\small
\begin{verbatim}
   GEN_REWRITE_RULE (RATOR_CONV o ONCE_DEPTH_CONV) []  [ADD_SYM] mythm
\end{verbatim}
}
\noindent Other rules, such as {\small\verb%ONCE_REWRITE_RULE%}, would match and
substitute on both sides, which would not be the desirable result.

\SEEALSO
ASM_REWRITE_RULE, ONCE_REWRITE_RULE, PURE_REWRITE_RULE, REWR_CONV,
REWRITE_RULE.

\ENDDOC
\DOC{GEN{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%GEN_REWRITE_TAC : (conv -> conv) -> thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal, selecting terms according to a user-specified strategy.

\DESCRIBE
Distinct rewriting tactics differ in the search strategies used in finding
subterms on which to apply substitutions, and the built-in theorems used in
rewriting. In the case of {\small\verb%REWRITE_TAC%}, this is a recursive traversal starting
from the body of the goal's conclusion part, while in the case of
{\small\verb%ONCE_REWRITE_TAC%}, for example, the search stops as soon as a term on which a
substitution is possible is found. {\small\verb%GEN_REWRITE_TAC%} allows a user to specify a
more complex strategy for rewriting.

The basis of pattern-matching for rewriting is the notion of conversions,
through the application of {\small\verb%REWR_CONV%}.  Conversions are rules for mapping
terms with theorems equating the given terms to other semantically equivalent
ones.

When attempting to rewrite subterms recursively, the use of conversions (and
therefore rewrites) can be automated further by using functions which take a
conversion and search for instances at which they are applicable. Examples of
these functions are {\small\verb%ONCE_DEPTH_CONV%} and {\small\verb%RAND_CONV%}. The first argument to
{\small\verb%GEN_REWRITE_TAC%} is such a function, which specifies a search strategy; i.e.
it specifies how subterms (on which substitutions are allowed) should be
searched for.

The second argument is a list of theorems used for rewriting. The
order in which these are used is not specified. The theorems need not be in
equational form: negated terms, say {\small\verb%"~ t"%}, are transformed into the
equivalent equational form {\small\verb%"t = F"%}, while other non-equational theorems with
conclusion of form {\small\verb%"t"%} are cast as the corresponding equations {\small\verb%"t = T"%}.
Conjunctions are separated into the individual components, which are used as
distinct rewrites.

\FAILURE
{\small\verb%GEN_REWRITE_TAC%} fails if the search strategy fails. It may also cause a
non-terminating sequence of rewrites, depending on the search strategy used.
The resulting tactic is invalid when a theorem which matches the goal (and
which is thus used for rewriting it with) has a hypothesis which is not
alpha-convertible to any of the assumptions of the goal. Applying such an
invalid tactic may result in a proof of a theorem which does not correspond to
the original goal.

\USES
Detailed control of rewriting strategy, allowing a user to specify a search
strategy.

\EXAMPLE
Given a goal such as:
{\par\samepage\setseps\small
\begin{verbatim}
   ?- a - (b + c) = a - (c + b)
\end{verbatim}
}
\noindent we may want to rewrite only one side of it with a theorem,
say {\small\verb%ADD_SYM%}. Rewriting tactics which operate recursively result in
divergence; the tactic {\small\verb%ONCE_REWRITE_TAC [ADD_SYM]%} rewrites on both
sides to produce the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
   ?- a - (c + b) = a - (b + c)
\end{verbatim}
}
\noindent as {\small\verb%ADD_SYM%} matches at two positions. To rewrite on
only one side of the equation, the following tactic can be used:
{\par\samepage\setseps\small
\begin{verbatim}
   GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV) [ADD_SYM]
\end{verbatim}
}
\noindent which produces the desired goal:
{\par\samepage\setseps\small
\begin{verbatim}
   ?- a - (c + b) = a - (c + b)
\end{verbatim}
}

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_RULE, ONCE_REWRITE_TAC, PURE_REWRITE_TAC,
REWR_CONV, REWRITE_TAC,

\ENDDOC
\DOC{GEN{\_}SIMPLIFY{\_}CONV}

\TYPE {\small\verb%GEN_SIMPLIFY_CONV : strategy -> simpset -> int -> thm list -> conv%}\egroup

\SYNOPSIS
General simplification with given strategy and simpset and theorems.

\DESCRIBE
The call {\small\verb%GEN_SIMPLIFY_CONV strat ss n thl%} incorporates the rewrites and
conditional rewrites derived from {\small\verb%thl%} into the simpset {\small\verb%ss%}, then simplifies
using that simpset, controlling the traversal of the term by {\small\verb%strat%}, and
starting at level {\small\verb%n%}.

\FAILURE
Never fails unless some component is malformed.

\SEEALSO
GEN_REWRITE_CONV, ONCE_SIMPLIFY_CONV, SIMPLIFY_CONV, SIMP_CONV, SIMP_RULE,
SIMP_TAC.

\ENDDOC
\DOC{GEN{\_}TAC}

\TYPE {\small\verb%GEN_TAC : tactic%}\egroup

\SYNOPSIS
Strips the outermost universal quantifier from the conclusion of a goal.

\DESCRIBE
When applied to a goal {\small\verb%A ?- !x. t%}, the tactic {\small\verb%GEN_TAC%} reduces it to
{\small\verb%A ?- t[x'/x]%} where {\small\verb%x'%} is a variant of {\small\verb%x%} chosen to avoid clashing with any
variables free in the goal's assumption list. Normally {\small\verb%x'%} is just {\small\verb%x%}.
{\par\samepage\setseps\small
\begin{verbatim}
     A ?- !x. t
   ==============  GEN_TAC
    A ?- t[x'/x]
\end{verbatim}
}
\FAILURE
Fails unless the goal's conclusion is universally quantified.

\USES
The tactic {\small\verb%REPEAT GEN_TAC%} strips away any universal quantifiers, and
is commonly used before tactics relying on the  underlying term structure.

\SEEALSO
FIX_TAC, GEN, GENL, GEN_ALL, INTRO_TAC, SPEC, SPECL, SPEC_ALL, SPEC_TAC,
STRIP_TAC, X_GEN_TAC.

\ENDDOC
\DOC{get{\_}const{\_}type}

\TYPE {\small\verb%get_const_type : string -> hol_type%}\egroup

\SYNOPSIS
Gets the generic type of a constant from the name of the constant.

\DESCRIBE
{\small\verb%get_const_type "c"%} returns the generic type of {\small\verb%`c`%}, if {\small\verb%`c`%} is a constant.

\FAILURE
{\small\verb%get_const_type st%} fails if {\small\verb%st%} is not the name of a constant.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # get_const_type "COND";;
  val it : hol_type = `:bool->A->A->A`
\end{verbatim}
}

\SEEALSO
dest_const, is_const.

\ENDDOC
\DOC{get{\_}infix{\_}status}

\TYPE {\small\verb%get_infix_status : string -> int * string%}\egroup

\SYNOPSIS
Get the precedence and associativity of an infix operator.

\DESCRIBE
Certain identifiers are treated as infix operators with a given precedence and
associativity (left or right). The call {\small\verb%get_infix_status "op"%} looks up {\small\verb%op%}
in this list and returns a pair consisting of its precedence and its
associativity; the latter is one of the strings {\small\verb%"left"%} or {\small\verb%"right"%}.

\FAILURE
Fails if the given string does not have infix status.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # get_infix_status "/";;
  val it : int * string = (22, "left")
  # get_infix_status "UNION";;
  val it : int * string = (16, "right")
\end{verbatim}
}

\SEEALSO
infixes, parse_as_infix, unparse_as_infix.

\ENDDOC
\DOC{get{\_}type{\_}arity}

\TYPE {\small\verb%get_type_arity : string -> int%}\egroup

\SYNOPSIS
Returns the arity of a type constructor.

\DESCRIBE
When applied to the name of a type constructor, {\small\verb%arity%} returns its arity, i.e.
how many types it is supposed to be applied to. Base types like {\small\verb%:bool%} are
regarded as constructors with zero arity.

\FAILURE
Fails if there is no type constructor of that name.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # get_type_arity "bool";;
  val it : int = 0

  # get_type_arity "fun";;
  val it : int = 2

  # get_type_arity "nocon";;
  Exception: Failure "find".
\end{verbatim}
}

\SEEALSO
new_type, new_type_definition, types.

\ENDDOC
\DOC{graph}

\TYPE {\small\verb%graph : ('a, 'b) func -> ('a * 'b) list%}\egroup

\SYNOPSIS
Returns the graph of a finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The {\small\verb%graph%} function takes a finite partial function that maps {\small\verb%x1%} to
{\small\verb%y1%}, ..., {\small\verb%xn%} to {\small\verb%yn%} and returns its graph as a set/list:
{\small\verb%[x1,y1; ...; xn,yn]%}.

\FAILURE
Attempts to sort the resulting list, so may fail if the type of the pairs does
not permit comparison.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # graph undefined;;
  val it : ('a * 'b) list = []
  # graph (1 |=> 2);;
  val it : (int * int) list = [(1, 2)]
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{GSYM}

\TYPE {\small\verb%GSYM : thm -> thm%}\egroup

\SYNOPSIS
Reverses the first equation(s) encountered in a top-down search.

\DESCRIBE
The inference rule {\small\verb%GSYM%} reverses the first equation(s) encountered in a
top-down search of the conclusion of the argument theorem. An equation will be
reversed iff it is not a proper subterm of another equation. If a theorem
contains no equations, it will be returned unchanged.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- ..(s1 = s2)...(t1 = t2)..
   --------------------------------  GSYM
    A |- ..(s2 = s1)...(t2 = t1)..
\end{verbatim}
}
\FAILURE
Never fails, and never loops infinitely.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD;;
  val it : thm = |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n))

  # GSYM ADD;;
  val it : thm = |- (!n. n = 0 + n) /\ (!m n. SUC (m + n) = SUC m + n)
\end{verbatim}
}
\SEEALSO
REFL, SYM.

\ENDDOC
\DOC{HAS{\_}SIZE{\_}CONV}

\TYPE {\small\verb%HAS_SIZE_CONV : term -> thm%}\egroup

\SYNOPSIS
Converts statement about set's size into existential enumeration.

\DESCRIBE
Given a term of the form {\small\verb%`s HAS_SIZE n`%} for a numeral {\small\verb%n%}, the conversion
{\small\verb%HAS_SIZE_CONV%} returns an equivalent form postulating the existence of {\small\verb%n%}
pairwise distinct elements that make up the set.

\FAILURE
Fails if applied to a term of the wrong form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # HAS_SIZE_CONV `s HAS_SIZE 1`;;
  ...
  val it : thm = |- s HAS_SIZE 1 <=> (?a. s = {a})

  # HAS_SIZE_CONV `t HAS_SIZE 3`;;
  ...
  val it : thm =
    |- t HAS_SIZE 3 <=>
       (?a a' a''. ~(a' = a'') /\ ~(a = a') /\ ~(a = a'') /\ t = {a, a', a''})
\end{verbatim}
}

\ENDDOC
\DOC{HAS{\_}SIZE{\_}DIMINDEX{\_}RULE}

\TYPE {\small\verb%HAS_SIZE_DIMINDEX_RULE : hol_type -> thm%}\egroup

\SYNOPSIS
Computes the {\small\verb%dimindex%} for a standard finite type.

\DESCRIBE
Finite types parsed and printed as numerals are provided, and this conversion
when applied to such a type of the form {\small\verb%`:n`%} returns the theorem
{\small\verb%|- (:n) HAS_SIZE n%} where the {\small\verb%(:n)%} is the customary HOL Light printing of
the universe set {\small\verb%UNIV:n->bool%}, the second {\small\verb%n%} is a numeral term and
{\small\verb%HAS_SIZE%} is the usual cardinality relation.

\FAILURE
Fails if the type provided is not a standard finite type.

\EXAMPLE
Here we use a 64-element type, perhaps useful for indexing the bits of a
word:
{\par\samepage\setseps\small
\begin{verbatim}
  # HAS_SIZE_DIMINDEX_RULE `:64`;;
  val it : thm = |- (:64) HAS_SIZE 64
\end{verbatim}
}

\SEEALSO
dest_finty, DIMINDEX_CONV, DIMINDEX_TAC, mk_finty.

\ENDDOC
\DOC{hd}

\TYPE {\small\verb%hd : 'a list -> 'a%}\egroup

\SYNOPSIS
Computes the first element (the head) of a list.

\DESCRIBE
{\small\verb%hd [x1;...;xn]%} returns {\small\verb%x1%}.

\FAILURE
Fails with {\small\verb%hd%} if the list is empty.

\SEEALSO
tl, el.

\ENDDOC
\DOC{help}

\TYPE {\small\verb%help : string -> unit%}\egroup

\SYNOPSIS
Displays help on a given identifier in the system.

\DESCRIBE
A call {\small\verb%help "s"%} will attempt to display the help file associated with a
particular identifier {\small\verb%s%} in the system. If there is no entry for identifier
{\small\verb%s%}, the call responds instead with some possibly helpful suggestions as to
what you might have meant, based on a simple `edit distance' criterion.

The built-in help files are stored in the {\small\verb%Help%} subdirectory of HOL Light.
Users can add additional locations by modifying {\small\verb%help_path%}. Normally the help
file for an identifier {\small\verb%name%} would be called {\small\verb%name.hlp%}, but there are a few
exceptions, because some identifiers have characters that cannot be put in
filenames and some platforms like Cygwin have inadequate case sensitivity.

\FAILURE
Never fails.

\EXAMPLE
Here is a successful call:
{\par\samepage\setseps\small
\begin{verbatim}
  # help "lhs";;
  -------------------------------------------------------------------

  lhs : term -> term

  SYNOPSIS

  Returns the left-hand side of an equation.

  DESCRIPTION

  lhs `t1 = t2` returns `t1`.

  FAILURE CONDITIONS

  Fails with lhs if the term is not an equation.

  EXAMPLES


    # lhs `2 + 2 = 4`;;
    val it : term = `2 + 2`


  SEE ALSO
  dest_eq, lhand, rand, rhs.

  -------------------------------------------------------------------
  val it : unit = ()
\end{verbatim}
}
\noindent and here is one for a non-existent identifier:
{\par\samepage\setseps\small
\begin{verbatim}
  # help "IMP_TAC";;
  -------------------------------------------------------------------
  No help found for "IMP_TAC"; did you mean:

  help "SIMP_TAC";;
  help "MP_TAC";;
  help "IMP_TRANS";;

  ?
  --------------------------------------------------------------------
\end{verbatim}
}

\SEEALSO
help_path, hol_version.

\ENDDOC
\DOC{help{\_}path}

\TYPE {\small\verb%help_path : string list ref%}\egroup

\SYNOPSIS
Path where HOL Light tries to find help files.

\DESCRIBE
The reference variable {\small\verb%help_path%} gives a list of directories. When using the
online {\small\verb%help%} function, HOL Light will search in these places for help files.
An initial dollar sign {\small\verb%$%} in each path is interpreted as a reference to the
current setting of {\small\verb%hol_dir%}. To get an actual {\small\verb%$%} at the start of the
filename, actually use two dollar signs {\small\verb%$$%}.

\FAILURE
Not applicable.

\SEEALSO
file_on_path, help, hol_dir, hol_expand_directory, load_on_path, load_path,
loads, loadt.

\ENDDOC
\DOC{hide{\_}constant}

\TYPE {\small\verb%hide_constant : string -> unit%}\egroup

\SYNOPSIS
Stops the quotation parser from recognizing a constant.

\DESCRIBE
A call {\small\verb%hide_constant "c"%} where {\small\verb%c%} is the name of a constant, will
prevent the quotation parser from parsing it as such; it will just be parsed as
a variable. The effect can be reversed by {\small\verb%unhide_constant "c"%}.

\FAILURE
Fails if the given name is not a constant of the current theory, or if the
named constant is already hidden.

\COMMENTS
The hiding of a constant only affects the quotation parser; the constant is
still there in a theory, and may not be redefined.

\SEEALSO
unhide_constant.

\ENDDOC
\DOC{HIGHER{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%HIGHER_REWRITE_CONV : thm list -> bool -> term -> thm%}\egroup

\SYNOPSIS
Rewrite once using more general higher order matching.

\DESCRIBE
The call {\small\verb%HIGHER_REWRITE_CONV [th1;...;thn] flag t%} will find a higher-order
match for the whole term {\small\verb%t%} against one of the left-hand sides of the
equational theorems in the list {\small\verb%[th1;...;thn]%}. Each such theorem should be of
the form {\small\verb%|- P pat <=> t%} where {\small\verb%f%} is a variable. A free subterm {\small\verb%pat'%} of {\small\verb%t%}
will be found that matches (in the usual restricted higher-order sense) the
pattern {\small\verb%pat%}. If the {\small\verb%flag%} argument is true, this will be some topmost
matchable term, while if it is false, some innermost matchable term will be
selected. The rewrite is then applied by instantiating {\small\verb%P%} to a lambda-term
reflecting how {\small\verb%t%} is built up from {\small\verb%pat'%}, and beta-reducing as in normal
higher-order matching. However, this process is more general than HOL Light's
normal higher-order matching (as in {\small\verb%REWRITE_CONV%} etc., with core behaviour
inherited from {\small\verb%PART_MATCH%}), because {\small\verb%pat'%} need not be uniquely determined by
bound variable correspondences.

\FAILURE
Fails if no match is found.

\EXAMPLE
The theorem {\small\verb%COND_ELIM_THM%} can be applied to eliminate conditionals:
{\par\samepage\setseps\small
\begin{verbatim}
  # COND_ELIM_THM;;
  val it : thm = |- P (if c then x else y) <=> (c ==> P x) /\ (~c ==> P y)
\end{verbatim}
}
\noindent in a term like this:
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = `z = if x = 0 then if y = 0 then 0 else x + y else x + y`;;
  val t : term = `z = (if x = 0 then if y = 0 then 0 else x + y else x + y)`
\end{verbatim}
}
\noindent either outermost first:
{\par\samepage\setseps\small
\begin{verbatim}
  # HIGHER_REWRITE_CONV[COND_ELIM_THM] true t;;
  val it : thm =
    |- z = (if x = 0 then if y = 0 then 0 else x + y else x + y) <=>
       (x = 0 ==> z = (if y = 0 then 0 else x + y)) /\ (~(x = 0) ==> z = x + y)
\end{verbatim}
}
\noindent or innermost first:
{\par\samepage\setseps\small
\begin{verbatim}
  # HIGHER_REWRITE_CONV[COND_ELIM_THM] false t;;
  val it : thm =
    |- z = (if x = 0 then if y = 0 then 0 else x + y else x + y) <=>
       (y = 0 ==> z = (if x = 0 then 0 else x + y)) /\
       (~(y = 0) ==> z = (if x = 0 then x + y else x + y))
\end{verbatim}
}

\USES
Applying general simplification patterns without manual instantiation.

\SEEALSO
PART_MATCH, REWRITE_CONV.

\ENDDOC
\DOC{HINT{\_}EXISTS{\_}TAC}

\TYPE {\small\verb%HINT_EXISTS_TAC : tactic%}\egroup

\SYNOPSIS
Attemps to instantiate existential goals from context.

\DESCRIBE
Given a goal which contains some subformula of the form
{\small\verb%?x_1... x_k. P_1 y^1_1 ... y^1_m1 /\ ... /\ P_n y^n_1 ... y^n_mn%} in a
context where {\small\verb%P_i t_1 ... t_mi%} holds for some {\small\verb%t_1,...,t_mi%}, then
instantiates {\small\verb%x_i1,...,x_i_mi%} with {\small\verb%t_1,...,t_mi%}. The ``context'' consists in
the assumptions or in the premisses of the implications where the existential
subformula occurs.

Note: it is enough that just P t holds, not the complete existentially
quantified formula. As the name suggests, we just use the context as a ``hint''
but it is (in most general uses) not sufficient to solve the existential
completely: if this is doable automatically, then other techniques can do the
job in a better way (typically {\small\verb%MESON%}).

\FAILURE
Fails if no instantiation is found from the context.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!P Q R S. P 1 /\ Q 2 /\ R 3 ==> ?x y. P x /\ R y /\ S x y`;;
  val it : goalstack = 1 subgoal (1 total)

  `!P Q R S. P 1 /\ Q 2 /\ R 3 ==> (?x y. P x /\ R y /\ S x y)`

  # e HINT_EXISTS_TAC;;
  val it : goalstack = 1 subgoal (1 total)

  `!P Q R S. P 1 /\ Q 2 /\ R 3 ==> S 1 3`
\end{verbatim}
}

\USES
When facing an existential goal, it happens often that the context ``suggests''
a candidate to be a witness. In many cases, this is because the existential
goal is partly satisfied by a proposition in the context. However, often, the
context does not allow to automatically prove completely the existential using
this witness. Therefore, usual automation tactics are useless. Usually, in such
circumstances, one has to provide the witness explicitly. This is tedious and
time-consuming whereas this witness can be found automatically from the
context, this is what this tactic allows to do.

\SEEALSO
EXISTS_TAC, IMP_REWRITE_TAC, SIMP_TAC.

\ENDDOC
\DOC{hol{\_}dir}

\TYPE {\small\verb%hol_dir : string ref%}\egroup

\SYNOPSIS
Base directory in which HOL Light is installed.

\DESCRIBE
This reference variable holds the directory (folder) for the base of the HOL
Light distribution. This information is used, for example, when loading files
with {\small\verb%loads%}. Normally set to the current directory when HOL Light is loaded or
built, but picked up from the system variable {\small\verb%HOLLIGHT_DIR%} if it is defined.

\FAILURE
Not applicable.

\EXAMPLE
On my laptop, the value is:
{\par\samepage\setseps\small
\begin{verbatim}
  # !hol_dir;;
  val it : string = "/home/johnh/holl"
\end{verbatim}
}

\USES
Ensuring that HOL Light can find any libraries or other system files needed to
support proofs.

\SEEALSO
load_path, loads.

\ENDDOC
\DOC{hol{\_}expand{\_}directory}

\TYPE {\small\verb%hol_expand_directory : string -> string%}\egroup

\SYNOPSIS
Modifies directory name starting with {\small\verb%$%} to include HOL directory

\DESCRIBE
The function {\small\verb%hol_expand_directory%} takes a string indicating a directory. If
it does not begin with a dollar sign {\small\verb%$%}, the string is returned unchanged.
Otherwise, the initial dollar sign is replaced with the current HOL Light
directory {\small\verb%hol_dir%}. To get an actual {\small\verb%$%} at the start of the returned
directory, actually use two dollar signs {\small\verb%$$%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # hol_dir;;
  val it : string ref = {\small\verb%contents = "/home/johnh/holl"%}
  # hol_expand_directory "$/Help";;
  val it : string = "/home/johnh/holl/Help"
\end{verbatim}
}

\SEEALSO
file_on_path, help_path, load_on_path, load_path.

\ENDDOC
\DOC{hol{\_}version}

\TYPE {\small\verb%hol_version : string%}\egroup

\SYNOPSIS
A string indicating the version of HOL Light.

\DESCRIBE
This string is a numeric version number for HOL Light.

\FAILURE
Not applicable.

\EXAMPLE
On my laptop, the value is:
{\par\samepage\setseps\small
\begin{verbatim}
  # hol_version;;
  val it : string = "2.10"
\end{verbatim}
}

\SEEALSO
startup_banner.

\ENDDOC
\DOC{hyp}

\TYPE {\small\verb%hyp : thm -> term list%}\egroup

\SYNOPSIS
Returns the hypotheses of a theorem.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t%}, the function {\small\verb%hyp%} returns {\small\verb%A%}, the
list of hypotheses of the theorem.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ADD_ASSUM `x = 1` (ASSUME `y = 2`);;
  val th : thm = y = 2, x = 1 |- y = 2

  # hyp th;;
  val it : term list = [`y = 2`; `x = 1`]
\end{verbatim}
}

\SEEALSO
dest_thm, concl.

\ENDDOC
\DOC{HYP{\_}TAC}

\TYPE {\small\verb%HYP_TAC : string -> (thm -> thm) -> tactic%}\egroup

\SYNOPSIS
Applies a rule to a named hypothesis.

\DESCRIBE

Given a string {\small\verb%s%} and a rule {\small\verb%r%}, {\small\verb%HYP_TAC s r%} applies {\small\verb%r%} to the hypothesis
labeled {\small\verb%l%} as specified by the pattern {\small\verb%s%} which can be of one of the
following form:

\begin{itemize}

\item "{\small\verb%l%} : {\small\verb%patt%}", meaning apply {\small\verb%r%} to hypothesis {\small\verb%l%} and destruct it
  with {\small\verb%patt%}, like {\small\verb%REMOVE_THEN l (DESTRUCT_TAC patt o r)%}

\item a label {\small\verb%"l"%}, meaning apply {\small\verb%r%} to the hypothesis {\small\verb%l%}, a shorthand for
  {\small\verb%HYP_TAC "l : l" r%}

\item "{\small\verb%l%} : {\small\verb%patt%}", meaning apply {\small\verb%r%} to hypothesis {\small\verb%l%} and destruct it
  with {\small\verb%patt%} but keep hypothesis {\small\verb%l%}, like
  {\small\verb%USE_THEN l (DESTRUCT_TAC patt o r)%}

\end{itemize}

\FAILURE
Applied to its arguments fails if the pattern is ill-formed.  When executed
as a tactic, fails if it refers to non-existent hypothesis or the rule fails
or do not produce a theorem of a suitable form.

\EXAMPLE
Here we use the theorem {\small\verb%MEMBER_NOT_EMPTY%} to obtain an element {\small\verb%a%} from a
non empty set {\small\verb%s%}
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!s. ~(s = {\small\verb%%}) ==> (minimal n. n IN s) IN s`;;
  # e (INTRO_TAC "!s; s");;
  # e (HYP_TAC "s : @a. +" (REWRITE_RULE[GSYM MEMBER_NOT_EMPTY]));;
  val it : goalstack = 1 subgoal (1 total)

    `a IN s ==> (minimal n. n IN s) IN s`
\end{verbatim}
}
\noindent next we can finish with this goal with
{\par\samepage\setseps\small
\begin{verbatim}
  # e (MESON_TAC[MINIMAL]);;
\end{verbatim}
}

Here we derive that a strictly positive number is a non negative number
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x. &0 < x ==> &0 <= inv x`;;
  # e (INTRO_TAC "!x; xgt");;
  # e (HYP_TAC "xgt -> xge" (MATCH_MP REAL_LT_IMP_LE));;
  val it : goalstack = 1 subgoal (1 total)

    0 [`&0 < x`] (xgt)
    1 [`&0 <= x`] (xge)

  `&0 <= inv x`
\end{verbatim}
}
\noindent then we can solve the goal with
{\par\samepage\setseps\small
\begin{verbatim}
  # e (HYP SIMP_TAC "xge" [REAL_LE_INV]);;
\end{verbatim}
}

\SEEALSO
DESTRUCT_TAC, HYP, LABEL_TAC, REMOVE_THEN, USE_THEN

\ENDDOC
\DOC{HYP}

\TYPE {\small\verb%HYP : (thm list -> tactic) -> string -> thm list -> tactic%}\egroup

\SYNOPSIS
Augments a tactic's theorem list with named assumptions.

\DESCRIBE
If {\small\verb%tac%} is a tactic that expects a list of theorems as its arguments, e.g.
{\small\verb%MESON_TAC%}, {\small\verb%REWRITE_TAC%} or {\small\verb%SET_TAC%}, then {\small\verb%HYP tac s%} converts it to a
tactic where that list is augmented by the goal's assumptions specified in the
string argument s, which is a list of alphanumeric identifiers separated by
whitespace, e.g. {\small\verb%"lab1 lab2"%}.

\FAILURE
When fully applied to a goal, it will fail if the string specifying the labels
is ill-formed, if any of the specified assumption labels are not found in
the goal, or if the tactic itself fails on the combined list of theorems.

\EXAMPLE
With the following trivial goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `p /\ q /\ r ==> r /\ q`;;
\end{verbatim}
}
We may start by assuming and labelling the hypotheses, which may conveniently
be done using {\small\verb%INTRO_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(INTRO_TAC "asm_p asm_q asm_r");;
  val it : goalstack = 1 subgoal (1 total)

    0 [`p`] (asm_p)
    1 [`q`] (asm_q)
    2 [`r`] (asm_r)

  `r /\ q`
\end{verbatim}
}
The resulting goal can trivially be solved in any number of ways, but if we
want to ensure that {\small\verb%MESON_TAC%} uses exactly the assumptions relating to {\small\verb%q%}
and {\small\verb%r%} and no extraneous ones, we could do:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(HYP MESON_TAC "asm_r asm_q" []);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ASM, ASSUM_LIST, FREEZE_THEN, LABEL_TAC, MESON_TAC, REMOVE_THEN, REWRITE_TAC,
SET_TAC, USE_THEN.

\ENDDOC
\DOC{I}

\TYPE {\small\verb%I : 'a -> 'a%}\egroup

\SYNOPSIS
Performs identity operation: {\small\verb%I x%} = {\small\verb%x%}.

\FAILURE
Never fails.

\SEEALSO
C, K, F_F, o, W.

\ENDDOC
\DOC{ideal{\_}cofactors}

\TYPE {\small\verb%ideal_cofactors : (term -> num) * (num -> term) * conv * term * term * term * term * term * term * term * thm * (term -> thm) -> term list -> term -> term list%}\egroup

\SYNOPSIS
Generic procedure to compute cofactors for ideal membership.

\DESCRIBE
The {\small\verb%ideal_cofactors%} function takes first the same set of arguments as {\small\verb%RING%},
defining a suitable ring for it to operate over. (See the entry for {\small\verb%RING%} for
details.) It then yields a function that given a list of terms {\small\verb%[p1; ...; pn]%}
and another term {\small\verb%p%}, all of which have the right type to be considered as
polynomials over the ring, attempts to find a corresponding set of `cofactors'
{\small\verb%[q1; ...; qn]%} such that the following is an algebraic ring identity:
{\par\samepage\setseps\small
\begin{verbatim}
  p = p1 * q1 + ... + pn * qn
\end{verbatim}
}
That is, it provides a concrete certificate for the fact that {\small\verb%p%} is in the
ideal generated by the {\small\verb%p1,...,pn%}. If {\small\verb%p%} is not in this ideal, the function
will fail.

\FAILURE
Fails if the `polynomials' are of the wrong type, or if ideal membership does
not hold.

\EXAMPLE
For an example of the real-number instantiation in action, see
{\small\verb%real_ideal_cofactors%}.

\SEEALSO
real_ideal_cofactors, RING, RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{ignore{\_}constant{\_}varstruct}

\TYPE {\small\verb%ignore_constant_varstruct : bool ref%}\egroup

\SYNOPSIS
Interpret a simple varstruct as a variable, even if there is a constant of that
name.

\DESCRIBE
As well as conventional abstractions {\small\verb%`\x. t`%} where {\small\verb%x%} is a variable, HOL
Light permits generalized abstractions where the varstruct is a more complex
term, e.g. {\small\verb%`\(x,y). x + y`%}. This includes the degenerate case of just a
constant. However, one may want a regular abstraction whose bound variable
happens to be in use as a constant. When parsing a quotation {\small\verb%"\c. t"%} where
{\small\verb%c%} is the name of a constant, HOL Light interprets it as a simple abstraction
with a variable {\small\verb%c%} when the flag {\small\verb%ignore_constant_varstruct%} is {\small\verb%true%}, as it
is by default. It will interpret it as a degenerate generalized abstraction,
only useful when applied to the constant {\small\verb%c%}, if the flag is {\small\verb%false%}.

\FAILURE
Not applicable.

\SEEALSO
GEN_BETA_CONV, is_abs, is_gabs.

\ENDDOC
\DOC{implode}

\TYPE {\small\verb%implode : string list -> string%}\egroup

\SYNOPSIS
Concatenates a list of strings into one string.

\DESCRIBE
{\small\verb%implode [s1;...;sn]%} returns the string formed by concatenating the
strings {\small\verb%s1 ... sn%}. If {\small\verb%n%} is zero (the list is empty), then the empty string
is returned.

\FAILURE
Never fails; accepts empty or multi-character component strings.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # implode ["e";"x";"a";"m";"p";"l";"e"];;
  val it : string = "example"
  # implode ["ex";"a";"mpl";"";"e"];;
  val it : string = "example"
\end{verbatim}
}

\SEEALSO
explode.

\ENDDOC
\DOC{IMP{\_}ANTISYM{\_}RULE}

\TYPE {\small\verb%IMP_ANTISYM_RULE : thm -> thm -> thm%}\egroup

\SYNOPSIS
Deduces equality of boolean terms from forward and backward implications.

\DESCRIBE
When applied to the theorems {\small\verb%A1 |- t1 ==> t2%} and {\small\verb%A2 |- t2 ==> t1%}, the
inference rule {\small\verb%IMP_ANTISYM_RULE%} returns the theorem {\small\verb%A1 u A2 |- t1 <=> t2%}.
{\par\samepage\setseps\small
\begin{verbatim}
   A1 |- t1 ==> t2     A2 |- t2 ==> t1
  -------------------------------------  IMP_ANTISYM_RULE
           A1 u A2 |- t1 <=> t2
\end{verbatim}
}

\FAILURE
Fails unless the theorems supplied are a complementary implicative
pair as indicated above.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = TAUT `p /\ q ==> q /\ p`
    and th2 = TAUT `q /\ p ==> p /\ q`;;
  val th1 : thm = |- p /\ q ==> q /\ p
  val th2 : thm = |- q /\ p ==> p /\ q

  # IMP_ANTISYM_RULE th1 th2;;
  val it : thm = |- p /\ q <=> q /\ p
\end{verbatim}
}

\SEEALSO
EQ_IMP_RULE, EQ_MP, EQ_TAC.

\ENDDOC
\DOC{IMP{\_}RES{\_}THEN}

\TYPE {\small\verb%IMP_RES_THEN : thm_tactical%}\egroup

\SYNOPSIS
Resolves an implication with the assumptions of a goal.

\DESCRIBE
The function {\small\verb%IMP_RES_THEN%} is the basic building block for resolution in HOL.
This is not full higher-order, or even first-order, resolution with
unification, but simply one way simultaneous pattern-matching (resulting in
term and type instantiation) of the antecedent of an implicative theorem to the
conclusion of another theorem (the candidate antecedent).

Given a theorem-tactic {\small\verb%ttac%} and a theorem {\small\verb%th%}, the theorem-tactical
{\small\verb%IMP_RES_THEN%} produces a tactic that, when applied to a goal {\small\verb%A ?- g%} attempts
to match each antecedent {\small\verb%ui%} to each assumption {\small\verb%aj |- aj%} in the assumptions
{\small\verb%A%}.  If the antecedent {\small\verb%ui%} of any implication matches the conclusion {\small\verb%aj%} of
any assumption, then an instance of the theorem {\small\verb%Ai u {aj} |- vi%}, called a
`resolvent', is obtained by specialization of the variables {\small\verb%x1%}, ..., {\small\verb%xn%} and
type instantiation, followed by an application of modus ponens.  There may be
more than one canonical implication and each implication is tried against every
assumption of the goal, so there may be several resolvents (or, indeed, none).

Tactics are produced using the theorem-tactic {\small\verb%ttac%} from all these resolvents
(failures of {\small\verb%ttac%} at this stage are filtered out) and these tactics are then
applied in an unspecified sequence to the goal.  That is,
{\par\samepage\setseps\small
\begin{verbatim}
   IMP_RES_THEN ttac th  (A ?- g)
\end{verbatim}
}
\noindent has the effect of:
{\par\samepage\setseps\small
\begin{verbatim}
   MAP_EVERY (mapfilter ttac [... ; (Ai u {aj} |- vi) ; ...]) (A ?- g)
\end{verbatim}
}
\noindent where the theorems {\small\verb%Ai u {aj} |- vi%} are all the consequences that
can be drawn by a (single) matching modus-ponens inference from the
assumptions of the goal {\small\verb%A ?- g%} and the implications derived from the supplied
theorem {\small\verb%th%}.  The sequence in which the theorems {\small\verb%Ai u {aj} |- vi%} are
generated and the corresponding tactics applied is unspecified.

\FAILURE
Evaluating {\small\verb%IMP_RES_THEN ttac th%} fails if the supplied theorem {\small\verb%th%} is not an
implication, or if no implications can be derived from {\small\verb%th%} by the
transformation process involved. Evaluating {\small\verb%IMP_RES_THEN ttac th (A ?- g)%}
fails if no assumption of the goal {\small\verb%A ?- g%} can be resolved with the
implication or implications derived from {\small\verb%th%}. Evaluation also fails if there
are resolvents, but for every resolvent {\small\verb%Ai u {aj} |- vi%} evaluating the
application {\small\verb%ttac (Ai u {aj} |- vi)%} fails---that is, if for every resolvent
{\small\verb%ttac%} fails to produce a tactic. Finally, failure is propagated if any of the
tactics that are produced from the resolvents by {\small\verb%ttac%} fails when applied in
sequence to the goal.

\EXAMPLE
The following example shows a straightforward use of {\small\verb%IMP_RES_THEN%} to
infer an equational consequence of the assumptions of a goal, use it
once as a substitution in the conclusion of goal, and then `throw it away'.
Suppose the goal is:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a n. a + n = a ==> !k. k - n = k`;;
\end{verbatim}
}
\noindent and we start out with:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN DISCH_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`a + n = a`]

  `!k. k - n = k`
\end{verbatim}
}
\noindent By using the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # let ADD_INV_0 = ARITH_RULE `!m n. m + n = m ==> n = 0`;;
\end{verbatim}
}
\noindent the assumption of this goal implies that {\small\verb%n%} equals {\small\verb%0%}.  A
single-step resolution with this theorem followed by substitution:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(IMP_RES_THEN SUBST1_TAC ADD_INV_0);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`a + n = a`]

  `!k. k - 0 = k`
\end{verbatim}
}
\noindent Here, a single resolvent {\small\verb%a + n = a |- n = 0%} is obtained by
matching the antecedent of {\small\verb%ADD_INV_0%} to the assumption of the goal.  This is
then used to substitute {\small\verb%0%} for {\small\verb%n%} in the conclusion of the goal. The goal is
now solvable by {\small\verb%ARITH_TAC%} (as indeed was the original goal).

\SEEALSO
IMP_RES_THEN, MATCH_MP, MATCH_MP_TAC.

\ENDDOC
\DOC{IMP{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%IMP_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Performs implicational rewriting, adding new assumptions if necessary.

\DESCRIBE
Given a list of theorems {\small\verb%[th_1;...;th_k]%} of the form
{\small\verb%!x_1... x_n. P ==> !y_1... y_m. l = r%}, the tactic
{\small\verb%IMP_REWRITE_TAC [th_1;...;th_k]%} applies implicational rewriting using all
theorems, i.e. replaces any occurrence of {\small\verb%l%} by {\small\verb%r%} in the goal, even
if {\small\verb%P%} does not hold. This may involve adding some propositional atoms
(typically instantations of {\small\verb%P%}) or existentials, but in the end, you are
(almost) sure that l is replaced by r. Note that P can be ``empty'', in which
case implicational rewriting is just rewriting.

Additional remarks:
\begin{itemize}

\item A theorem of the form {\small\verb%!x_1... x_n. l = r%} is turned into
{\small\verb%!x_1... x_n. T ==> l = r%} (so that {\small\verb%IMP_REWRITE_TAC%} can be
used as a replacement for {\small\verb%REWRITE_TAC%} and {\small\verb%SIMP_TAC%}).

\item A theorem of the form {\small\verb%!x_1... x_n. P ==> !y_1... y_m. Q%}
is turned into {\small\verb%!x_1... x_n.  P ==> !y_1... y_m. Q = T%} (so that
{\small\verb%IMP_REWRITE_TAC%} can be used as a ``deep'' replacement for {\small\verb%MATCH_MP_TAC%}).

\item A theorem of the form {\small\verb%!x_1... x_n. P ==> !y_1... y_m. ~Q%}
is turned into {\small\verb%!x_1... x_n. P ==> !y_1... y_m. Q = F%}.

\item A theorem of the form
{\small\verb%!x_1... x_n. P ==> !y_1... y_k. Q ... ==> l = r%}
is turned into {\small\verb%!x_1... x_n,y_1... y_k,... P \wedge Q \wedge ... ==> l = r%}

\item A theorem of the form
{\small\verb%!x_1... x_n. P ==> (!y^1_1... y^1_k. Q_1 ... ==> l_1 = r_1 /\ !y^2_1... y^2_k. Q_2 ... ==> l_2=r_2 /\ ...)%}
is turned into the list of theorems
{\small\verb%!x_1... x_n, y^1_1... y^1_k,... P /\ Q_1 /\ ... ==> l_1 = r_1%},
{\small\verb%!x_1... x_n,y^2_1... y^2_k,... P /\ Q_2 /\ ... ==> l_2 = r_2%} etc.

\end{itemize}

\FAILURE
Fails if no rewrite can be achieved. If the usual behavior of leaving the goal unchanged
is desired, one can wrap the coal in {\small\verb%TRY_TAC%}.

\EXAMPLE
This is a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_DIV_REFL;;
  val it : thm = |- !x. ~(x = &0) ==> x / x = &1
  # g `!a b c. a < b ==> (a - b) / (a - b) * c = c`;;
  val it : goalstack = 1 subgoal (1 total)

  `!a b c. a < b ==> (a - b) / (a - b) * c = c`

  # e(IMP_REWRITE_TAC[REAL_DIV_REFL]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a b c. a < b ==> &1 * c = c / ~(a - b = &0)`
\end{verbatim}
}
We can actually do more in one step:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a b c. a < b ==> (a - b) / (a - b) * c = c`;;
  val it : goalstack = 1 subgoal (1 total)

  `!a b c. a < b ==> (a - b) / (a - b) * c = c`

  # e(IMP_REWRITE_TAC[REAL_DIV_REFL;REAL_MUL_LID;REAL_SUB_0]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a b. a < b ==> ~(a = b)`
\end{verbatim}
}
And one can easily conclude with:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(IMP_REWRITE_TAC[REAL_LT_IMP_NE]);;
  val it : goalstack = No subgoals
\end{verbatim}
}
This illustrates the use of this tactic as a replacement for {\small\verb%MATCH_MP_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a b. &0 < a - b ==> ~(b = a)`;;
  val it : goalstack = 1 subgoal (1 total)

  `!a b. &0 < a - b ==> ~(b = a)`

  # e(IMP_REWRITE_TAC[REAL_LT_IMP_NE]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a b. &0 < a - b ==> b < a`
\end{verbatim}
}
Actually the goal can be completely proved just by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(IMP_REWRITE_TAC[REAL_LT_IMP_NE;REAL_SUB_LT]);;
  val it : goalstack = No subgoals
\end{verbatim}
}
Of course on this simple example, it would actually be enough to use
{\small\verb%SIMP_TAC%}.

\USES
Allows to make some progress when {\small\verb%REWRITE_TAC%} or {\small\verb%SIMP_TAC%} cannot. Namely,
if the precondition P cannot be proved automatically, then these classic
tactics cannot be used, and one must generally add the precondition explicitly
using {\small\verb%SUBGOAL_THEN%} or {\small\verb%SUBGOAL_TAC%}. {\small\verb%IMP_REWRITE_TAC%} allows one to do this
automatically. Additionally, it can add this precondition deep in a term,
actually to the deepest where it is meaningful. Thus there is no need to first
use {\small\verb%REPEAT STRIP_TAC%} (which often forces to decompose the goal into subgoals
whereas the user would not want to do so). {\small\verb%IMP_REWRITE_TAC%} can also be used
like {\small\verb%MATCH_MP_TAC%}, but, again, deep in a term. Therefore you can avoid the
common preliminary {\small\verb%REPEAT STRIP_TAC%}. The only disadvantages w.r.t.
{\small\verb%REWRITE_TAC%}, {\small\verb%SIMP_TAC%} and {\small\verb%MATCH_MP_TAC%} are that {\small\verb%IMP_REWRITE_TAC%} uses
only first-order matching and is generally a little bit slower.

\COMMENTS
Contrarily to {\small\verb%REWRITE_TAC%} or {\small\verb%SIMP_TAC%}, the goal obtained by using
implicational rewriting is generally not equivalent to the initial goal. This
is actually what makes this tactic so useful: applying only ``reversible''
reasoning steps is quite a big restriction compared to all the reasoning steps
that could be achieved (and often wanted).

We use only first-order matching because higher-order matching happens to match
``too much''.

In situations where they can be used, {\small\verb%REWRITE_TAC%} and {\small\verb%SIMP_TAC%} are generally
more efficient.

\SEEALSO
CASE_REWRITE_TAC, REWRITE_TAC, SEQ_IMP_REWRITE_TAC, SIMP_TAC, TARGET_REWRITE_TAC.

\ENDDOC
\DOC{IMP{\_}REWR{\_}CONV}

\TYPE {\small\verb%IMP_REWR_CONV : thm -> term -> thm%}\egroup

\SYNOPSIS
Basic conditional rewriting conversion.

\DESCRIBE
Given an equational theorem {\small\verb%A |- !x1...xn. p ==> s = t%} that expresses a
conditional rewrite rule, the conversion {\small\verb%IMP_REWR_CONV%} gives a conversion
that applied to any term {\small\verb%s'%} will attempt to match the left-hand side of the
equation {\small\verb%s = t%} to {\small\verb%s'%}, and return the corresponding theorem
{\small\verb%A |- p' ==> s' = t'%}.

\FAILURE
Fails if the theorem is not of the right form or the two terms cannot be
matched, for example because the variables that need to be instantiated are
free in the hypotheses {\small\verb%A%}.

\EXAMPLE
We use the following theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # DIV_MULT;;
  val it : thm = |- !m n. ~(m = 0) ==> (m * n) DIV m = n
\end{verbatim}
}
\noindent to make a conditional rewrite:
{\par\samepage\setseps\small
\begin{verbatim}
  # IMP_REWR_CONV DIV_MULT `(2 * x) DIV 2`;;
  val it : thm = |- ~(2 = 0) ==> (2 * x) DIV 2 = x
\end{verbatim}
}

\USES
One of the building-blocks for conditional rewriting as implemented by
{\small\verb%SIMP_CONV%}, {\small\verb%SIMP_RULE%}, {\small\verb%SIMP_TAC%} etc.

\SEEALSO
ORDERED_IMP_REWR_CONV, REWR_CONV, SIMP_CONV.

\ENDDOC
\DOC{IMP{\_}TRANS}

\TYPE {\small\verb%IMP_TRANS : thm -> thm -> thm%}\egroup

\SYNOPSIS
Implements the transitivity of implication.

\DESCRIBE
When applied to theorems {\small\verb%A1 |- t1 ==> t2%} and {\small\verb%A2 |- t2 ==> t3%},
the inference rule {\small\verb%IMP_TRANS%} returns the theorem {\small\verb%A1 u A2 |- t1 ==> t3%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- t1 ==> t2   A2 |- t2 ==> t3
   -----------------------------------  IMP_TRANS
         A1 u A2 |- t1 ==> t3
\end{verbatim}
}

\FAILURE
Fails unless the theorems are both implicative, with the consequent of the
first being the same as the antecedent of the  second (up to alpha-conversion).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = TAUT `p /\ q /\ r ==> p /\ q`
    and th2 = TAUT `p /\ q ==> p`;;
  val th1 : thm = |- p /\ q /\ r ==> p /\ q
  val th2 : thm = |- p /\ q ==> p

  # IMP_TRANS th1 th2;;
  val it : thm = |- p /\ q /\ r ==> p
\end{verbatim}
}

\SEEALSO
IMP_ANTISYM_RULE, SYM, TRANS.

\ENDDOC
\DOC{increasing}

\TYPE {\small\verb%increasing : ('a -> 'b) -> 'a -> 'a -> bool%}\egroup

\SYNOPSIS
Returns a total ordering based on a measure function

\DESCRIBE
When applied to a ``measure'' function {\small\verb%f%}, the call {\small\verb%increasing f%} returns a
binary function ordering elements in a call {\small\verb%increasing f x y%} by
{\small\verb%f(x) <? f(y)%}, where the ordering {\small\verb%<?%} is the OCaml polymorphic ordering.

\FAILURE
Never fails unless the measure function does.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let nums = -5 -- 5;;
  val nums : int list = [-5; -4; -3; -2; -1; 0; 1; 2; 3; 4; 5]
  # sort (increasing abs) nums;;
  val it : int list = [0; 1; -1; 2; -2; 3; -3; 4; -4; 5; -5]
\end{verbatim}
}

\SEEALSO
<?, decreasing, sort.

\ENDDOC
\DOC{index}

\TYPE {\small\verb%index : 'a -> 'a list -> int%}\egroup

\SYNOPSIS
Returns position of given element in list.

\DESCRIBE
The call {\small\verb%index x l%} where l is a list returns the position number of the first
instance of x in the list, failing if there is none. The indices start at zero,
corresponding to {\small\verb%el%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # index "j" (explode "abcdefghijklmnopqrstuvwxyz");;
  val it : int = 9
\end{verbatim}
}
This is a sort of inverse to the indexing into a string by {\small\verb%el%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # el 9 (explode "abcdefghijklmnopqrstuvwxyz");;
  val it : string = "j"
\end{verbatim}
}

\SEEALSO
el, find, find_index.

\ENDDOC
\DOC{inductive{\_}type{\_}store}

\TYPE {\small\verb%inductive_type_store : (string * (int * thm * thm)) list ref%}\egroup

\SYNOPSIS
List of inductive types defined with corresponding theorems.

\DESCRIBE
The reference variable {\small\verb%inductive_type_store%} holds an association list that
associates with the name of each inductive type defined so far (e.g. {\small\verb%"list"%}
or {\small\verb%"1"%}) a triple: the number of constructors, the induction theorem and the
recursion theorem for it. The two theorems are exactly of the form returned by
{\small\verb%define_type%}.

\FAILURE
Not applicable.

\EXAMPLE
This example is characteristic:
{\par\samepage\setseps\small
\begin{verbatim}
  # assoc "list" (!inductive_type_store);;
  val it : int * thm * thm =
    (2, |- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x),
     |- !NIL' CONS'.
            ?fn. fn [] = NIL' /\
                 (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1)))
\end{verbatim}
}
\noindent while the following shows that there is an entry for the Boolean
type, for the sake of regularity, even though it is not normally considered an
inductive type:
{\par\samepage\setseps\small
\begin{verbatim}
  # assoc "bool" (!inductive_type_store);;
  val it : int * thm * thm =
    (2, |- !P. P F /\ P T ==> (!x. P x), |- !a b. ?f. f F = a /\ f T = b)
\end{verbatim}
}

\USES
This list is mainly for internal use. For example it is employed by {\small\verb%define%} to
automatically prove the existence of recursive functions over inductive types.
Users may find the information helpful to implement their own proof tools.
However, while the list may be inspected, it should not be modified explicitly
or there may be unwanted side-effects on {\small\verb%define%}.

\SEEALSO
define, define_type, new_recursive_definition, prove_recursive_functions_exist.

\ENDDOC
\DOC{INDUCT{\_}TAC}

\TYPE {\small\verb%INDUCT_TAC : tactic%}\egroup

\SYNOPSIS
Performs tactical proof by mathematical induction on the natural numbers.

\DESCRIBE
{\small\verb%INDUCT_TAC%} reduces a goal {\small\verb%A ?- !n. P[n]%}, where {\small\verb%n%} has type {\small\verb%num%}, to two
subgoals corresponding to the base and step cases in a proof by mathematical
induction on {\small\verb%n%}. The induction hypothesis appears among the assumptions of the
subgoal for the step case.  The specification of {\small\verb%INDUCT_TAC%} is:
{\par\samepage\setseps\small
\begin{verbatim}
                A ?- !n. P
    ========================================  INDUCT_TAC
     A ?- P[0/n]     A u {P} ?- P[SUC n'/n]
\end{verbatim}
}
\noindent where {\small\verb%n'%} is a primed variant of {\small\verb%n%} that does not appear free in
the assumptions {\small\verb%A%} (usually, {\small\verb%n'%} is just {\small\verb%n%}).

\FAILURE
{\small\verb%INDUCT_TAC g%} fails unless the conclusion of the goal {\small\verb%g%} has the form
{\small\verb%`!n. t`%}, where the variable {\small\verb%n%} has type {\small\verb%num%}.

\EXAMPLE
Suppose we want to prove the classic `sum of the first {\small\verb%n%} integers' theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!n. nsum(1..n) (\i. i) = (n * (n + 1)) DIV 2`;;
\end{verbatim}
}
\noindent This is a classic example of an inductive proof. If we apply
induction, we get two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e INDUCT_TAC;;
  val it : goalstack = 2 subgoals (2 total)

   0 [`nsum (1 .. n) (\i. i) = (n * (n + 1)) DIV 2`]

  `nsum (1 .. SUC n) (\i. i) = (SUC n * (SUC n + 1)) DIV 2`

  `nsum (1 .. 0) (\i. i) = (0 * (0 + 1)) DIV 2`
\end{verbatim}
}
\noindent each of which can be solved by just:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_REWRITE_TAC[NSUM_CLAUSES_NUMSEG] THEN ARITH_TAC);;
\end{verbatim}
}

\COMMENTS
Essentially the same effect can be had by {\small\verb%MATCH_MP_TAC num_INDUCTION%}. This
does not subsequently break down the goal in such a convenient way, but gives
more control over choice of variable. You can also equally well use it for
other kinds of induction, e.g. use {\small\verb%MATCH_MP_TAC num_WF%} for wellfounded
(complete, noetherian) induction.

\SEEALSO
LIST_INDUCT_TAC, MATCH_MP_TAC, WF_INDUCT_TAC.

\ENDDOC
\DOC{infixes}

\TYPE {\small\verb%infixes : unit -> (string * (int * string)) list%}\egroup

\SYNOPSIS
Lists the infixes currently recognized by the parser.

\DESCRIBE
The function {\small\verb%infixes%} should be applied to the unit {\small\verb%()%} and will then return
a list of all the infixes currently recognized by the parser together with
their precedence and associativity (left or right).

\FAILURE
Never fails.

\SEEALSO
get_infix_status, parse_as_infix, unparse_as_infix.

\ENDDOC
\DOC{injectivity}

\TYPE {\small\verb%injectivity : string -> thm%}\egroup

\SYNOPSIS
Produce injectivity theorem for an inductive type.

\DESCRIBE
A call {\small\verb%injectivity "ty"%} where {\small\verb%"ty"%} is the name of a recursive type defined
with {\small\verb%define_type%}, returns a ``injectivity'' theorem asserting that elements
constructed by different type constructors are always different. The effect is
exactly the same as if {\small\verb%prove_constructors_injective%} were applied to the
recursion theorem produced by {\small\verb%define_type%}, and the documentation for
{\small\verb%prove_constructors_injective%} gives a lengthier discussion.

\FAILURE
Fails if {\small\verb%ty%} is not the name of a recursive type, or if all its constructors
are nullary.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # injectivity "num";;
  val it : thm = |- !n n'. SUC n = SUC n' <=> n = n'

  # injectivity "list";;
  val it : thm =
    |- !a0 a1 a0' a1'. CONS a0 a1 = CONS a0' a1' <=> a0 = a0' /\ a1 = a1'
\end{verbatim}
}

\SEEALSO
cases, define_type, distinctness, prove_constructors_injective.

\ENDDOC
\DOC{injectivity{\_}store}

\TYPE {\small\verb%injectivity_store : (string * thm) list ref%}\egroup

\SYNOPSIS
Internal theorem list of injectivity theorems.

\DESCRIBE
This list contains all the injectivity theorems (see {\small\verb%injectivity%}) for the
recursive types defined so far. It is automatically extended by {\small\verb%define_type%}
and used as a cache by {\small\verb%injectivity%}.

\FAILURE
Not applicable.

\SEEALSO
define_type, distinctness_store, extend_rectype_net, injectivity.

\ENDDOC
\DOC{insert}

\TYPE {\small\verb%insert : 'a -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Adds element to the head of a list if not already present.

\DESCRIBE
The call {\small\verb%insert x l%} returns just {\small\verb%l%} if {\small\verb%x%} is already in the list, and
otherwise returns {\small\verb%x::l%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # insert 5 (1--10);;
  val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
  # insert 15 (1--10);;
  val it : int list = [15; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
\end{verbatim}
}

\USES
An analog to the basic list constructor {\small\verb%::%} but treating the list more like a
set.

\SEEALSO
union, intersect, subtract.

\ENDDOC
\DOC{insert'}

\TYPE {\small\verb%insert' : ('a -> 'a -> bool) -> 'a -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Insert element into list unless it contains an equivalent one already.

\DESCRIBE
If {\small\verb%r%} is a binary relation, {\small\verb%x%} an element and {\small\verb%l%} a list, the call
{\small\verb%insert' r x l%} will add {\small\verb%x%} to the head of the list, unless the list already
contains an element {\small\verb%x'%} with {\small\verb%r x x'%}; if it does, the list is returned
unchanged. The function {\small\verb%insert%} is the special case where {\small\verb%r%} is equality.

\FAILURE
Fails only if the relation fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # insert' (fun x y -> abs(x) = abs(y)) (-1) [1;2;3];;
  val it : int list = [1; 2; 3]

  # insert' (fun x y -> abs(x) = abs(y)) (-1) [2;3;4];;
  val it : int list = [-1; 2; 3; 4]
\end{verbatim}
}

\SEEALSO
insert, mem', subtract', union', unions'.

\ENDDOC
\DOC{inst}

\TYPE {\small\verb%inst : (hol_type * hol_type) list -> term -> term%}\egroup

\SYNOPSIS
Instantiate type variables in a term.

\DESCRIBE
The call {\small\verb%inst [ty1,tv1; ...; tyn,tvn] t%} will systematically replace each type
variable {\small\verb%tvi%} by the corresponding type {\small\verb%tyi%} inside the term {\small\verb%t%}. Bound
variables will be renamed if necessary to avoid capture.

\FAILURE
Never fails. Repeated type variables in the instantiation list are not
detected, and the first such element will be used.

\EXAMPLE
Here is a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # inst [`:num`,`:A`] `x:A = x`;;
  val it : term = `x = x`

  # type_of(rand it);;
  val it : hol_type = `:num`
\end{verbatim}
}
To construct an example where variable renaming is necessary we need to
construct terms with identically-named variables of different types, which
cannot be done directly in the term parser:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = mk_abs(`x:A`,`x + 1`);;
  val tm : term = `\x. x + 1`
\end{verbatim}
}
\noindent Note that the two variables {\small\verb%x%} are different; this is a constant
boolean function returning {\small\verb%x + 1%}. Now if we instantiate type variable {\small\verb%:A%} to
{\small\verb%:num%}, we still get a constant function, thanks to variable renaming:
{\par\samepage\setseps\small
\begin{verbatim}
  # inst [`:num`,`:A`] tm;;
  val it : term = `\x'. x + 1`
\end{verbatim}
}
\noindent It would have been incorrect to just keep the same name, for that
would have been the successor function, something different.

\SEEALSO
subst, type_subst, vsubst.

\ENDDOC
\DOC{installed{\_}parsers}

\TYPE {\small\verb%installed_parsers : unit -> (string * (lexcode list -> preterm * lexcode list)) list%}\egroup

\SYNOPSIS
List the user parsers currently installed.

\DESCRIBE
HOL Light allows user parsing functions to be installed, and will try them on
all terms during parsing before the usual parsers. The call
{\small\verb%installed_parsers()%} lists the parsing functions that have been so installed.

\FAILURE
Never fails.

\SEEALSO
delete_parser, install_parser, try_user_parser.

\ENDDOC
\DOC{install{\_}parser}

\TYPE {\small\verb%install_parser : string * (lexcode list -> preterm * lexcode list) -> unit%}\egroup

\SYNOPSIS
Install a user parser.

\DESCRIBE
HOL Light allows user parsing functions to be installed, and will try them on
all terms during parsing before the usual parsers. The call
{\small\verb%install_parser(s,p)%} installs the parser {\small\verb%p%} among the user parsers to try in
this way. The string {\small\verb%s%} is there so that the parser can conveniently be
deleted again.

\FAILURE
Never fails.

\SEEALSO
delete_parser, installed_parsers, try_user_parser.

\ENDDOC
\DOC{install{\_}user{\_}color{\_}printer}

\TYPE {\small\verb%install_user_color_printer : string * (formater -> term -> unit) -> unit%}\egroup

\SYNOPSIS
Install a user-defined color printing function into the HOL Light term printer.

\DESCRIBE
The call {\small\verb%install_user_color_printer(s,pr)%} sets up {\small\verb%pr%} inside the HOL Light
toplevel printer. When a term is to be color-printed, on each subterm encountered,
{\small\verb%pr%} will be tried first.
if it fails with {\small\verb%Failure ...%}, HOL Light will try its non-coloring user printer
registered with {\small\verb%install_user_printer%}.
If it fails again with {\small\verb%Failure ...%} will the normal HOL Light printing be
invoked. The additional string argument {\small\verb%s%} is just to provide a convenient
handle for later removal through {\small\verb%delete_user_color_printer%}. However, any previous
user printer with the same string tag will be removed when
{\small\verb%install_user_color_printer%} is called. The printing function takes two arguments,
the second being the term to print and the first being the formatter to be
used; this ensures that the printer will automatically have its output sent to
the current formatter by the overall printer.

\FAILURE
Never fails.

\EXAMPLE
Analogous to the example of {\small\verb%install_user_printer%}.

\SEEALSO
delete_user_color_printer, delete_user_printer, install_user_printer,
try_user_color_printer, try_user_printer.

\ENDDOC
\DOC{install{\_}user{\_}printer}

\TYPE {\small\verb%install_user_printer : string * (formater -> term -> unit) -> unit%}\egroup

\SYNOPSIS
Install a user-defined printing function into the HOL Light term printer.

\DESCRIBE
The call {\small\verb%install_user_printer(s,pr)%} sets up {\small\verb%pr%} inside the HOL Light
toplevel printer. On each subterm encountered, {\small\verb%pr%} will be tried first, and
only if it fails with {\small\verb%Failure ...%} will the normal HOL Light printing be
invoked. The additional string argument {\small\verb%s%} is just to provide a convenient
handle for later removal through {\small\verb%delete_user_printer%}. However, any previous
user printer with the same string tag will be removed when
{\small\verb%install_user_printer%} is called. The printing function takes two arguments,
the second being the term to print and the first being the formatter to be
used; this ensures that the printer will automatically have its output sent to
the current formatter by the overall printer.

\FAILURE
Never fails.

\EXAMPLE
The user might wish to print every variable with its type:
{\par\samepage\setseps\small
\begin{verbatim}
  # let print_typed_var fmt tm =
      let s,ty = dest_var tm in
      pp_print_string fmt ("("^s^":"^string_of_type ty^")") in
    install_user_printer("print_typed_var",print_typed_var);;

  val it : unit = ()
  # ADD_ASSOC;;
  val it : thm =
    |- !(m:num) (n:num) (p:num).
           (m:num) + (n:num) + (p:num) = ((m:num) + (n:num)) + (p:num)
\end{verbatim}
}

\USES
Modification of printing in this way is particularly useful when the HOL logic
is used to embed some other formalism such as a programming language, hardware
description language or other logic. This can then be printed in a ``native''
fashion without any artifacts of its HOL formalization.

\COMMENTS
Since user printing functions are tried on every subterm encountered in the
regular printing function, it is important that they fail quickly when
inapplicable, or the printing process can be slowed. They should also not
generate exceptions other than {\small\verb%Failure ...%} or the toplevel printer will start
to fail.

\SEEALSO
delete_user_color_printer, delete_user_printer, install_user_color_printer,
try_user_color_printer, try_user_printer.

\ENDDOC
\DOC{instantiate}

\TYPE {\small\verb%instantiate : instantiation -> term -> term%}\egroup

\SYNOPSIS
Apply a higher-order instantiation to a term.

\DESCRIBE
The call {\small\verb%instantiate i t%}, where {\small\verb%i%} is an instantiation as returned by
{\small\verb%term_match%}, will perform the instantiation indicated by {\small\verb%i%} in the term {\small\verb%t%}:
types and terms will be instantiated and the beta-reductions that are part of
higher-order matching will be applied.

\FAILURE
Should never fail on a valid instantiation.

\EXAMPLE
We first compute an instantiation:
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = `(!x. P x) <=> ~(?x. P x)`;;
  Warning: inventing type variables
  val t : term = `(!x. P x) <=> ~(?x. P x)`

  # let i = term_match [] (lhs t) `!p. prime(p) ==> p = 2 \/ ODD(p)`;;
  val i : instantiation =
    ([(1, `P`)], [(`\p. prime p ==> p = 2 \/ ODD p`, `P`)],
     [(`:num`, `:?61195`)])
\end{verbatim}
}
\noindent and now apply it. Notice that the type variable name is not
corrected, as is done inside {\small\verb%PART_MATCH%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # instantiate i t;;
  val it : term =
    `(!x. prime x ==> x = 2 \/ ODD x) <=> ~(?x. prime x ==> x = 2 \/ ODD x)`
\end{verbatim}
}

\COMMENTS
This is probably not useful for most users.

\SEEALSO
compose_insts, INSTANTIATE, INSTANTIATE_ALL, inst_goal, PART_MATCH, term_match.

\ENDDOC
\DOC{INSTANTIATE{\_}ALL}

\TYPE {\small\verb%INSTANTIATE_ALL : instantiation -> thm -> thm%}\egroup

\SYNOPSIS
Apply a higher-order instantiation to assumptions and conclusion of a theorem.

\DESCRIBE
The call {\small\verb%INSTANTIATE_ALL i t%}, where {\small\verb%i%} is an instantiation as returned by
{\small\verb%term_match%}, will perform the instantiation indicated by {\small\verb%i%} in the conclusion
of the theorem {\small\verb%th%}: types and terms will be instantiated and the
beta-reductions that are part of higher-order matching will be applied.

\FAILURE
Never fails on a valid instantiation.

\COMMENTS
This is not intended for general use. {\small\verb%PART_MATCH%} is generally a more
convenient packaging. The function {\small\verb%INSTANTIATE%} is almost the same but does
not instantiate hypotheses and may fail if type variables or term variables
free in the hypotheses make the instantiation impossible.

\SEEALSO
INSTANTIATE, INSTANTIATE_ALL, PART_MATCH, term_match.

\ENDDOC
\DOC{instantiate{\_}casewise{\_}recursion}

\TYPE {\small\verb%instantiate_casewise_recursion : term -> thm%}\egroup

\SYNOPSIS
Instantiate the general scheme for a recursive function existence assertion.

\DESCRIBE
The function {\small\verb%instantiate_casewise_recursion%} should be applied to an
existentially quantified term {\small\verb%`?f. def_1[f] /\ ... /\ def_n[f]`%},
where each clause {\small\verb%def_i%} is a universally quantified equation with an
application of {\small\verb%f%} to arguments on the left-hand side. The idea is that these
clauses define the action of {\small\verb%f%} on arguments of various kinds, for example on
an empty list and nonempty list:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (f [] = a) /\ (!h t. CONS h t = k[f,h,t])
\end{verbatim}
}
\noindent or on even numbers and odd numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (!n. f(2 * n) = a[f,n]) /\ (!n. f(2 * n + 1) = b[f,n])
\end{verbatim}
}
The returned value is a theorem whose conclusion matches the input term, with
an assumption sufficient for the existence assertion. This is not normally in a
very convenient form for the user.

\FAILURE
Fails only if the definition is malformed. However it is possible that for an
inadmissible definition the assumption of the theorem may not hold.

\USES
This is seldom a convenient function for users. Normally, use
{\small\verb%prove_general_recursive_function_exists%} to prove something like this while
attempting to discharge the side-conditions automatically, or {\small\verb%define%} to
actually make a definition. In situations where the automatic discharge of the
side-conditions fails, one may prefer instead
{\small\verb%pure_prove_recursive_function_exists%}. The even more minimal
{\small\verb%instantiate_casewise_recursion%} is for the rare cases where one wants to force
no processing at all of the side-conditions to be undertaken.

\SEEALSO
define, prove_general_recursive_function_exists,
pure_prove_recursive_function_exists.

\ENDDOC
\DOC{INSTANTIATE}

\TYPE {\small\verb%INSTANTIATE : instantiation -> thm -> thm%}\egroup

\SYNOPSIS
Apply a higher-order instantiation to conclusion of a theorem.

\DESCRIBE
The call {\small\verb%INSTANTIATE i t%}, where {\small\verb%i%} is an instantiation as returned by
{\small\verb%term_match%}, will perform the instantiation indicated by {\small\verb%i%} in the conclusion
of the theorem {\small\verb%th%}: types and terms will be instantiated and the
beta-reductions that are part of higher-order matching will be applied.

\FAILURE
Fails if the instantiation is impossible because of free term or type variables
in the hypotheses.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = lhs(concl(SPEC_ALL NOT_FORALL_THM));;
  val t : term = `~(!x. P x)`
  # let i = term_match [] t `~(!n. prime(n) ==> ODD(n))`;;
  val i : instantiation =
    ([(1, `P`)], [(`\n. prime n ==> ODD n`, `P`)], [(`:num`, `:A`)])

  # INSTANTIATE i (SPEC_ALL NOT_FORALL_THM);;
  val it : thm = |- ~(!x. prime x ==> ODD x) <=> (?x. ~(prime x ==> ODD x))
\end{verbatim}
}

\COMMENTS
This is not intended for general use. {\small\verb%PART_MATCH%} is generally a more
convenient packaging.

\SEEALSO
instantiate, INSTANTIATE_ALL, PART_MATCH, term_match.

\ENDDOC
\DOC{inst{\_}goal}

\TYPE {\small\verb%inst_goal : instantiation -> goal -> goal%}\egroup

\SYNOPSIS
Apply higher-order instantiation to a goal.

\DESCRIBE
The call {\small\verb%inst_goal i g%} where {\small\verb%i%} is an instantiation (as returned by
{\small\verb%term_match%} for example), will perform the instantiation indicated by {\small\verb%i%} in
both assumptions and conclusion of the goal {\small\verb%g%}.

\FAILURE
Should never fail on a valid instantiation.

\COMMENTS
Probably only of specialist interest to those writing tactics from scratch.

\SEEALSO
compose_insts, instantiate, INSTANTIATE, INSTANTIATE_ALL,
PART_MATCH, term_match.

\ENDDOC
\DOC{INST{\_}TYPE}

\TYPE {\small\verb%INST_TYPE : (hol_type * hol_type) list -> thm -> thm%}\egroup

\SYNOPSIS
Instantiates types in a theorem.

\DESCRIBE
{\small\verb%INST_TYPE [ty1,tv1;...;tyn,tvn]%} will systematically replaces all instances of
each type variable {\small\verb%tvi%} by the corresponding type {\small\verb%tyi%} in both assumptions
and conclusions of a theorem:
{\par\samepage\setseps\small
\begin{verbatim}
               A |- t
   -----------------------------------  INST_TYPE [ty1,tv1;...;tyn,tvn]
    A[ty1,...,tyn/tv1,...,tvn]
        |- t[ty1,...,tyn/tv1,...,tvn]
\end{verbatim}
}
Variables will be renamed if necessary to prevent variable capture.

\FAILURE
Never fails.

\USES
{\small\verb%INST_TYPE%} is employed to make use of polymorphic theorems.

\EXAMPLE
Suppose one wanted to specialize the theorem {\small\verb%EQ_SYM_EQ%} for
particular values, the first attempt could be to use {\small\verb%SPECL%} as
follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # SPECL [`a:num`; `b:num`] EQ_SYM_EQ ;;
  Exception: Failure "SPECL".
\end{verbatim}
}
\noindent The failure occurred because {\small\verb%EQ_SYM_EQ%} contains polymorphic types.
The desired specialization can be obtained by using {\small\verb%INST_TYPE%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # SPECL [`a:num`; `b:num`] (INST_TYPE [`:num`,`:A`] EQ_SYM_EQ) ;;
  val it : thm = |- a = b <=> b = a
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
INST, ISPEC, ISPECL.

\ENDDOC
\DOC{INST}

\TYPE {\small\verb%INST : (term * term) list -> thm -> thm%}\egroup

\SYNOPSIS
Instantiates free variables in a theorem.

\DESCRIBE
When {\small\verb%INST [t1,x1; ...; tn,xn]%} is applied to a theorem, it gives a new
theorem that systematically replaces free instances of each variable {\small\verb%xi%} with
the corresponding term {\small\verb%ti%} in both assumptions and conclusion.
{\par\samepage\setseps\small
\begin{verbatim}
               A |- t
   -----------------------------------  INST [t1,x1;...;tn,xn]
    A[t1,...,tn/x1,...,xn]
        |- t[t1,...,tn/x1,...,xn]
\end{verbatim}
}
Bound variables will be renamed if necessary to avoid capture. All variables
are substituted in parallel, so there is no problem if there is an overlap
between the terms {\small\verb%ti%} and {\small\verb%xi%}.

\FAILURE
Fails if any of the pairs {\small\verb%ti,xi%} in the instantiation list has {\small\verb%xi%} and {\small\verb%ti%}
with different types, or {\small\verb%xi%} a non-variable. Multiple instances of the same
{\small\verb%xi%} in the list are not trapped, but only the first one will be used
consistently.

\EXAMPLE
Here is a simple example
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC_ALL ADD_SYM;;
  val th : thm = |- m + n = n + m
  # INST [`1`,`m:num`; `x:num`,`n:num`] th;;
  val it : thm = |- 1 + x = x + 1
\end{verbatim}
}
\noindent and here is one where bound variable renaming is needed.
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SPEC_ALL LE_EXISTS;;
  val th : thm = |- m <= n <=> (?d. n = m + d)
  # INST [`d:num`,`m:num`] th;;
  val it : thm = |- d <= n <=> (?d'. n = d + d')
\end{verbatim}
}

\USES
This is the most efficient way to obtain instances of a theorem; though
sometimes more convenient, {\small\verb%SPEC%} and {\small\verb%SPECL%} are significantly slower.

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
INST_TYPE, ISPEC, ISPECL, SPEC, SPECL.

\ENDDOC
\DOC{INTEGER{\_}RULE}

\TYPE {\small\verb%INTEGER_RULE : term -> thm%}\egroup

\SYNOPSIS
Automatically prove elementary divisibility property over the integers.

\DESCRIBE
{\small\verb%INTEGER_RULE%} is a partly heuristic rule that can often
automatically prove elementary ``divisibility'' properties of the integers. The
precise subset that is dealt with is difficult to describe rigorously, but many
universally quantified combinations of {\small\verb%divides%}, {\small\verb%coprime%}, {\small\verb%gcd%} and
congruences {\small\verb%(x == y) (mod n)%} can be proved automatically, as well as some
existentially quantified goals. The examples below may give a feel for what can
be done.

\FAILURE
Fails if the goal is not accessible to the methods used.

\EXAMPLE
All sorts of elementary Boolean combinations of divisibility and congruence
properties can be solved, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # INTEGER_RULE
     `!x y n:int. (x == y) (mod n) ==> (n divides x <=> n divides y)`;;
  ...
  val it : thm = |- !x y n. (x == y) (mod n) ==> (n divides x <=> n divides y)

  # INTEGER_RULE
     `!a b d:int. d divides gcd(a,b) <=> d divides a /\ d divides b`;;
  ...
  val it : thm =
   |- !a b d. d divides gcd (a,b) <=> d divides a /\ d divides b
\end{verbatim}
}
\noindent including some less obvious ones:
{\par\samepage\setseps\small
\begin{verbatim}
  # INTEGER_RULE
     `!x y. coprime(x * y,x pow 2 + y pow 2) <=> coprime(x,y)`;;
  ...
  val it : thm = |- !x y. coprime (x * y,x pow 2 + y pow 2) <=> coprime (x,y)
\end{verbatim}
}
\noindent A limited class of existential goals is solvable too, e.g. a classic
sufficient condition for a linear congruence to have a solution:
{\par\samepage\setseps\small
\begin{verbatim}
  # INTEGER_RULE `!a b n:int. coprime(a,n) ==> ?x. (a * x == b) (mod n)`;;
  ...
  val it : thm = |- !a b n. coprime (a,n) ==> (?x. (a * x == b) (mod n))
\end{verbatim}
}
\noindent or the two-number Chinese Remainder Theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # INTEGER_RULE
    `!a b u v:int. coprime(a,b) ==> ?x. (x == u) (mod a) /\ (x == v) (mod b)`;;
  ...
  val it : thm =
  |- !a b u v. coprime (a,b) ==> (?x. (x == u) (mod a) /\ (x == v) (mod b))
\end{verbatim}
}

\SEEALSO
ARITH_RULE, INTEGER_TAC, INT_ARITH, INT_RING, NUMBER_RULE.

\ENDDOC
\DOC{INTEGER{\_}TAC}

\TYPE {\small\verb%INTEGER_TAC : tactic%}\egroup

\SYNOPSIS
Automated tactic for elementary divisibility properties over the integers.

\DESCRIBE
The tactic {\small\verb%INTEGER_TAC%} is a partly heuristic tactic that can often
automatically prove elementary ``divisibility'' properties of the integers. The
precise subset that is dealt with is difficult to describe rigorously, but many
universally quantified combinations of {\small\verb%divides%}, {\small\verb%coprime%}, {\small\verb%gcd%} and
congruences {\small\verb%(x == y) (mod n)%} can be proved automatically, as well as some
existentially quantified goals. See the documentation for {\small\verb%INTEGER_RULE%} for a
larger set of representative examples.

\FAILURE
Fails if the goal is not accessible to the methods used.

\EXAMPLE
A typical elementary divisibility property is that if two linear congruences
have a common solution modulo {\small\verb%n%}, then {\small\verb%n%} divides the resultant of the two
equations. If we set this as our goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!c2 c1 c0 n x:int.
        (c0 * x == c1) (mod n) /\ (c1 * x == c2) (mod n)
        ==> n divides (c1 * c1 - c0 * c2)`;;
\end{verbatim}
}
\noindent It can be solved automatically using {\small\verb%INTEGER_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e INTEGER_TAC;;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
INTEGER_RULE, INT_ARITH_TAC, INT_RING, NUMBER_RULE.

\ENDDOC
\DOC{intersect}

\TYPE {\small\verb%intersect : 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Computes the intersection of two `sets'.

\DESCRIBE
{\small\verb%intersect l1 l2%} returns a list consisting of those elements of {\small\verb%l1%} that
also appear in {\small\verb%l2%}. If both sets are free of repetitions, this can be
considered a set-theoretic intersection operation.

\FAILURE
Never fails.

\COMMENTS
Duplicate elements in the first list will still be present in the result.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # intersect [1;2;3] [3;5;4;1];;
  val it : int list = [1; 3]
  # intersect [1;2;4;1] [1;2;3;2];;
  val it : int list = [1; 2; 1]
\end{verbatim}
}
\SEEALSO
setify, set_equal, union, subtract.

\ENDDOC
\DOC{INTRO{\_}TAC}

\TYPE {\small\verb%INTRO_TAC : string -> tactic%}\egroup

\SYNOPSIS
Breaks down outer quantifiers in goal, introducing variables and named
hypotheses.

\DESCRIBE
Given a string {\small\verb%s%}, {\small\verb%INTRO_TAC s%} breaks down outer universal quantifiers and
implications in the goal, fixing variables and introducing assumptions with
names. It combines several forms of introduction of logical connectives. The
introduction pattern uses the following syntax:

\begin{itemize}

\item {\small\verb%! fix_pattern%} introduces universally quantified variables as with
   {\small\verb%FIX_TAC%}

\item a destruct pattern introduces and destructs an implication as with
   {\small\verb%DESTRUCT_TAC%}

\item {\small\verb%#n%} selects disjunct {\small\verb%n%} in the goal

\end{itemize}

Several fix patterns and destruct patterns can be combined sequentially,
separed by semicolons `;'.

\FAILURE
Fails if the pattern is ill-formed or does not match the form of the goal.

\EXAMPLE
Here we introduce the universally quantified outer variables, assume the
antecedent, splitting apart conjunctions and disjunctions:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!p q r. p \/ (q /\ r) ==> p /\ q \/ p /\ r`;;
  # e (INTRO_TAC "!p q r; p | q r");;
  val it : goalstack = 2 subgoals (2 total)

    0 [`q`] (q)
    1 [`r`] (r)

  `p /\ q \/ p /\ r`

    0 [`p`] (p)

  `p /\ q \/ p /\ r`
\end{verbatim}
}
Now a further step will select the first disjunct to prove in the top goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e (INTRO_TAC "#1");;
  val it : goalstack = 1 subgoal (2 total)

    0 [`p`] (p)

  `p /\ q`
\end{verbatim}
}

In the next example we introduce an alternation of universally quantified
variables and antecedents.  Along the way we split a disjunction and rename
variables x1, x2 into n, n'.  All is done in a single tactic invocation.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a. ~(a = 0) ==> ONE_ONE (\n. a * n)`;;
  # e (REWRITE_TAC[ONE_ONE; EQ_MULT_LCANCEL]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a. ~(a = 0) ==> (!x1 x2. a = 0 \/ x1 = x2 ==> x1 = x2)`

  # e (INTRO_TAC "!a; anz; ![n] [n']; az | eq");;
  val it : goalstack = 2 subgoals (2 total)

    0 [`~(a = 0)`] (anz)
    1 [`n = n'`] (eq)

  `n = n'`

    0 [`~(a = 0)`] (anz)
    1 [`a = 0`] (az)

  `n = n'`
\end{verbatim}
}

\SEEALSO
DESTRUCT_TAC, DISCH_TAC, FIX_TAC, GEN_TAC, LABEL_TAC, REMOVE_THEN,
STRIP_TAC, USE_THEN.

\ENDDOC
\DOC{INT{\_}ABS{\_}CONV}

\TYPE {\small\verb%INT_ABS_CONV : conv%}\egroup

\SYNOPSIS
Conversion to produce absolute value of an integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_ABS_CONV `abs c`%}, where {\small\verb%c%} is an integer literal of type
{\small\verb%:int%}, returns the theorem {\small\verb%|- abs c = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c%}'s absolute value. The literal {\small\verb%c%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of integer literal of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_ABS_CONV `abs(-- &42)`;;
  val it : thm = |- abs (-- &42) = &42
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_ABS_CONV.

\ENDDOC
\DOC{INT{\_}ADD{\_}CONV}

\TYPE {\small\verb%INT_ADD_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two integer literals of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_ADD_CONV `c1 + c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:int%}, returns {\small\verb%|- c1 + c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 + c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the sum of two permitted integer
literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_ADD_CONV `-- &17 + &25`;;
  val it : thm = |- -- &17 + &25 = &8
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_ADD_CONV.

\ENDDOC
\DOC{INT{\_}ARITH}

\TYPE {\small\verb%INT_ARITH : term -> thm%}\egroup

\SYNOPSIS
Proves integer theorems needing basic rearrangement and linear inequality
reasoning only.

\DESCRIBE
{\small\verb%INT_ARITH%} is a rule for automatically proving natural number theorems using
basic algebraic normalization and inequality reasoning.

\FAILURE
Fails if the term is not boolean or if it cannot be proved using the basic
methods employed, e.g. requiring nonlinear inequality reasoning.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_ARITH `!x y:int. x <= y + &1 ==> x + &2 < y + &4`;;
  val it : thm = |- !x y. x <= y + &1 ==> x + &2 < y + &4

  # INT_ARITH `(x + y:int) pow 2 = x pow 2 + &2 * x * y + y pow 2`;;
  val it : thm = |- (x + y) pow 2 = x pow 2 + &2 * x * y + y pow 2
\end{verbatim}
}

\USES
Disposing of elementary arithmetic goals.

\SEEALSO
ARITH_RULE, INT_ARITH_TAC, NUM_RING, REAL_ARITH, REAL_FIELD, REAL_RING.

\ENDDOC
\DOC{INT{\_}ARITH{\_}TAC}

\TYPE {\small\verb%INT_ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Attempt to prove goal using basic algebra and linear arithmetic over the
integers.

\DESCRIBE
The tactic {\small\verb%INT_ARITH_TAC%} is the tactic form of {\small\verb%INT_ARITH%}. Roughly
speaking, it will automatically prove any formulas over the reals that are
effectively universally quantified and can be proved valid by algebraic
normalization and linear equational and inequality reasoning. See {\small\verb%REAL_ARITH%}
for more information about the algorithm used and its scope.

\FAILURE
Fails if the goal is not in the subset solvable by these means, or is not
valid.

\EXAMPLE
Here is a goal that holds by virtue of pure algebraic normalization:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_int();;
  val it : unit = ()

  # g `(x1 pow 2 + x2 pow 2 + x3 pow 2 + x4 pow 2) *
       (y1 pow 2 + y2 pow 2 + y3 pow 2 + y4 pow 2) =
       (x1 * y1 - x2 * y2 - x3 * y3 - x4 * y4) pow 2  +
       (x1 * y2 + x2 * y1 + x3 * y4 - x4 * y3) pow 2  +
       (x1 * y3 - x2 * y4 + x3 * y1 + x4 * y2) pow 2  +
       (x1 * y4 + x2 * y3 - x3 * y2 + x4 * y1) pow 2`;;
\end{verbatim}
}
\noindent and here is one that holds by linear inequality reasoning:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x y:int. abs(x + y) < abs(x) + abs(y) + &1`;;
\end{verbatim}
}
\noindent so either goal is solved simply by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e INT_ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ARITH_TAC, ASM_INT_ARITH_TAC, INT_ARITH, REAL_ARITH_TAC.

\ENDDOC
\DOC{INT{\_}EQ{\_}CONV}

\TYPE {\small\verb%INT_EQ_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:int%} is equal to
another.

\DESCRIBE
The call {\small\verb%INT_EQ_CONV `c1 < c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:int%}, returns whichever of {\small\verb%|- c1 = c2 <=> T%} or
{\small\verb%|- c1 = c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not an equality comparison on two permitted
integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_EQ_CONV `&1 = &2`;;
  val it : thm = |- &1 = &2 <=> F

  # INT_EQ_CONV `-- &1 = -- &1`;;
  val it : thm = |- -- &1 = -- &1 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_EQ_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_EQ_CONV.

\ENDDOC
\DOC{INT{\_}GE{\_}CONV}

\TYPE {\small\verb%INT_GE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:int%} is {\small\verb%>=%}
another.

\DESCRIBE
The call {\small\verb%INT_GE_CONV `c1 >= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:int%}, returns whichever of {\small\verb%|- c1 >= c2 <=> T%} or
{\small\verb%|- c1 >= c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_GE_CONV `&7 >= &6`;;
  val it : thm = |- &7 >= &6 <=> T
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_GE_CONV.

\ENDDOC
\DOC{INT{\_}GT{\_}CONV}

\TYPE {\small\verb%INT_GT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:int%} is {\small\verb%<%}
another.

\DESCRIBE
The call {\small\verb%INT_GT_CONV `c1 > c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:int%}, returns whichever of {\small\verb%|- c1 > c2 <=> T%} or
{\small\verb%|- c1 > c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_GT_CONV `&1 > &2`;;
  val it : thm = |- &1 > &2 <=> F
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_GT_CONV.

\ENDDOC
\DOC{int{\_}ideal{\_}cofactors}

\TYPE {\small\verb%int_ideal_cofactors : term list -> term -> term list%}\egroup

\SYNOPSIS
Produces cofactors proving that one integer polynomial is in the ideal
generated by others.

\DESCRIBE
The call {\small\verb%int_ideal_cofactors [`p1`; ...; `pn`] `p`%}, where all the terms have
type {\small\verb%:int%} and can be considered as polynomials, will test whether {\small\verb%p%} is in
the ideal generated by the {\small\verb%p1,...,pn%}. If so, it will return a corresponding
list {\small\verb%[`q1`; ...; `qn`]%} of `cofactors' such that the following is an algebraic
identity provable by {\small\verb%INT_RING%} or a slight elaboration of {\small\verb%INT_POLY_CONV%}, for
example)
{\par\samepage\setseps\small
\begin{verbatim}
  p = p1 * q1 + ... + pn * qn
\end{verbatim}
}
\noindent hence providing an explicit certificate for the ideal membership. If
ideal membership does not hold, {\small\verb%int_ideal_cofactors%} fails. The test is
performed using a Gr\"obner basis procedure.

\FAILURE
Fails if the terms are ill-typed, or if ideal membership fails. At present this
is a generic version for fields, and in rare cases it may fail because
cofactors are found involving non-trivial rational numbers even where there are
integer cofactors. This imperfection should be fixed eventually, and is not
usually a problem in practice.

\EXAMPLE
In the case of a singleton list, ideal membership just amounts to polynomial
divisibility, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_int();;
  val it : unit = ()

  # int_ideal_cofactors
     [`r * x * (&1 - x) - x`]
     `r * (r * x * (&1 - x)) * (&1 - r * x * (&1 - x)) - x`;;
  [`&1 * r pow 2 * x pow 2 +
    -- &1 * r pow 2 * x +
    -- &1 * r * x +
    &1 * r +
    &1`]
\end{verbatim}
}

\COMMENTS
When we say that terms can be `considered as polynomials', we mean that initial
normalization, essentially in the style of {\small\verb%INT_POLY_CONV%}, will be applied,
but some complex constructs such as conditional expressions will be treated as
atomic.

\SEEALSO
ideal_cofactors, INT_IDEAL_CONV, INT_RING, real_ideal_cofactors, RING,
RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{INT{\_}LE{\_}CONV}

\TYPE {\small\verb%INT_LE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:int%} is {\small\verb%<=%}
another.

\DESCRIBE
The call {\small\verb%INT_LE_CONV `c1 <= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:int%}, returns whichever of {\small\verb%|- c1 <= c2 <=> T%} or
{\small\verb%|- c1 <= c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_LE_CONV `&11 <= &77`;;
  val it : thm = |- &11 <= &77 <=> T
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_LE_CONV.

\ENDDOC
\DOC{INT{\_}LT{\_}CONV}

\TYPE {\small\verb%INT_LT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:int%} is {\small\verb%<%}
another.

\DESCRIBE
The call {\small\verb%INT_LT_CONV `c1 < c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:int%}, returns whichever of {\small\verb%|- c1 < c2 <=> T%} or
{\small\verb%|- c1 < c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_LT_CONV `-- &18 < &64`;;
  val it : thm = |- -- &18 < &64 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_LT_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_LT_CONV.

\ENDDOC
\DOC{INT{\_}MAX{\_}CONV}

\TYPE {\small\verb%INT_MAX_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two integer literals of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_MAX_CONV `max c1 c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:int%}, returns {\small\verb%|- max c1 c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%max c1 c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the maximum operator applied to two
permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_MAX_CONV `max (-- &1) (&2)`;;
  val it : thm = |- max (-- &1) (&2) = &2
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{INT{\_}MIN{\_}CONV}

\TYPE {\small\verb%INT_MIN_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two integer literals of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_MIN_CONV `min c1 c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:int%}, returns {\small\verb%|- min c1 c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%min c1 c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the minimum operator applied to two
permitted integer literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_MIN_CONV `min (-- &1) (&2)`;;
  val it : thm = |- min (-- &1) (&2) = &2
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{INT{\_}MUL{\_}CONV}

\TYPE {\small\verb%INT_MUL_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform multiplication on two integer literals of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_MUL_CONV `c1 * c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:int%}, returns {\small\verb%|- c1 * c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 * c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the product of two permitted integer
literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_MUL_CONV `&6 * -- &9`;;
  val it : thm = |- &6 * -- &9 = -- &54
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_MUL_CONV.

\ENDDOC
\DOC{INT{\_}NEG{\_}CONV}

\TYPE {\small\verb%INT_NEG_CONV : conv%}\egroup

\SYNOPSIS
Conversion to negate an integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_NEG_CONV `--c`%}, where {\small\verb%c%} is an integer literal of type
{\small\verb%:int%}, returns the theorem {\small\verb%|- --c = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c%}'s negation. The literal {\small\verb%c%} may be of the form
{\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will be of
the same form.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of integer literal of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_NEG_CONV `-- (-- &3 / &2)`;;
  val it : thm = |- --(-- &3 / &2) = &3 / &2
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_NEG_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_NEG_CONV.

\ENDDOC
\DOC{INT{\_}OF{\_}REAL{\_}THM}

\TYPE {\small\verb%INT_OF_REAL_THM : thm -> thm%}\egroup

\SYNOPSIS
Map a universally quantified theorem from reals to integers.

\DESCRIBE
We often regard integers as a subset of the reals, so any universally
quantified theorem over the reals also holds for the integers, and indeed any
other subset. In HOL, integers and reals are completely separate types ({\small\verb%int%}
and {\small\verb%real%} respectively). However, there is a natural injection (actually
called {\small\verb%dest_int%}) from integers to reals that maps integer operations to their
real counterparts, and using this we can similarly show that any universally
quantified formula over the reals also holds over the integers with operations
mapped to the right type. The rule {\small\verb%INT_OF_REAL_THM%} embodies this procedure;
given a universally quantified theorem over the reals, it maps it to a
corresponding theorem over the integers.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_ABS_TRIANGLE;;
  val it : thm = |- !x y. abs (x + y) <= abs x + abs y
  # map dest_var (variables(concl it));;
  val it : (string * hol_type) list = [("y", `:real`); ("x", `:real`)]

  # INT_OF_REAL_THM REAL_ABS_TRIANGLE;;
  val it : thm = |- !x y. abs (x + y) <= abs x + abs y
  # map dest_var (variables(concl it));;
  val it : (string * hol_type) list = [("y", `:int`); ("x", `:int`)]
\end{verbatim}
}

\SEEALSO
ARITH_RULE, INT_ARITH, INT_ARITH_TAC, NUM_TO_INT_CONV,
REAL_ARITH.

\ENDDOC
\DOC{INT{\_}POLY{\_}CONV}

\TYPE {\small\verb%INT_POLY_CONV : term -> thm%}\egroup

\SYNOPSIS
Converts a integer polynomial into canonical form.

\DESCRIBE
Given a term of type {\small\verb%:int%} that is built up using addition, subtraction,
negation and multiplication, {\small\verb%INT_POLY_CONV%} converts it into a canonical
polynomial form and returns a theorem asserting the equivalence of the original
and canonical terms. The basic elements need not simply be variables or
constants; anything not built up using the operators given above will be
considered `atomic' for the purposes of this conversion. The canonical
polynomial form is a `multiplied out' sum of products, with the monomials
(product terms) ordered according to the canonical OCaml order on terms. In
particular, it is just {\small\verb%&0%} if the polynomial is identically zero.

\FAILURE
Never fails, even if the term has the wrong type; in this case it merely
returns a reflexive theorem.

\EXAMPLE
This illustrates how terms are `multiplied out':
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_POLY_CONV `(x + y) pow 3`;;
  val it : thm =
    |- (x + y) pow 3 = x pow 3 + &3 * x pow 2 * y + &3 * x * y pow 2 + y pow 3
\end{verbatim}
}
\noindent while the following verifies a remarkable `sum of cubes' identity due
to Yasutoshi Kohmoto:
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_POLY_CONV
     `(&1679616 * a pow 16 - &66096 * a pow 10 * b pow 6 +
       &153 * a pow 4 * b pow 12) pow 3 +
      (-- &1679616 * a pow 16 - &559872 * a pow 13 * b pow 3 -
       &27216 * a pow 10 * b pow 6 + &3888 * a pow 7 * b pow 9 +
       &63 * a pow 4 * b pow 12 - &3 * a * b pow 15) pow 3 +
      (&1679616 * a pow 15 * b + &279936 * a pow 12 * b pow 4 -
       &11664 * a pow 9 * b pow 7 -
       &648 * a pow 6 * b pow 10 + &9 * a pow 3 * b pow 13 + b pow 16) pow 3`;;
 val it : thm =
  |- ... =
     b pow 48
\end{verbatim}
}

\USES
Keeping terms in normal form. For simply proving equalities, {\small\verb%INT_RING%} is
more powerful and usually more convenient.

\SEEALSO
INT_ARITH, INT_RING, REAL_POLY_CONV, SEMIRING_NORMALIZERS_CONV.

\ENDDOC
\DOC{INT{\_}POW{\_}CONV}

\TYPE {\small\verb%INT_POW_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform exponentiation on a integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_POW_CONV `c pow n`%} where {\small\verb%c%} is an integer literal of type
{\small\verb%:int%} and {\small\verb%n%} is a numeral of type {\small\verb%:num%}, returns {\small\verb%|- c pow n = d%} where {\small\verb%d%}
is the canonical integer literal that is equal to {\small\verb%c%} raised to the {\small\verb%n%}th
power. The literal {\small\verb%c%} may be of the form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in
the latter case) and the result will be of the same form.

\FAILURE
Fails if applied to a term that is not a permitted integer literal of type
{\small\verb%:int%} raised to a numeral power.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_POW_CONV `(-- &2) pow 77`;;
  val it : thm = |- -- &2 pow 77 = -- &151115727451828646838272
\end{verbatim}
}

\SEEALSO
INT_POW_CONV, INT_REDUCE_CONV.

\ENDDOC
\DOC{INT{\_}REDUCE{\_}CONV}

\TYPE {\small\verb%INT_REDUCE_CONV : conv%}\egroup

\SYNOPSIS
Evaluate subexpressions built up from integer literals of type {\small\verb%:int%}, by
proof.

\DESCRIBE
When applied to a term, {\small\verb%INT_REDUCE_CONV%} performs a recursive bottom-up
evaluation by proof of subterms built from integer literals of type {\small\verb%:int%}
using the unary operators `{\small\verb%--%}', `{\small\verb%inv%}' and `{\small\verb%abs%}', and the binary
arithmetic (`{\small\verb%+%}', `{\small\verb%-%}', `{\small\verb%*%}', `{\small\verb%/%}', `{\small\verb%pow%}') and relational (`{\small\verb%<%}', `{\small\verb%<=%}',
`{\small\verb%>%}', `{\small\verb%>=%}', `{\small\verb%=%}') operators, as well as propagating literals through
logical operations, e.g. {\small\verb%T /\ x <=> x%}, returning a theorem that the original
and reduced terms are equal. The permissible integer literals are of the form
{\small\verb%&n%} or {\small\verb%-- &n%} for numeral {\small\verb%n%}, nonzero in the negative case.

\FAILURE
Never fails, but may have no effect.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_REDUCE_CONV
     `if &5 pow 4 < &4 pow 5 then (&2 pow 3 - &1) pow 2 + &1 else &99`;;
  val it : thm =
    |- (if &5 pow 4 < &4 pow 5 then (&2 pow 3 - &1) pow 2 + &1 else &99) = &50
\end{verbatim}
}

\COMMENTS
The corresponding {\small\verb%INT_REDUCE_CONV%} works for the type of integers. The more
general function {\small\verb%REAL_RAT_REDUCE_CONV%} works similarly over {\small\verb%:int%} but for
arbitrary rational literals.

\SEEALSO
INT_RED_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{INT{\_}RED{\_}CONV}

\TYPE {\small\verb%INT_RED_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs one arithmetic or relational operation on integer literals of type
{\small\verb%:int%}.

\DESCRIBE
When applied to any of the terms {\small\verb%`--c`%}, {\small\verb%`abs c`%}, {\small\verb%`c1 + c2`%}, {\small\verb%`c1 - c2`%},
{\small\verb%`c1 * c2`%}, {\small\verb%`c pow n`%}, {\small\verb%`c1 <= c2`%}, {\small\verb%`c1 < c2`%}, {\small\verb%`c1 >= c2`%}, {\small\verb%`c1 > c2`%},
{\small\verb%`c1 = c2`%}, where {\small\verb%c%}, {\small\verb%c1%} and {\small\verb%c2%} are integer literals of type {\small\verb%:int%} and
{\small\verb%n%} is a numeral of type {\small\verb%:num%}, {\small\verb%INT_RED_CONV%} returns a theorem
asserting the equivalence of the term to a canonical integer (for the
arithmetic operators) or a truth-value (for the relational operators). The
integer literals are terms of the form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the
latter case).

\FAILURE
Fails if applied to an inappropriate term.

\USES
More convenient for most purposes is {\small\verb%INT_REDUCE_CONV%}, which applies
these evaluation conversions recursively at depth, or still more generally
{\small\verb%REAL_RAT_REDUCE_CONV%} which applies to any rational numbers, not just
integers. Still, access to this `one-step' reduction can be handy if you want to
add a conversion {\small\verb%conv%} for some other operator on int number literals, which
you can conveniently incorporate it into {\small\verb%INT_REDUCE_CONV%} with
{\par\samepage\setseps\small
\begin{verbatim}
  # let INT_REDUCE_CONV' =
      DEPTH_CONV(INT_RED_CONV ORELSEC conv);;
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_RED_CONV.

\ENDDOC
\DOC{INT{\_}REM{\_}DOWN{\_}CONV}

\TYPE {\small\verb%INT_REM_DOWN_CONV : conv%}\egroup

\SYNOPSIS
Combines nested {\small\verb%rem%} terms into a single toplevel one.

\DESCRIBE
When applied to a term containing integer arithmetic operations of
negation, addition, subtraction, multiplication and exponentiation,
interspersed with applying {\small\verb%rem%} with a fixed modulus {\small\verb%n%}, and a toplevel
{\small\verb%... rem n%} too, the conversion {\small\verb%INT_REM_DOWN_CONV%} proves that this is equal
to a simplified term with only the toplevel {\small\verb%rem%}.

\FAILURE
Never fails but may have no effect

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `((x rem n) + (y rem n * &3) pow 2) rem n`;;
  val tm : term = `(x rem n + (y rem n * &3) pow 2) rem n`

  # INT_REM_DOWN_CONV tm;;
  val it : thm =
    |- (x rem n + (y rem n * &3) pow 2) rem n = (x + (y * &3) pow 2) rem n
\end{verbatim}
}

\SEEALSO
MOD_DOWN_CONV.

\ENDDOC
\DOC{INT{\_}RING}

\TYPE {\small\verb%INT_RING : term -> thm%}\egroup

\SYNOPSIS
Ring decision procedure instantiated to integers.

\DESCRIBE
The rule {\small\verb%INT_RING%} should be applied to a formula that, after suitable
normalization, can be considered a universally quantified Boolean combination
of equations and inequations between terms of type {\small\verb%:int%}. If that formula
holds in all integral domains, {\small\verb%INT_RING%} will prove it. Any ``alien'' atomic
formulas that are not integer equations will not contribute to the proof but
will not in themselves cause an error. The function is a particular
instantiation of {\small\verb%RING%}, which is a more generic procedure for ring and
semiring structures.

\FAILURE
Fails if the formula is unprovable by the methods employed. This does not
necessarily mean that it is not valid for {\small\verb%:int%}, but rather that it is not
valid on all integral domains (see below).

\EXAMPLE
Here is a nice identity taken from one of Ramanujan's notebooks:
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_RING
     `!a b c:int.
       a + b + c = &0
       ==> &2 * (a * b + a * c + b * c) pow 2 =
             a pow 4 + b pow 4 + c pow 4 /\
           &2 * (a * b + a * c + b * c) pow 4 =
             (a * (b - c)) pow 4 + (b * (a - c)) pow 4 + (c * (a - b)) pow 4`;;
  ...
  val it : thm =
    |- !a b c.
           a + b + c = &0
           ==> &2 * (a * b + a * c + b * c) pow 2 = a pow 4 + b pow 4 + c pow 4 /\
               &2 * (a * b + a * c + b * c) pow 4 =
               (a * (b - c)) pow 4 + (b * (a - c)) pow 4 + (c * (a - b)) pow 4
\end{verbatim}
}
The reasoning {\small\verb%INT_RING%} is capable of includes, of course, the degenerate case
of simple algebraic identity, e.g. Brahmagupta's identity:
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_RING `(a pow 2 + b pow 2) * (c pow 2 + d pow 2) =
              (a * c - b * d) pow 2 + (a * d + b * c) pow 2`;;
\end{verbatim}
}
\noindent or the more complicated 4-squares variant:
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_RING
    `(x1 pow 2 + x2 pow 2 + x3 pow 2 + x4 pow 2) *
     (y1 pow 2 + y2 pow 2 + y3 pow 2 + y4 pow 2) =
     (x1 * y1 - x2 * y2 - x3 * y3 - x4 * y4) pow 2 +
     (x1 * y2 + x2 * y1 + x3 * y4 - x4 * y3) pow 2 +
     (x1 * y3 - x2 * y4 + x3 * y1 + x4 * y2) pow 2 +
     (x1 * y4 + x2 * y3 - x3 * y2 + x4 * y1) pow 2`;;
  ...
\end{verbatim}
}
Note that formulas depending on specific features of the integers are not
always provable by this generic ring procedure. For example we cannot prove:
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_RING `x pow 2 = &2 ==> F`;;
  1 basis elements and 0 critical pairs
  Exception: Failure "find".
\end{verbatim}
}
Although it is possible to deal with special cases like this, there can be no
general algorithm for testing such properties over the integers: the set of
true universally quantified equations over the integers with addition and
multiplication is not recursively enumerable. (This follows from Matiyasevich's
results on diophantine sets leading to the undecidability of Hilbert's 10th
problem.)

\SEEALSO
INT_ARITH, INT_ARITH_TAC, int_ideal_cofactors, NUM_RING, REAL_RING, REAL_FIELD.

\ENDDOC
\DOC{INT{\_}SGN{\_}CONV}

\TYPE {\small\verb%INT_SGN_CONV : conv%}\egroup

\SYNOPSIS
Conversion to produce sign of an integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_SGN_CONV `int_sgn c`%}, where {\small\verb%c%} is an integer literal of type
{\small\verb%:int%}, returns the theorem {\small\verb%|- int_sgn c = d%} where {\small\verb%d%} is the canonical
integer literal that is equal to {\small\verb%c%}'s sign. The literal {\small\verb%c%} may be
of the form {\small\verb%&n%} or {\small\verb%-- &n%} and the result will be of the same form.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of integer literal of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_SGN_CONV `int_sgn(-- &42:int)`;;
  val it : thm = |- int_sgn (-- &42) = -- &1
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_SGN_CONV.

\ENDDOC
\DOC{INT{\_}SUB{\_}CONV}

\TYPE {\small\verb%INT_SUB_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform subtraction on two integer literals of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%INT_SUB_CONV `c1 - c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:int%}, returns {\small\verb%|- c1 - c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 - c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the difference of two permitted integer
literals of type {\small\verb%:int%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # INT_SUB_CONV `&33 - &77`;;
  val it : thm = |- &33 - &77 = -- &44
\end{verbatim}
}

\SEEALSO
INT_REDUCE_CONV, REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{isalnum}

\TYPE {\small\verb%isalnum : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is alphanumeric.

\DESCRIBE
The call {\small\verb%isalnum s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is alphanumeric, i.e. an uppercase or lowercase
letter, a digit, an underscore or a prime character.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalpha, isbra, isnum, issep, isspace, issymb.

\ENDDOC
\DOC{isalpha}

\TYPE {\small\verb%isalpha : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is alphabetic.

\DESCRIBE
The call {\small\verb%isalpha s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is alphabetic, i.e. an uppercase or lowercase
letter, an underscore or a prime character.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isbra, isnum, issep, isspace, issymb.

\ENDDOC
\DOC{isbra}

\TYPE {\small\verb%isbra : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is some kind of bracket.

\DESCRIBE
The call {\small\verb%isbra s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is a bracket, meaning an opening or closing
parenthesis, square bracket or curly brace.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isalpha, isnum, issep, isspace, issymb.

\ENDDOC
\DOC{isnum}

\TYPE {\small\verb%isnum : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is a decimal digit.

\DESCRIBE
The call {\small\verb%isnum s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is a decimal digit.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isalpha, isbra, issep, isspace, issymb.

\ENDDOC
\DOC{ISPEC}

\TYPE {\small\verb%ISPEC : term -> thm -> thm%}\egroup

\SYNOPSIS
Specializes a theorem, with type instantiation if necessary.

\DESCRIBE
This rule specializes a quantified variable as does {\small\verb%SPEC%}; it differs
from it in also instantiating the type if needed, both in the conclusion and
hypotheses:
{\par\samepage\setseps\small
\begin{verbatim}
     A |- !x:ty.tm
  -----------------------  ISPEC `t:ty'`
   A[ty'/ty] |- tm[t/x]
\end{verbatim}
}
\noindent (where {\small\verb%t%} is free for {\small\verb%x%} in {\small\verb%tm%}, and {\small\verb%ty'%} is an instance
of {\small\verb%ty%}).

\FAILURE
{\small\verb%ISPEC%} fails if the input theorem is not universally quantified, or if
the type of the given term is not an instance of the type of the
quantified variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ISPEC `0` EQ_REFL;;
  val it : thm = |- 0 = 0
\end{verbatim}
}
\noindent Note that the corresponding call to {\small\verb%SPEC%} would fail because of the
type mismatch:
{\par\samepage\setseps\small
\begin{verbatim}
  # SPEC `0` EQ_REFL;;
  Exception: Failure "SPEC".
\end{verbatim}
}

\SEEALSO
INST, INST_TYPE, ISPECL, SPEC, type_match.

\ENDDOC
\DOC{ISPECL}

\TYPE {\small\verb%ISPECL : term list -> thm -> thm%}\egroup

\SYNOPSIS
Specializes a theorem zero or more times, with type instantiation if necessary.

\DESCRIBE
{\small\verb%ISPECL%} is an iterative version of {\small\verb%ISPEC%}
{\par\samepage\setseps\small
\begin{verbatim}
         A |- !x1...xn.t
   -----------------------------  ISPECL [`t1`,...,`tn`]
    A' |- t[t1,...tn/x1,...,xn]
\end{verbatim}
}
\noindent (where {\small\verb%ti%} is free for {\small\verb%xi%} in {\small\verb%tm%}) in which {\small\verb%A'%} results from
applying all the corresponding type instantiations to the assumption list {\small\verb%A%}.

\FAILURE
{\small\verb%ISPECL%} fails if the list of terms is longer than the number of
quantified variables in the term, or if the type instantiation fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ISPECL [`x:num`; `2`] EQ_SYM_EQ;;
  val it : thm = |- x = 2 <=> 2 = x
\end{verbatim}
}
\noindent Note that the corresponding call to {\small\verb%SPECL%} would fail because of the
type mismatch:
{\par\samepage\setseps\small
\begin{verbatim}
  # SPECL [`x:num`; `2`] EQ_SYM_EQ;;
  Exception: Failure "SPECL".
\end{verbatim}
}

\SEEALSO
INST_TYPE, INST, ISPEC, SPEC, SPECL, type_match.

\ENDDOC
\DOC{issep}

\TYPE {\small\verb%issep : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is a separator.

\DESCRIBE
The call {\small\verb%issep s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is one of the separators `{\small\verb%,%}' or `{\small\verb%;%}'.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isalpha, isbra, isnum, isspace, issymb.

\ENDDOC
\DOC{isspace}

\TYPE {\small\verb%isspace : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is some kind of space.

\DESCRIBE
The call {\small\verb%isspace s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is a `space' of some kind, including tab and newline.

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isalpha, isbra, isnum, issep, issymb.

\ENDDOC
\DOC{issymb}

\TYPE {\small\verb%issymb : string -> bool%}\egroup

\SYNOPSIS
Tests if a one-character string is a symbol other than bracket or separator.

\DESCRIBE
The call {\small\verb%issymb s%} tests whether the first character of string {\small\verb%s%} (normally
it is the only character) is ``symbolic''. This means that it is one of the
usual ASCII characters but is not alphanumeric, not an underscore or prime
character, and is also not one of the two separators `{\small\verb%,%}' or `{\small\verb%;%}' nor any
bracket, parenthesis or curly brace. More explicitly, the set of symbolic
characters is:
{\par\samepage\setseps\small
\begin{verbatim}
  \ ! @ # $ % ^ & * - + | \ \ < = > / ? ~ . :
\end{verbatim}
}

\FAILURE
Fails if the string is empty.

\SEEALSO
isalnum, isalpha, isbra, isnum, issep, isspace.

\ENDDOC
\DOC{is{\_}abs}

\TYPE {\small\verb%is_abs : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is an abstraction.

\DESCRIBE
{\small\verb%is_abs `\var. t`%} returns {\small\verb%true%}. If the term is not an abstraction the
result is {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_abs `\x. x + 1`;;
  val it : bool = true

  # is_abs `!x. x >= 0`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
mk_abs, dest_abs, is_var, is_const, is_comb.

\ENDDOC
\DOC{is{\_}binary}

\TYPE {\small\verb%is_binary : string -> term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an application of a named binary operator.

\DESCRIBE
The call {\small\verb%is_binary s tm%} tests if term {\small\verb%tm%} is an instance of a binary
operator {\small\verb%(op l) r%} where {\small\verb%op%} is a constant with name {\small\verb%s%}. If so, it returns
true; otherwise it returns false. Note that {\small\verb%op%} is required to be a constant.

\FAILURE
Never fails.

\EXAMPLE
This one succeeds:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_binary "+" `1 + 2`;;
  val it : bool = true
\end{verbatim}
}
\noindent but this one fails unless {\small\verb%f%} has been declared a constant:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_binary "f" `f x y`;;
  Warning: inventing type variables
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_binary, is_binop, is_comb, mk_binary.

\ENDDOC
\DOC{is{\_}binder}

\TYPE {\small\verb%is_binder : string -> term -> bool%}\egroup

\SYNOPSIS
Tests if a term is a binder construct with named constant.

\DESCRIBE
The call {\small\verb%is_binder "c" t%} tests whether the term {\small\verb%t%} has the form of an
application of a constant {\small\verb%c%} to an abstraction. Note that this has nothing to
do with the parsing status of the name {\small\verb%c%} as a binder, but only the form of
the term.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_binder "!" `!x. x >= 0`;;
  val it : bool = true
\end{verbatim}
}
\noindent Note how only the basic logical form is tested, even taking in things
that we wouldn't really think of as binders:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_binder "=" `(=) (\x. x + 1)`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
dest_binder, mk_binder.

\ENDDOC
\DOC{is{\_}binop}

\TYPE {\small\verb%is_binop : term -> term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an application of the given binary operator.

\DESCRIBE
The call {\small\verb%is_binop op t%} returns {\small\verb%true%} if the term {\small\verb%t%} is of the form
{\small\verb%(op l) r%} for any two terms {\small\verb%l%} and {\small\verb%r%}, and {\small\verb%false%} otherwise.

\FAILURE
Never fails.

\EXAMPLE
This is a fairly typical example:
{\par\samepage\setseps\small
\begin{verbatim}
# is_binop `(/\)` `p /\ q`;;
val it : bool = true
\end{verbatim}
}
\noindent but note that the operator needn't be a constant:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_binop `f:num->num->num` `(f:num->num->num) x y`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
dest_binary, dest_binop, is_binary, mk_binary, mk_binop.

\ENDDOC
\DOC{is{\_}comb}

\TYPE {\small\verb%is_comb : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a combination (function application).

\DESCRIBE
{\small\verb%is_comb "t1 t2"%} returns {\small\verb%true%}. If the term is not a combination the result
is {\small\verb%false%}.

\FAILURE
Never fails

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_comb `x + 1`;;
  val it : bool = true
  # is_comb `T`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_comb, is_var, is_const, is_abs, mk_comb.

\ENDDOC
\DOC{is{\_}cond}

\TYPE {\small\verb%is_cond : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a conditional.

\DESCRIBE
{\small\verb%is_cond `if t then t1 else t2`%} returns {\small\verb%true%}. If the term is not a
conditional the result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
mk_cond, dest_cond.

\ENDDOC
\DOC{is{\_}conj}

\TYPE {\small\verb%is_conj : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a conjunction.

\DESCRIBE
{\small\verb%is_conj `t1 /\ t2`%} returns {\small\verb%true%}. If the term is not a conjunction the
result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_conj, mk_conj.

\ENDDOC
\DOC{is{\_}cons}

\TYPE {\small\verb%is_cons : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is an application of {\small\verb%CONS%}.

\DESCRIBE
{\small\verb%is_cons%} returns {\small\verb%true%} of a term representing a non-empty list. Otherwise it
returns {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_cons, dest_list, is_list, mk_cons, mk_list.

\ENDDOC
\DOC{is{\_}const}

\TYPE {\small\verb%is_const : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a constant.

\DESCRIBE
{\small\verb%is_const `const:ty`%} returns {\small\verb%true%}. If the term is not a constant the
result is {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_const `T`;;
  val it : bool = true
  # is_const `x:bool`;;
  val it : bool = false
\end{verbatim}
}
Note that numerals are not constants; they are composite constructs hidden by
prettyprinting:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_const `0`;;
  val it : bool = false
  # is_numeral `12345`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
dest_const, is_abs, is_comb, is_numeral, is_var, mk_const.

\ENDDOC
\DOC{is{\_}disj}

\TYPE {\small\verb%is_disj : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a disjunction.

\DESCRIBE
{\small\verb%is_disj `t1 \/ t2`%} returns {\small\verb%true%}. If the term is not a disjunction the
result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_disj, mk_disj.

\ENDDOC
\DOC{is{\_}eq}

\TYPE {\small\verb%is_eq : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is an equation.

\DESCRIBE
{\small\verb%is_eq `t1 = t2`%} returns {\small\verb%true%}. If the term is not an equation the result
is {\small\verb%false%}. Note that logical equivalence is just equality on type {\small\verb%:bool%},
even though it is printed as {\small\verb%<=>%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_eq `2 + 2 = 4`;;
  val it : bool = true

  # is_eq `p /\ q <=> q /\ p`;;
  val it : bool = true

  # is_eq `p ==> p`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_eq, is_beq, mk_eq.

\ENDDOC
\DOC{is{\_}exists}

\TYPE {\small\verb%is_exists : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it as an existential quantification.

\DESCRIBE
{\small\verb%is_exists `?var. t`%} returns {\small\verb%true%}. If the term is not an existential
quantification the result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_exists, mk_exists.

\ENDDOC
\DOC{is{\_}forall}

\TYPE {\small\verb%is_forall : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a universal quantification.

\DESCRIBE
{\small\verb%is_forall `!var. t`%} returns {\small\verb%true%}. If the term is not a universal
quantification the result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_forall, mk_forall.

\ENDDOC
\DOC{is{\_}gabs}

\TYPE {\small\verb%is_gabs : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is a basic or generalized abstraction.

\DESCRIBE
The call {\small\verb%is_gabs t%} tests if {\small\verb%t%} is either a basic logical abstraction (as
identified by {\small\verb%is_abs%}) or a generalized one (a standard composite logical
structure to support a non-variable vastruct). If so, it returns {\small\verb%true%}, and
otherwise it returns {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
This shows that ordinary abstractions are allowed:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_gabs `\x. x + 1`;;
  val it : bool = true
\end{verbatim}
}
\noindent while the following shows a more typical case:
{\par\samepage\setseps\small
\begin{verbatim}
  # is_gabs `\(x,y,z). x + y + z + 1`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
GEN_BETA_CONV, dest_gabs, mk_gabs.

\ENDDOC
\DOC{is{\_}hidden}

\TYPE {\small\verb%is_hidden : string -> bool%}\egroup

\SYNOPSIS
Determines whether a constant is hidden.

\DESCRIBE
This predicate returns {\small\verb%true%} if the named {\small\verb%ML%} constant has been hidden by
the function {\small\verb%hide_constant%}; it returns {\small\verb%false%} if the constant is not hidden.
Hiding a constant forces the quotation parser to treat the constant as
a variable (lexical rules permitting).

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_hidden "SUC";;
  val it : bool = false

  # hide_constant "SUC";;
  val it : unit = ()

  # is_hidden "SUC";;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
hide_constant, unhide_constant

\ENDDOC
\DOC{is{\_}iff}

\TYPE {\small\verb%is_iff : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an equation between Boolean terms (iff / logical
equivalence).

\DESCRIBE
Recall that in HOL, the Boolean operation variously called logical equivalence,
bi-implication or `if and only if' (iff) is simply the equality relation on
Boolean type. The call {\small\verb%is_iff t%} returns {\small\verb%true%} if {\small\verb%t%} is an equality between
terms of Boolean type, and {\small\verb%false%} otherwise.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_iff `p = T`;;
  val it : bool = true

  # is_iff `p <=> q`;;
  val it : bool = true

  # is_iff `0 = 1`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_iff, is_eq, mk_iff.

\ENDDOC
\DOC{is{\_}imp}

\TYPE {\small\verb%is_imp : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an application of implication.

\DESCRIBE
The call {\small\verb%is_imp t%} returns {\small\verb%true%} if {\small\verb%t%} is of the form {\small\verb%p ==> q%} for some {\small\verb%p%}
and {\small\verb%q%}, and returns {\small\verb%false%} otherwise.

\FAILURE
Never fails.

\SEEALSO
dest_imp.

\ENDDOC
\DOC{is{\_}intconst}

\TYPE {\small\verb%is_intconst : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%is_intconst t%} tests whether the term {\small\verb%t%} is a canonical integer
literal of type {\small\verb%:int%}, i.e. either `{\small\verb%&n%}' for a numeral {\small\verb%n%} or `{\small\verb%-- &n%}' for
a nonzero numeral {\small\verb%n%}. If so it returns {\small\verb%true%}, otherwise {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_intconst `-- &3 :int`;;
  val it : bool = true
  # is_intconst `-- &0 :int`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_intconst, is_realintconst, mk_intconst.

\ENDDOC
\DOC{is{\_}let}

\TYPE {\small\verb%is_let : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a {\small\verb%let%}-expression.

\DESCRIBE
{\small\verb%is_let `let x1 = e1 and ... and xn = en in E`%} returns {\small\verb%true%}.
If the term is not a {\small\verb%let%}-expression of any kind, the result is {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_let `let x = 1 in x + x`;;
  val it : bool = true

  # is_let `let x = 2 and y = 3 in y + x`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
mk_let, dest_let.

\ENDDOC
\DOC{is{\_}list}

\TYPE {\small\verb%is_list : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a list.

\DESCRIBE
{\small\verb%is_list%} returns {\small\verb%true%} of a term representing a list. Otherwise it returns
{\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_cons, dest_list, is_cons, mk_cons, mk_list.

\ENDDOC
\DOC{is{\_}neg}

\TYPE {\small\verb%is_neg : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a logical negation.

\DESCRIBE
{\small\verb%is_neg `~t`%} returns {\small\verb%true%}. If the term is not a logical negation the result
is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_neg, mk_neg.

\ENDDOC
\DOC{is{\_}numeral}

\TYPE {\small\verb%is_numeral : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is a natural number numeral.

\DESCRIBE
When applied to a term, {\small\verb%is_numeral%} returns {\small\verb%true%} if and only if the term is
a canonical natural number numeral ({\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%} etc.)

\FAILURE
Never fails.

\SEEALSO
dest_numeral, is_numeral.

\ENDDOC
\DOC{is{\_}pair}

\TYPE {\small\verb%is_pair : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a pair.

\DESCRIBE
{\small\verb%is_pair `(t1,t2)`%} returns {\small\verb%true%}. If the term is not a pair the result is
{\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_pair `1,2,3`;;
  val it : bool = true

  # is_pair `[1;2;3]`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_pair, is_cons, mk_pair.

\ENDDOC
\DOC{is{\_}prefix}

\TYPE {\small\verb%is_prefix : string -> bool%}\egroup

\SYNOPSIS
Tests if an identifier has prefix status.

\DESCRIBE
Certain identifiers {\small\verb%c%} have prefix status, meaning that combinations of the
form {\small\verb%c f x%} will be parsed as {\small\verb%c (f x)%} rather than the usual {\small\verb%(c f) x%}. The
call {\small\verb%is_prefix "c"%} tests if {\small\verb%c%} is one of those identifiers.

\FAILURE
Never fails.

\SEEALSO
parse_as_prefix, prefixes, unparse_as_prefix.

\ENDDOC
\DOC{is{\_}ratconst}

\TYPE {\small\verb%is_ratconst : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is a canonical rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%is_ratconst t%} tests whether the term {\small\verb%t%} is a canonical rational
literal of type {\small\verb%:real%}. This means an integer literal {\small\verb%&n%} for numeral {\small\verb%n%},
{\small\verb%-- &n%} for a nonzero numeral {\small\verb%n%}, or a ratio {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} where
{\small\verb%p%} is nonzero, {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} share no common factor. If so,
{\small\verb%is_ratconst%} returns {\small\verb%true%}, and otherwise {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_ratconst `&22 / &7`;;
  val it : bool = true
  # is_ratconst `&4 / &2`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
is_realintconst, rat_of_term, REAL_RAT_REDUCE_CONV, term_of_rat.

\ENDDOC
\DOC{is{\_}realintconst}

\TYPE {\small\verb%is_realintconst : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is an integer literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%is_realintconst t%} tests whether the term {\small\verb%t%} is a canonical integer
literal of type {\small\verb%:real%}, i.e. either `{\small\verb%&n%}' for a numeral {\small\verb%n%} or `{\small\verb%-- &n%}' for
a nonzero numeral {\small\verb%n%}. If so it returns {\small\verb%true%}, otherwise {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_realintconst `-- &3 :real`;;
  val it : bool = true
  # is_realintconst `&1 :int`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_realintconst, is_intconst, is_ratconst, mk_realintconst.

\ENDDOC
\DOC{is{\_}reserved{\_}word}

\TYPE {\small\verb%is_reserved_word : string -> bool%}\egroup

\SYNOPSIS
Tests if a string is one of the reserved words.

\DESCRIBE
Certain identifiers in HOL are reserved, e.g. `{\small\verb%if%}', `{\small\verb%let%}' and `{\small\verb%|%}',
meaning that they are special to the parser and cannot be used as ordinary
identifiers. The call {\small\verb%is_reserved_word s%} tests if the string {\small\verb%s%} is one of
them.

\FAILURE
Never fails.

\SEEALSO
reserved_words, reserve_words, unreserve_words.

\ENDDOC
\DOC{is{\_}select}

\TYPE {\small\verb%is_select : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a choice binding.

\DESCRIBE
{\small\verb%is_select `@var. t`%} returns {\small\verb%true%}. If the term is not an epsilon-term the
result is {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
mk_select, dest_select.

\ENDDOC
\DOC{is{\_}setenum}

\TYPE {\small\verb%is_setenum : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is a set enumeration.

\DESCRIBE
When applied to a term that is an explicit set enumeration {\small\verb%`{t1,...,tn}`%},
the function {\small\verb%is_setenum%} returns {\small\verb%true%}; otherwise it returns {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_setenum `1 INSERT 2 INSERT {}`;;
  val it : bool = true

  # is_setenum `{1,2,3,4,1,2,3,4}`;;
  val it : bool = true

  # is_setenum `1 INSERT 2 INSERT s`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
dest_setenum, mk_fset, mk_setenum.

\ENDDOC
\DOC{is{\_}type}

\TYPE {\small\verb%is_type : hol_type -> bool%}\egroup

\SYNOPSIS
Tests whether a type is an instance of a type constructor.

\DESCRIBE
{\small\verb%is_type ty%} returns {\small\verb%true%} if {\small\verb%ty%} is a base type or constructed by an outer
type constructor, and {\small\verb%false%} if it is a type variable.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_type `:bool`;;
  val it : bool = true

  # is_type `:bool->int`;;
  val it : bool = true

  # is_type `:Tyvar`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
get_type_arity, is_vartype.

\ENDDOC
\DOC{is{\_}uexists}

\TYPE {\small\verb%is_uexists : term -> bool%}\egroup

\SYNOPSIS
Tests if a term is of the form `there exists a unique ...'

\DESCRIBE
If {\small\verb%t%} has the form {\small\verb%?!x. p[x]%} (there exists a unique {\small\verb%x%} such that {\small\verb%p[x]%}
then {\small\verb%is_uexists t%} returns {\small\verb%true%}, otherwise {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
dest_uexists, is_exists, is_forall.

\ENDDOC
\DOC{is{\_}undefined}

\TYPE {\small\verb%is_undefined : ('a, 'b) func -> bool%}\egroup

\SYNOPSIS
Tests if a finite partial function is defined nowhere.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The predicate {\small\verb%is_undefined%} tests if the argument is the completely
undefined function.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let x = undefined and y = (1 |=> 2);;
  val x : ('a, 'b) func = <func>
  val y : (int, int) func = <func>

  # is_undefined x;;
  val it : bool = true

  # is_undefined y;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{is{\_}var}

\TYPE {\small\verb%is_var : term -> bool%}\egroup

\SYNOPSIS
Tests a term to see if it is a variable.

\DESCRIBE
{\small\verb%is_var `var:ty`%} returns {\small\verb%true%}. If the term is not a variable the result
is {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_var `x:bool`;;
  val it : bool = true
  # is_var `T`;;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
mk_var, dest_var, is_const, is_comb, is_abs.

\ENDDOC
\DOC{is{\_}vartype}

\TYPE {\small\verb%is_vartype : hol_type -> bool%}\egroup

\SYNOPSIS
Tests a type to see if it is a type variable.

\DESCRIBE
Returns {\small\verb%true%} if applied to a type variable. For types that are not type
variables it returns {\small\verb%false%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # is_vartype `:A`;;
  val it : bool = true

  # is_vartype `:bool`;;
  val it : bool = false

  # is_vartype (mk_vartype "bool");;
  val it : bool = true

\end{verbatim}
}

\SEEALSO
mk_vartype, dest_vartype.

\ENDDOC
\DOC{it}

\TYPE {\small\verb%it : 'a%}\egroup

\SYNOPSIS
Binds the value of the last expression evaluated at top level.

\DESCRIBE
The identifier {\small\verb%it%} is bound to the value of the last expression evaluated
at top level. Declarations do not effect the value of {\small\verb%it%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # 2 + 3;;
  val it : int = 5
  # let x = 2*3;;
  val x : int = 6
  # it;;
  val it : int = 5
  # it + 12;;
  val it : int = 17
\end{verbatim}
}

\USES
Used in evaluating expressions that require the value of the last evaluated
expression.

\ENDDOC
\DOC{ITAUT}

\TYPE {\small\verb%ITAUT : term -> thm%}\egroup

\SYNOPSIS
Attempt to prove term using intuitionistic first-order logic.

\DESCRIBE
The call {\small\verb%ITAUT `p`%} attempts to prove {\small\verb%p%} using a basic tableau-type proof
search for intuitionistic first-order logic. The restriction to intuitionistic
logic means that no principles such as the ``law of the excluded middle'' or
``law of double negation'' are used.

\FAILURE
Fails if the goal is non-Boolean. May also fail if it's unprovable, though more
usually this results in indefinite looping.

\EXAMPLE
This is intuitionistically valid, so it works:
{\par\samepage\setseps\small
\begin{verbatim}
  # ITAUT `~(~(~p)) ==> ~p`;;
  ...
  val it : thm = |- ~ ~ ~p ==> ~p
\end{verbatim}
}
\noindent whereas this, one of the main non-intuitionistic principles, is not:
{\par\samepage\setseps\small
\begin{verbatim}
  # ITAUT `~(~p) ==> p`;;
  Searching with limit 0
  Searching with limit 1
  Searching with limit 2
  Searching with limit 3
  ...
\end{verbatim}
}
\noindent so the procedure loops; you can as usual terminate such loops with
control-C.

\COMMENTS
Normally, first-order reasoning should be performed by {\small\verb%MESON[]%}, which is much
more powerful, complete for all classical logic, and handles equality. The
function {\small\verb%ITAUT%} is mainly for ``bootstrapping'' purposes. Nevertheless it may
sometimes be intellectually interesting to see that certain logical formulas
are provable intuitionistically.

\SEEALSO
BOOL_CASES_TAC, ITAUT_TAC, MESON, MESON_TAC.

\ENDDOC
\DOC{ITAUT{\_}TAC}

\TYPE {\small\verb%ITAUT_TAC : tactic%}\egroup

\SYNOPSIS
Simple intuitionistic logic prover.

\DESCRIBE
The tactic {\small\verb%ITAUT%} attempts to prove the goal using a basic tableau-type proof
search for intuitionistic first-order logic. The restriction to intuitionistic
logic means that no principles such as the ``law of the excluded middle'' or
``law of double negation'' are used.

\FAILURE
May fail if the goal is unprovable, e.g. for purely propositional problems. For
unsolvable problems with quantifiers it usually just loops.

\EXAMPLE
Suppose we try to prove the logical equivalence of ``contraposition'', already
embedded in the pre-proved theorem {\small\verb%CONTRAPOS_THM%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!p q. (p ==> q) <=> (~q ==> ~p)`;;
\end{verbatim}
}
\noindent by splitting it into two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN EQ_TAC);;
  val it : goalstack = 2 subgoals (2 total)

  `(~q ==> ~p) ==> p ==> q`

  `(p ==> q) ==> ~q ==> ~p`
\end{verbatim}
}
\noindent The first subgoal (printed at the bottom) can be solved by
{\small\verb%ITAUT_TAC%}, indicating that it's intuitionistically valid:
{\par\samepage\setseps\small
\begin{verbatim}
  # e ITAUT_TAC;;
  ...
  val it : goalstack = 1 subgoal (1 total)

  `(~q ==> ~p) ==> p ==> q`
\end{verbatim}
}
\noindent but the other one isn't, though it is solvable by full classical
logic:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MESON_TAC[]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\COMMENTS
Normally, first-order reasoning should be performed by {\small\verb%MESON_TAC[]%}, which is
much more powerful, complete for all classical logic, and handles equality. The
function {\small\verb%ITAUT_TAC%} is mainly for ``bootstrapping'' purposes. Nevertheless it
may sometimes be intellectually interesting to see that certain logical
formulas are provable intuitionistically.

\SEEALSO
ITAUT, MESON_TAC.

\ENDDOC
\DOC{itlist}

\TYPE {\small\verb%itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b%}\egroup

\SYNOPSIS
List iteration function. Applies a binary function between adjacent elements
of a list.

\DESCRIBE
{\small\verb%itlist f [x1;...;xn] y%} returns
{\par\samepage\setseps\small
\begin{verbatim}
   f x1 (f x2 ... (f xn y)...)
\end{verbatim}
}
\noindent It returns {\small\verb%y%} if list is empty.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # itlist (+) [1;2;3;4;5] 0;;
  val it : int = 15
  # itlist (+) [1;2;3;4;5] 6;;
  val it : int = 21
\end{verbatim}
}

\SEEALSO
rev_itlist, end_itlist.

\ENDDOC
\DOC{itlist2}

\TYPE {\small\verb%itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c%}\egroup

\SYNOPSIS
Applies a paired function between adjacent elements of 2 lists.

\DESCRIBE
{\small\verb%itlist2 f ([x1;...;xn],[y1;...;yn]) z%} returns
{\par\samepage\setseps\small
\begin{verbatim}
   f x1 y1 (f x2 y2 ... (f xn yn z)...)
\end{verbatim}
}
\noindent It returns {\small\verb%z%} if both lists are empty.

\FAILURE
Fails if the two lists are of different lengths.

\EXAMPLE
This takes a `dot product' of two vectors of integers:
{\par\samepage\setseps\small
\begin{verbatim}
  # let dot v w = itlist2 (fun x y z -> x * y + z) v w 0;;
  val dot : int list -> int list -> int = <fun>
  # dot [1;2;3] [4;5;6];;
  val it : int = 32
\end{verbatim}
}
\SEEALSO
itlist, rev_itlist, end_itlist, uncurry.

\ENDDOC
\DOC{K}

\TYPE {\small\verb%K : 'a -> 'b -> 'a%}\egroup

\SYNOPSIS
Forms a constant function: {\small\verb%(K x) y%} = {\small\verb%x%}.

\FAILURE
Never fails.

\SEEALSO
C, F_F, I, o, W.

\ENDDOC
\DOC{LABEL{\_}TAC}

\TYPE {\small\verb%LABEL_TAC : string -> thm_tactic%}\egroup

\SYNOPSIS
Add an assumption with a named label to a goal.

\DESCRIBE
Given a theorem {\small\verb%th%}, the tactic {\small\verb%LABEL_TAC "name" th%} will add {\small\verb%th%} as a new
hypothesis, just as {\small\verb%ASSUME_TAC%} does, but will also give it {\small\verb%name%} as a label.
The name will show up when the goal is printed, and can be used to refer to the
theorem in tactics like {\small\verb%USE_THEN%} and {\small\verb%REMOVE_THEN%}.

\FAILURE
Never fails, though may be invalid if the theorem has assumptions that are not
a subset of those in the goal, up to alpha-equivalence.

\EXAMPLE
Suppose we want to prove that a binary relation {\small\verb%<<=%} that is antisymmetric and
has a strong wellfoundedness property is also total and transitive, and
hence a wellorder:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!x y. x <<= y /\ y <<= x ==> x = y) /\
       (!s. ~(s = {}) ==> ?a:A. a IN s /\ !x. x IN s ==> a <<= x)
       ==> (!x y. x <<= y \/ y <<= x) /\
           (!x y z. x <<= y /\ y <<= z ==> x <<= z)`;;
\end{verbatim}
}
\noindent We might start by putting the two hypotheses on the assumption list
with intuitive names:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN(CONJUNCTS_THEN2 (LABEL_TAC "antisym") (LABEL_TAC "wo")));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`!x y. x <<= y /\ y <<= x ==> x = y`] (antisym)
   1 [`!s. ~(s = {}) ==> (?a. a IN s /\ (!x. x IN s ==> a <<= x))`] (wo)

  `(!x y. x <<= y \/ y <<= x) /\ (!x y z. x <<= y /\ y <<= z ==> x <<= z)`
\end{verbatim}
}
Now we break down the goal a bit
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`!x y. x <<= y /\ y <<= x ==> x = y`] (antisym)
   1 [`!s. ~(s = {}) ==> (?a. a IN s /\ (!x. x IN s ==> a <<= x))`] (wo)
   2 [`x <<= y`]
   3 [`y <<= z`]

  `x <<= z`

   0 [`!x y. x <<= y /\ y <<= x ==> x = y`] (antisym)
   1 [`!s. ~(s = {}) ==> (?a. a IN s /\ (!x. x IN s ==> a <<= x))`] (wo)

  `x <<= y \/ y <<= x`
\end{verbatim}
}
\noindent We want to specialize the wellordering assumption to an appropriate
set for each case, and we can identify it using the label {\small\verb%wo%}; the problem is
then simple set-theoretic reasoning:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(USE_THEN "wo" (MP_TAC o SPEC `{x:A,y:A}`) THEN SET_TAC[]);;
  ...
  val it : goalstack = 1 subgoal (1 total)

   0 [`!x y. x <<= y /\ y <<= x ==> x = y`] (antisym)
   1 [`!s. ~(s = {}) ==> (?a. a IN s /\ (!x. x IN s ==> a <<= x))`] (wo)
   2 [`x <<= y`]
   3 [`y <<= z`]

  `x <<= z`
\end{verbatim}
}
\noindent Similarly for the other one:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(USE_THEN "wo" (MP_TAC o SPEC `{x:A,y:A,z:A}`) THEN ASM SET_TAC[]);;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Convenient for referring to an assumption explicitly, just as in mathematics
books one sometimes marks a theorem with an asterisk or dagger, then refers to
it using that symbol.

\COMMENTS
There are other ways of identifying assumptions than by label, but they are not
always convenient. For example, explicitly doing {\small\verb%ASSUME `asm`%} is cumbersome
if {\small\verb%asm%} is large, and using its number in the assumption list can make proofs
very brittle under later changes.

\SEEALSO
ASSUME_TAC, DESTRUCT_TAC, NAME_ASSUMS_TAC, HYP, INTRO_TAC, REMOVE_THEN, USE_THEN.

\ENDDOC
\DOC{LAMBDA{\_}ELIM{\_}CONV}

\TYPE {\small\verb%LAMBDA_ELIM_CONV : conv%}\egroup

\SYNOPSIS
Eliminate lambda-terms that are not part of quantifiers from Boolean term.

\DESCRIBE
When applied to a Boolean term, {\small\verb%LAMBDA_ELIM_CONV%} returns an equivalent
version with `bare' lambda-terms (those not part of quantifiers) removed. They
are replaced with new `function' variables and suitable hypotheses about them;
for example a lambda-term {\small\verb%\x. t[x]%} is replaced by a function {\small\verb%f%} with an
additional hypothesis {\small\verb%!x. f x = t[x]%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LAMBDA_ELIM_CONV `MAP (\x. x + 1) l = l'`;;
  val it : thm =
    |- MAP (\x. x + 1) l = l' <=>
       (!_73141. (!x. _73141 x = x + 1) ==> MAP _73141 l = l')
\end{verbatim}
}

\USES
This is mostly intended for normalization prior to automated proof procedures,
and is used by {\small\verb%MESON%}, for example. However, it may sometimes be useful in
itself.

\SEEALSO
SELECT_ELIM_TAC, CONDS_ELIM_CONV.

\ENDDOC
\DOC{LAND{\_}CONV}

\TYPE {\small\verb%LAND_CONV : conv -> conv%}\egroup

\SYNOPSIS
Apply a conversion to left-hand argument of binary operator.

\DESCRIBE
If {\small\verb%c%} is a conversion where {\small\verb%c `l`%} gives {\small\verb%|- l = l'%}, then
{\small\verb%LAND_CONV c `op l r`%} gives {\small\verb%|- op l r = op l' r%}.

\FAILURE
Fails if the underlying conversion does or returns an inappropriate theorem
(i.e. is not really a conversion).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LAND_CONV NUM_ADD_CONV `(2 + 2) + (2 + 2)`;;
  val it : thm = |- (2 + 2) + 2 + 2 = 4 + 2 + 2
\end{verbatim}
}

\SEEALSO
ABS_CONV, COMB_CONV, COMB_CONV2, RAND_CONV, RATOR_CONV, SUB_CONV.

\ENDDOC
\DOC{last}

\TYPE {\small\verb%last : 'a list -> 'a%}\egroup

\SYNOPSIS
Computes the last element of a list.

\DESCRIBE
{\small\verb%last [x1;...;xn]%} returns {\small\verb%xn%}.

\FAILURE
Fails with {\small\verb%last%} if the list is empty.

\SEEALSO
butlast, hd, tl, el.

\ENDDOC
\DOC{lcm{\_}num}

\TYPE {\small\verb%lcm_num : num -> num -> num%}\egroup

\SYNOPSIS
Computes lowest common multiple of two unlimited-precision integers.

\DESCRIBE
The call {\small\verb%lcm_num m n%} for two unlimited-precision (type {\small\verb%num%}) integers {\small\verb%m%} and
{\small\verb%n%} returns the (positive) lowest common multiple of {\small\verb%m%} and {\small\verb%n%}. If either {\small\verb%m%}
or {\small\verb%n%} (or both) are both zero, it returns zero.

\FAILURE
Fails if either number is not an integer (the type {\small\verb%num%} supports arbitrary
rationals).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # lcm_num (Int 35) (Int(-77));;
  val it : num = 385
\end{verbatim}
}

\SEEALSO
gcd, gcd_num.

\ENDDOC
\DOC{LEANCOP}

\TYPE {\small\verb%LEANCOP : thm list -> term -> thm%}\egroup

\SYNOPSIS
Attempt to prove a term by first-order proof search using leanCop
connection-based prover.

\DESCRIBE
A call {\small\verb%LEANCOP[theorems] `tm`%} will attempt to prove {\small\verb%tm%} using pure
first-order reasoning, taking {\small\verb%theorems%} as the starting-point. It will usually
either prove it completely or run for an infeasibly long time, but it may
sometimes fail quickly.

Although {\small\verb%LEANCOP%} is capable of some fairly non-obvious pieces of first-order
reasoning, and will handle equality adequately, it does purely logical
reasoning. It will exploit no special properties of the constants in the goal,
other than equality and logical primitives. Any properties that are needed must
be supplied explicitly in the theorem list, e.g. {\small\verb%LE_REFL%} to tell it that {\small\verb%<=%}
on natural numbers is reflexive, or {\small\verb%REAL_ADD_SYM%} to tell it that addition on
real numbers is symmetric.

\FAILURE
Fails if the term is unprovable within the search bounds.

\EXAMPLE
A typical application is to prove some elementary logical lemma for use inside
a tactic proof:
{\par\samepage\setseps\small
\begin{verbatim}
  # LEANCOP [EXTENSION; IN_INSERT]
      `x INSERT y INSERT s = y INSERT x INSERT s`;;
\end{verbatim}
}

\USES
Generating simple logical lemmas as part of a large proof.

\SEEALSO
LEANCOP_TAC, MESON, METIS, NANOCOP.

\ENDDOC
\DOC{LEANCOP{\_}TAC}

\TYPE {\small\verb%LEANCOP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic using leanCoP algorithm.

\DESCRIBE
A call to {\small\verb%LEANCOP_TAC[theorems]%} will attempt to establish the current goal
using pure first-order reasoning, taking {\small\verb%theorems%} as the starting-point.
It will usually either solve the goal completely or run for an infeasibly long
time, but it may sometimes fail quickly. This tactic is analogous to
{\small\verb%MESON_TAC%}, and many of the same general comments apply.

\FAILURE
Fails if the goal is unprovable within the search bounds.

\EXAMPLE
Here is a simple fact about natural number sums as a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum u f`;;

\end{verbatim}
}
It is solved in a fraction of a second by {\small\verb%LEANCOP_TAC%} with some relevant
lemmas:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(LEANCOP_TAC[SUBSET; NSUM_SUPERSET; IN_UNION]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
LEANCOP, MESON_TAC, METIS_TAC, NANOCOP_TAC.

\ENDDOC
\DOC{leftbin}

\TYPE {\small\verb%leftbin : ('a -> 'b * 'c) -> ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c%}\egroup

\SYNOPSIS
Parses iterated left-associated binary operator.

\DESCRIBE
If {\small\verb%p%} is a parser for ``items'' of some kind, {\small\verb%s%} is a parser for some
``separator'', {\small\verb%c%} is a `constructor' function taking an element as parsed by
{\small\verb%s%} and two other elements as parsed by {\small\verb%p%} and giving a new such element, and
{\small\verb%e%} is an error message, then {\small\verb%leftbin p s c e%} will parse an iterated sequence
of items by {\small\verb%p%} and separated by something parsed with {\small\verb%s%}. It will repeatedly
apply the constructor function {\small\verb%c%} to compose these elements into one,
associating to the left. For example, the input:
{\par\samepage\setseps\small
\begin{verbatim}
  <p1> <s1> <p2> <s2> <p3> <s3> <p4>
\end{verbatim}
}
meaning successive segments {\small\verb%pi%} that are parsed by {\small\verb%p%} and {\small\verb%sj%} that are
parsed by {\small\verb%s%}, will result in
{\par\samepage\setseps\small
\begin{verbatim}
  c (c s2 (c s1 p1 p2) p3) p4
\end{verbatim}
}

\FAILURE
The call {\small\verb%leftbin p s c e%} never fails, though the resulting parser may.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, listof, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{length}

\TYPE {\small\verb%length : 'a list -> int%}\egroup

\SYNOPSIS
Computes the length of a list: {\small\verb%length [x1;...;xn]%} returns {\small\verb%n%}.

\FAILURE
Never fails.

\ENDDOC
\DOC{LENGTH{\_}CONV}

\TYPE {\small\verb%LENGTH_CONV : conv%}\egroup

\SYNOPSIS
Evaluate the list {\small\verb%LENGTH%} function when applied to a specific list.

\DESCRIBE
When applied to a term {\small\verb%`LENGTH [t1; ...; tn]`%} the conversion
{\small\verb%LENGTH_CONV%} returns the theorem {\small\verb%|- LENGTH [t1; ...; tn] = n%}. The
elements of the list do not have to be constants or ground terms.

\FAILURE
Fails if the term is not of the expected form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LENGTH_CONV `LENGTH [1;2;3;4;5]`;;
  val it : thm = |- LENGTH [1; 2; 3; 4; 5] = 5

  # LENGTH_CONV `LENGTH [a;one;c]`;;
  val it : thm = |- LENGTH [a; one; c] = 3
\end{verbatim}
}

\USES
Evaluating {\small\verb%LENGTH%} in a more efficient and focused way than unfolding its
definition.

\SEEALSO
EL_CONV, LIST_CONV, LIST_OF_SEQ_CONV, REVERSE_CONV.

\ENDDOC
\DOC{let{\_}CONV}

\TYPE {\small\verb%let_CONV : term -> thm%}\egroup

\SYNOPSIS
Evaluates {\small\verb%let%}-terms in the HOL logic.

\DESCRIBE
The conversion {\small\verb%let_CONV%} implements evaluation of object-language {\small\verb%let%}-terms.
When applied to a {\small\verb%let%}-term of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   let v1 = t1 and ... and vn = tn in t
\end{verbatim}
}
\noindent where {\small\verb%v1%}, ..., {\small\verb%vn%} are variables, {\small\verb%let_CONV%} proves and returns
the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (let v1 = t1 and ... and vn = tn in t) = t[t1,...,tn/v1,...,vn]
\end{verbatim}
}
\noindent where {\small\verb%t[t1,...,tn/v1,...,vn]%} denotes the result of substituting
{\small\verb%ti%} for {\small\verb%v1%} in parallel in {\small\verb%t%}, with automatic renaming of bound variables
to prevent free variable capture.

{\small\verb%let_CONV%} also works on {\small\verb%let%}-terms that bind terms built up from applications
of inductive type constructors. For example, if {\small\verb%<tup>%} is an
arbitrarily-nested tuple of distinct variables {\small\verb%v1%}, ..., {\small\verb%vn%} and {\small\verb%<val>%} is a
structurally similar tuple of values, that is {\small\verb%<val>%} equals
{\small\verb%<tup>[t1,...,tn/v1,...,vn]%} for some terms {\small\verb%t1%}, ..., {\small\verb%tn%}, then:
{\par\samepage\setseps\small
\begin{verbatim}
   let_CONV `let <tup> = <val> in t`
\end{verbatim}
}
\noindent returns
{\par\samepage\setseps\small
\begin{verbatim}
  |- (let <tup> = <val> in t) = t[t1,...,tn/v1,...,vn]
\end{verbatim}
}
\noindent That is, the term {\small\verb%ti%} is substituted for the corresponding variable
{\small\verb%vi%} in {\small\verb%t%}.  This form of {\small\verb%let%}-reduction also works with simultaneous binding
of tuples using {\small\verb%and%}.

\FAILURE
{\small\verb%let_CONV tm%} fails if {\small\verb%tm%} is not a reducible {\small\verb%let%}-term of one of the forms
specified above.

\EXAMPLE
A simple example of the use of {\small\verb%let_CONV%} to eliminate a single local variable
is the following:
{\par\samepage\setseps\small
\begin{verbatim}
  # let_CONV `let x = 1 in x+y`;;
  val it : thm = |- (let x = 1 in x + y) = 1 + y
\end{verbatim}
}
\noindent and an example showing a tupled binding is:
{\par\samepage\setseps\small
\begin{verbatim}
  # let_CONV `let (x,y) = (1,2) in x+y`;;
  val it : thm = |- (let x,y = 1,2 in x + y) = 1 + 2
\end{verbatim}
}
\noindent Simultaneous introduction of two bindings
is illustrated by:
{\par\samepage\setseps\small
\begin{verbatim}
  # let_CONV `let x = 1 and y = 2 in x + y + z`;;
  val it : thm = |- (let x = 1 and y = 2 in x + y + z) = 1 + 2 + z
\end{verbatim}
}

\SEEALSO
BETA_CONV, GEN_BETA_CONV, SUBLET_CONV.

\ENDDOC
\DOC{LET{\_}TAC}

\TYPE {\small\verb%LET_TAC : tactic%}\egroup

\SYNOPSIS
Eliminates a let binding in a goal by introducing equational assumptions.

\DESCRIBE
Given a goal {\small\verb%A ?- t%} where {\small\verb%t%} contains a free let-expression
{\small\verb%let x1 = E1 and ... let xn = En in E%}, the tactic {\small\verb%LET_TAC%} replaces that
subterm by simply {\small\verb%E%} but adds new assumptions {\small\verb%E1 = x1%}, ..., {\small\verb%En = xn%}.
That is, the local let bindings are replaced with new assumptions, put in
reverse order so that {\small\verb%ASM_REWRITE_TAC%} will not immediately expand them. In
cases where the term contains several let-expression candidates, a topmost one
will be selected. In particular, if let-expressions are nested, the outermost
one will be handled.

\FAILURE
Fails if the goal contains no eligible let-term.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `let x = 2 and y = 3 in x + 1 <= y`;;
  val it : goalstack = 1 subgoal (1 total)

  `let x = 2 and y = 3 in x + 1 <= y`

  # e LET_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`2 = x`]
   1 [`3 = y`]

  `x + 1 <= y`
\end{verbatim}
}

\SEEALSO
ABBREV_TAC, EXPAND_TAC, let_CONV.

\ENDDOC
\DOC{lex}

\TYPE {\small\verb%lex : string list -> lexcode list%}\egroup

\SYNOPSIS
Lexically analyze an input string.

\DESCRIBE
The function {\small\verb%lex%} expects a list of single-character strings representing
input (as produced by {\small\verb%explode%}, for example) and analyzes it into a sequence
of tokens according to HOL Light lexical conventions. A token is either
{\small\verb%Ident "s"%} or {\small\verb%Resword "s"%}; in each case this encodes a string but in the
latter case indicates that the string is a reserved word.

Lexical analysis essentially regards any number of alphanumeric characters (see
{\small\verb%isalnum%}) or any number of symbolic characters (see {\small\verb%issymb%}) as a single
token, except that certain brackets (see {\small\verb%isbra%}) are only allowed to be
single-character tokens and other separators (see {\small\verb%issep%}) can only be combined
with multiple instances of themselves not other characters. Whitespace
including spaces, tabs and newlines (see {\small\verb%isspace%}) is eliminated and serves
only to separate tokens that would otherwise be one. Comments introduced by the
comment token (see {\small\verb%comment_token%}) are removed.

\FAILURE
Fails if the input is highly malformed, e.g. contains illegal characters.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # lex(explode "if p+1=2 then x + 1 else y - 1");;
  val it : lexcode list =
    [Resword "if"; Ident "p"; Ident "+"; Ident "1"; Ident "="; Ident "2";
     Resword "then"; Ident "x"; Ident "+"; Ident "1"; Resword "else";
     Ident "y"; Ident "-"; Ident "1"]
\end{verbatim}
}

\SEEALSO
comment_token, explode, isalnum, isbra, issep, isspace, issymb,
is_reserved_word, parse_term, parse_type.

\ENDDOC
\DOC{LE{\_}IMP}

\TYPE {\small\verb%LE_IMP : thm -> thm%}\egroup

\SYNOPSIS
Perform transitivity chaining for non-strict natural number inequality.

\DESCRIBE
When applied to a theorem {\small\verb%A |- s <= t%} where {\small\verb%s%} and {\small\verb%t%} have type {\small\verb%num%}, the
rule {\small\verb%LE_IMP%} returns {\small\verb%A |- !x1...xn z. t <= z ==> s <= z%}, where {\small\verb%z%} is some
variable and the {\small\verb%x1,...,xn%} are free variables in {\small\verb%s%} and {\small\verb%t%}.

\FAILURE
Fails if applied to a theorem whose conclusion is not of the form {\small\verb%`s <= t`%}
for some natural number terms {\small\verb%s%} and {\small\verb%t%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LE_IMP (ARITH_RULE `n <= SUC(m + n)`);;
  val it : thm = |- !m n p. SUC (m + n) <= p ==> n <= p
\end{verbatim}
}

\USES
Can make transitivity chaining in goals easier, e.g. by
{\small\verb%FIRST_ASSUM(MATCH_MP_TAC o LE_IMP)%}.

\SEEALSO
ARITH_RULE, REAL_LE_IMP, REAL_LET_IMP.

\ENDDOC
\DOC{lhand}

\TYPE {\small\verb%lhand : term -> term%}\egroup

\SYNOPSIS
Take left-hand argument of a binary operator.

\DESCRIBE
When applied to a term {\small\verb%t%} that is an application of a binary operator to two
arguments, i.e. is of the form {\small\verb%(op l) r%}, the call {\small\verb%lhand t%} will return the
left-hand argument {\small\verb%l%}. The terms {\small\verb%op%} and {\small\verb%r%} are arbitrary, though in many
applications {\small\verb%op%} is a constant such as addition or equality.

\FAILURE
Fails if the term is not of the indicated form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # lhand `1 + 2`;;
  val it : term = `1`

  # lhand `2 + 2 = 4`;;
  val it : term = `2 + 2`

  # lhand `f x y z`;;
  Warning: inventing type variables
  val it : term = `y`

  # lhand `if p then q else r`;;
  Warning: inventing type variables
  val it : term = `q`
\end{verbatim}
}

\COMMENTS
On equations, {\small\verb%lhand%} has the same effect as {\small\verb%lhs%}, but may be slightly quicker
because it does not check whether the operator {\small\verb%op%} is indeed the equality
constant.

\SEEALSO
lhs, rand, rhs.

\ENDDOC
\DOC{lhs}

\TYPE {\small\verb%lhs : term -> term%}\egroup

\SYNOPSIS
Returns the left-hand side of an equation.

\DESCRIBE
{\small\verb%lhs `t1 = t2`%} returns {\small\verb%`t1`%}.

\FAILURE
Fails with {\small\verb%lhs%} if the term is not an equation.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # lhs `2 + 2 = 4`;;
  val it : term = `2 + 2`
\end{verbatim}
}

\SEEALSO
dest_eq, lhand, rand, rhs.

\ENDDOC
\DOC{lift{\_}function}

\TYPE {\small\verb%lift_function : thm -> thm * thm -> string -> thm -> thm * thm%}\egroup

\SYNOPSIS
Lift a function on representing type to quotient type of equivalence classes.

\DESCRIBE
Suppose type {\small\verb%qty%} is a quotient type of {\small\verb%rty%} under an equivalence relation
{\small\verb%R:rty->rty->bool%}, as defined by {\small\verb%define_quotient_type%}, and {\small\verb%f%} is a function
{\small\verb%f:ty1->...->tyn->ty%}, some {\small\verb%tyi%} being the representing type {\small\verb%rty%}. The term
{\small\verb%lift_function%} should be applied to (i) a theorem of the form
{\small\verb%|- (?x. r = R x) <=> rep(abs r) = r%} as returned by {\small\verb%define_quotient_type%},
(ii) a pair of
theorems asserting that {\small\verb%R%} is reflexive and transitive, (iii) a desired name
for the counterpart of {\small\verb%f%} lifted to the type of equivalence classes, and (iv)
a theorem asserting that {\small\verb%f%} is ``welldefined'', i.e. respects the equivalence
class. This last theorem essentially asserts that the value of {\small\verb%f%} is
independent of the choice of representative: any {\small\verb%R%}-equivalent inputs give an
equal output, or an {\small\verb%R%}-equivalent one. Syntactically, the welldefinedness
theorem should be of the form:
{\par\samepage\setseps\small
\begin{verbatim}
  |- !x1 x1' .. xn xn'. (x1 == x1') /\ ... /\ (xn == xn')
                        ==> (f x1 .. xn == f x1' .. f nx')
\end{verbatim}
}
\noindent where each {\small\verb%==%} may be either equality or the relation {\small\verb%R%}, the
latter of course only if the type of that argument is {\small\verb%rty%}. The reflexivity
and transitivity theorems should be
{\par\samepage\setseps\small
\begin{verbatim}
  |- !x. R x x
\end{verbatim}
}
\noindent and
{\par\samepage\setseps\small
\begin{verbatim}
  |- !x y z. R x y /\ R y z ==> R x z
\end{verbatim}
}
It returns two theorems, a definition and a consequential theorem that can be
used by {\small\verb%lift_theorem%} later.

\FAILURE
Fails if the theorems are malformed or if there is already a constant of the
given name.

\EXAMPLE
Suppose that we have defined a type of finite multisets as in the documentation
for {\small\verb%define_quotient_type%}, based on the equivalence relation {\small\verb%multisame%} on
lists. First we prove that the equivalence relation {\small\verb%multisame%} is indeed
reflexive and transitive:
{\par\samepage\setseps\small
\begin{verbatim}
  # let MULTISAME_REFL,MULTISAME_TRANS = (CONJ_PAIR o prove)
     (`(!l:(A)list. multisame l l) /\
       (!l1 l2 l3:(A)list.
            multisame l1 l2 /\ multisame l2 l3 ==> multisame l1 l3)`,
      REWRITE_TAC[multisame] THEN MESON_TAC[]);;
\end{verbatim}
}
We would like to define the multiplicity of an element in a multiset. First we
define this notion on the representing type of lists:
{\par\samepage\setseps\small
\begin{verbatim}
  # let listmult = new_definition
     `listmult a l = LENGTH (FILTER (\x:A. x = a) l)`;;
\end{verbatim}
}
\noindent and prove that it is welldefined. Note that the second argument is
the only one we want to lift to the quotient type, so that's the only one for
which we use the relation {\small\verb%multisame%}. For the first argument and the result we
only use equality:
{\par\samepage\setseps\small
\begin{verbatim}
  # let LISTMULT_WELLDEF = prove
     (`!a a':A l l'.
        a = a' /\ multisame l l' ==> listmult a l = listmult a' l'`,
      SIMP_TAC[listmult; multisame]);;
\end{verbatim}
}
\noindent Now we can lift it to a multiplicity function on the quotient type:
{\par\samepage\setseps\small
\begin{verbatim}
  # let multiplicity,multiplicity_th =
      lift_function multiset_rep (MULTISAME_REFL,MULTISAME_TRANS)
      "multiplicity" LISTMULT_WELLDEF;;
  val multiplicity : thm =
    |- multiplicity a l = (@u. ?l. listmult a l = u /\ list_of_multiset l l)
  val multiplicity_th : thm =
    |- listmult a l = multiplicity a (multiset_of_list (multisame l))
\end{verbatim}
}
Another example is the `union' of multisets, which we can consider as the
lifting of the {\small\verb%APPEND%} operation on lists, which we show is welldefined:
{\par\samepage\setseps\small
\begin{verbatim}
  # let APPEND_WELLDEF = prove
     (`!l l' m m' :A list.
         multisame l l' /\ multisame m m'
         ==> multisame (APPEND l m) (APPEND l' m')`,
      SIMP_TAC[multisame; FILTER_APPEND]);;
\end{verbatim}
}
\noindent and lift as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # let munion,munion_th =
      lift_function multiset_rep (MULTISAME_REFL,MULTISAME_TRANS)
      "munion" APPEND_WELLDEF;;
  val munion : thm =
    |- munion l m =
       multiset_of_list
       (\u. ?l m.
                multisame (APPEND l m) u /\
                list_of_multiset l l /\
                list_of_multiset m m)
  val munion_th : thm =
    |- multiset_of_list (multisame (APPEND l m)) =
       munion (multiset_of_list (multisame l)) (multiset_of_list (multisame m))
\end{verbatim}
}
For continuation of this example, showing how to lift theorems from the
representing functions to the functions on the quotient type, see the
documentation entry for {\small\verb%lift_theorem%}.

\COMMENTS
If, as in these examples, the representing type is parametrized by type
variables, make sure that the same type variables are used consistently in the
various theorems.

\SEEALSO
define_quotient_type, lift_theorem.

\ENDDOC
\DOC{lift{\_}theorem}

\TYPE {\small\verb%lift_theorem : thm * thm -> thm * thm * thm -> thm list -> thm -> thm%}\egroup

\SYNOPSIS
Lifts a theorem to quotient type from representing type.

\DESCRIBE
The function {\small\verb%lift_theorem%} should be applied (i) a pair of type bijection
theorems as returned by {\small\verb%define_quotient_type%} for equivalence classes over a
binary relation {\small\verb%R%}, (ii) a triple of theorems asserting that the relation {\small\verb%R%}
is reflexive, symmetric and transitive in exactly the following form:
{\par\samepage\setseps\small
\begin{verbatim}
  |- !x. R x x
  |- !x y. R x y <=> R y x
  |- !x y z. R x y /\ R y z ==> R x z
\end{verbatim}
}
\noindent and (iii) the list of theorems returned as the second component of
the pairs from {\small\verb%lift_function%} for all functions that should be mapped.
Finally, it is then applied to a theorem about the representing type. It
automatically maps it over to the quotient type, appropriately modifying
quantification over the representing type into quantification over the new
quotient type, and replacing functions over the representing type with their
corresponding lifted counterparts. Note that all variables should be bound by
quantifiers; these may be existential or universal but if any types involve the
representing type {\small\verb%rty%} it must be just {\small\verb%rty%} and not a composite or
higher-order type such as {\small\verb%rty->rty%} or {\small\verb%rty#num%}.

\FAILURE
Fails if any of the input theorems are malformed (e.g. symmetry stated with
implication instead of equivalence) or fail to correspond (e.g. different
polymorphic type variables in the type bijections and the equivalence theorem).
Otherwise it will not fail, but if used improperly may not map the theorem
across cleanly.

\EXAMPLE
This is a continuation of the example in the documentation entries for
{\small\verb%define_quotient_type%} and {\small\verb%lift_function%}, where a type of finite multisets is
defined as the quotient of the type of lists by a suitable equivalence relation
{\small\verb%multisame%}. We can take the theorems asserting that this is indeed reflexive,
symmetric and transitive:
{\par\samepage\setseps\small
\begin{verbatim}
  # let [MULTISAME_REFL;MULTISAME_SYM;MULTISAME_TRANS] = (CONJUNCTS o prove)
     (`(!l:(A)list. multisame l l) /\
       (!l l':(A)list. multisame l l' <=> multisame l' l) /\
       (!l1 l2 l3:(A)list.
            multisame l1 l2 /\ multisame l2 l3 ==> multisame l1 l3)`,
      REWRITE_TAC[multisame] THEN MESON_TAC[]);;
\end{verbatim}
}
\noindent and can now lift theorems. For example, we know that {\small\verb%APPEND%} is
itself associative, and so in particular:
{\par\samepage\setseps\small
\begin{verbatim}
  # let MULTISAME_APPEND_ASSOC = prove
     (`!l m n. multisame (APPEND l (APPEND m n)) (APPEND (APPEND l m) n)`,
      REWRITE_TAC[APPEND_ASSOC; MULTISAME_REFL]);;
\end{verbatim}
}
\noindent and we can easily show how list multiplicity interacts with {\small\verb%APPEND%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # let LISTMULT_APPEND = prove
     (`!a l m. listmult a (APPEND l m) = listmult a l + listmult a m`,
      REWRITE_TAC[listmult; LENGTH_APPEND; FILTER_APPEND]);;
\end{verbatim}
}
These theorems and any others like them can now be lifted to equivalence
classes:
{\par\samepage\setseps\small
\begin{verbatim}
  # let [MULTIPLICITY_MUNION;MUNION_ASSOC] =
        map (lift_theorem (multiset_abs,multiset_rep)
                          (MULTISAME_REFL,MULTISAME_SYM,MULTISAME_TRANS)
                          [multiplicity_th; munion_th])
            [LISTMULT_APPEND; MULTISAME_APPEND_ASSOC];;
  val ( MULTIPLICITY_MUNION ) : thm =
    |- !a l m.
           multiplicity a (munion l m) = multiplicity a l + multiplicity a m
  val ( MUNION_ASSOC ) : thm =
    |- !l m n. munion l (munion m n) = munion (munion l m) n
\end{verbatim}
}

\SEEALSO
define_quotient_type, lift_function.

\ENDDOC
\DOC{listof}

\TYPE {\small\verb%listof : ('a -> 'b * 'c) -> ('c -> 'd * 'a) -> string -> 'a -> 'b list * 'c%}\egroup

\SYNOPSIS
Parses a separated list of items.

\DESCRIBE
If {\small\verb%p%} is a parser for ``items'' of some kind, {\small\verb%s%} is a parser for a
``separator'', and {\small\verb%e%} is an error message, then {\small\verb%listof p s e%} parses a
nonempty list of successive items using {\small\verb%p%}, where adjacent items are separated
by something parseable by {\small\verb%s%}. If a separator is parsed successfully but there
is no following item that can be parsed by {\small\verb%s%}, an exception {\small\verb%Failure e%} is
raised. (So note that the separator must not terminate the final element.)

\FAILURE
The call {\small\verb%listof p s e%} itself never fails, though the resulting parser may.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, many, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{LIST{\_}CONV}

\TYPE {\small\verb%LIST_CONV : conv -> conv%}\egroup

\SYNOPSIS
Apply a conversion to each element of a list.

\DESCRIBE
If {\small\verb%cnv `ti`%} returns {\small\verb%|- ti = ti'%} for {\small\verb%i%} ranging from {\small\verb%1%} to {\small\verb%n%}, then
{\small\verb%LIST_CONV cnv `[t1; ...; tn]`%} returns {\small\verb%|- [t1; ...; tn] = [t1'; ...; tn']%}.

\FAILURE
Fails if the conversion fails on any list element.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LIST_CONV num_CONV `[1;2;3;4;5]`;;
  val it : thm = |- [1; 2; 3; 4; 5] = [SUC 0; SUC 1; SUC 2; SUC 3; SUC 4]
\end{verbatim}
}

\USES
Applying a conversion more delicately than simply by {\small\verb%DEPTH_CONV%} etc.

\SEEALSO
DEPTH_BINOP_CONV, DEPTH_CONV, EL_CONV, LENGTH_CONV, LIST_OF_SEQ_CONV,
ONCE_DEPTH_CONV, REDEPTH_CONV, REVERSE_CONV, TOP_DEPTH_CONV, TOP_SWEEP_CONV.

\ENDDOC
\DOC{LIST{\_}INDUCT{\_}TAC}

\TYPE {\small\verb%LIST_INDUCT_TAC : tactic%}\egroup

\SYNOPSIS
Performs tactical proof by structural induction on lists.

\DESCRIBE
{\small\verb%LIST_INDUCT_TAC%} reduces a goal {\small\verb%A ?- !l. P[l]%}, where {\small\verb%l%} ranges over lists,
to two subgoals corresponding to the base and step cases in a proof by
structural induction on {\small\verb%l%}. The induction hypothesis appears among the
assumptions of the subgoal for the step case.  The specification of
{\small\verb%LIST_INDUCT_TAC%} is:
{\par\samepage\setseps\small
\begin{verbatim}
                     A ?- !l. P
   =====================================================  LIST_INDUCT_TAC
    A |- P[[]/l]   A u {P[t/l]} ?- P[CONS h t/l]
\end{verbatim}
}

\FAILURE
{\small\verb%LIST_INDUCT_TAC g%} fails unless the conclusion of the goal {\small\verb%g%} has the form
{\small\verb%`!l. t`%}, where the variable {\small\verb%l%} has type {\small\verb%(ty)list%} for some type {\small\verb%ty%}.

\EXAMPLE
Many simple list theorems can be proved simply by list induction then just
first-order reasoning (or even rewriting) with definitions of the operations
involved. For example if we want to prove that mapping a composition of
functions over a list is the same as successive mapping of the two functions:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!l f:A->B g:B->C. MAP (g o f) l = MAP g (MAP f l)`;;
\end{verbatim}
}
\noindent we can start by list induction:
{\par\samepage\setseps\small
\begin{verbatim}
  # e LIST_INDUCT_TAC;;
  val it : goalstack = 2 subgoals (2 total)

   0 [`!f g. MAP (g o f) t = MAP g (MAP f t)`]

  `!f g. MAP (g o f) (CONS h t) = MAP g (MAP f (CONS h t))`

  `!f g. MAP (g o f) [] = MAP g (MAP f [])`
\end{verbatim}
}
\noindent and each resulting subgoal is just solved at once by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_REWRITE_TAC[MAP; o_THM]);;
\end{verbatim}
}

\COMMENTS
Essentially the same effect can be had by {\small\verb%MATCH_MP_TAC list_INDUCT%}. This does
not subsequently break down the goal in such a convenient way, but gives more
control over choice of variable. For example, starting with the same goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!l f:A->B g:B->C. MAP (g o f) l = MAP g (MAP f l)`;;
\end{verbatim}
}
\noindent we get:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MATCH_MP_TAC list_INDUCT);;
  val it : goalstack = 1 subgoal (1 total)

  `(!f g. MAP (g o f) [] = MAP g (MAP f [])) /\
   (!a0 a1.
        (!f g. MAP (g o f) a1 = MAP g (MAP f a1))
        ==> (!f g. MAP (g o f) (CONS a0 a1) = MAP g (MAP f (CONS a0 a1))))`
\end{verbatim}
}
\noindent and after getting rid of some trivia:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[MAP]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a0 a1.
       (!f g. MAP (g o f) a1 = MAP g (MAP f a1))
       ==> (!f g.
                CONS ((g o f) a0) (MAP (g o f) a1) =
                CONS (g (f a0)) (MAP g (MAP f a1)))`
\end{verbatim}
}
\noindent we can carefully choose the variable names:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MAP_EVERY X_GEN_TAC [`k:A`; `l:A list`]);;
  val it : goalstack = 1 subgoal (1 total)

  `(!f g. MAP (g o f) l = MAP g (MAP f l))
   ==> (!f g.
            CONS ((g o f) k) (MAP (g o f) l) =
            CONS (g (f k)) (MAP g (MAP f l)))`
\end{verbatim}
}
\noindent This kind of control can be useful when the sub-proof is more
challenging. Here of course the same simple pattern as before works:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SIMP_TAC[o_THM]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
INDUCT_TAC, MATCH_MP_TAC, WF_INDUCT_TAC.

\ENDDOC
\DOC{list{\_}mk{\_}abs}

\TYPE {\small\verb%list_mk_abs : term list * term -> term%}\egroup

\SYNOPSIS
Iteratively constructs abstractions.

\DESCRIBE
{\small\verb%list_mk_abs([`x1`;...;`xn`],`t`)%} returns {\small\verb%`\x1 ... xn. t`%}.

\FAILURE
Fails with {\small\verb%list_mk_abs%} if the terms in the list are not variables.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_abs([`m:num`; `n:num`],`m + n + 1`);;
  val it : term = `\m n. m + n + 1`
\end{verbatim}
}

\SEEALSO
dest_abs, mk_abs, strip_abs.

\ENDDOC
\DOC{list{\_}mk{\_}binop}

\TYPE {\small\verb%list_mk_binop : term -> term list -> term%}\egroup

\SYNOPSIS
Makes an iterative application of a binary operator.

\DESCRIBE
The call {\small\verb%list_mk_binop op [t1; ...; tn]%} constructs the term
{\small\verb%op t1 (op t2 (op ... (op tn-1 tn) ...)))%}. If we think of {\small\verb%op%} as an infix
operator we can write it {\small\verb%t1 op t2 op t3 ... op tn%}, but the call will work for
any term {\small\verb%op%} compatible with all the types.

\FAILURE
Fails if the list of terms is empty or if the types would not work for the
composite term. In particular, if the list contains at least three items, all
the types must be the same.

\EXAMPLE
This example is typical:
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_binop `(+):num->num->num` (map mk_small_numeral (1--10));;
  val it : term = `1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10`
\end{verbatim}
}
\noindent while these show that for smaller lists, one can just regard it as
{\small\verb%mk_comb%} or {\small\verb%mk_binop%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_binop `SUC` [`0`];;
  val it : term = `0`

   # list_mk_binop `f:A->B->C` [`x:A`; `y:B`];;
  val it : term = `f x y`
\end{verbatim}
}

\SEEALSO
binops, mk_binop.

\ENDDOC
\DOC{list{\_}mk{\_}comb}

\TYPE {\small\verb%list_mk_comb : term * term list -> term%}\egroup

\SYNOPSIS
Iteratively constructs combinations (function applications).

\DESCRIBE
{\small\verb%list_mk_comb(`t`,[`t1`;...;`tn`])%} returns {\small\verb%`t t1 ... tn`%}.

\FAILURE
Fails with {\small\verb%list_mk_comb%} if the types of {\small\verb%t1%},...,{\small\verb%tn%} are not equal to the
argument types of {\small\verb%t%}. It is not necessary for all the arguments of {\small\verb%t%} to be
given. In particular the list of terms {\small\verb%t1%},...,{\small\verb%tn%} may be empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_comb(`1`,[]);;
  val it : term = `1`

  # list_mk_comb(`(/\)`,[`T`]);;
  val it : term = `(/\) T`

  # list_mk_comb(`(/\)`,[`1`]);;
  Exception: Failure "mk_comb: types do not agree".
\end{verbatim}
}

\SEEALSO
list_mk_icomb, mk_comb, strip_comb.

\ENDDOC
\DOC{list{\_}mk{\_}conj}

\TYPE {\small\verb%list_mk_conj : term list -> term%}\egroup

\SYNOPSIS
Constructs the conjunction of a list of terms.

\DESCRIBE
{\small\verb%list_mk_conj([`t1`;...;`tn`])%} returns {\small\verb%`t1 /\ ... /\ tn`%}.

\FAILURE
Fails with {\small\verb%list_mk_conj%} if the list is empty or if the list has more than
one element, one or more of which are not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_conj [`T`;`F`;`T`];;
  val it : term = `T /\ F /\ T`

  # list_mk_conj [`T`;`1`;`F`];;
  Exception: Failure "mk_binary".

  # list_mk_conj [`1`];;
  val it : term = `1`
\end{verbatim}
}

\SEEALSO
conjuncts, mk_conj.

\ENDDOC
\DOC{list{\_}mk{\_}disj}

\TYPE {\small\verb%list_mk_disj : term list -> term%}\egroup

\SYNOPSIS
Constructs the disjunction of a list of terms.

\DESCRIBE
{\small\verb%list_mk_disj([`t1`;...;`tn`])%} returns {\small\verb%`t1 \/ ... \/ tn`%}.

\FAILURE
Fails with {\small\verb%list_mk_disj%} if the list is empty or if the list has more than
one element, one or more of which are not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_disj [`T`;`F`;`T`];;
  val it : term = `T \/ F \/ T`

  # list_mk_disj [`T`;`1`;`F`];;
  Exception: Failure "mk_binary".

  # list_mk_disj [`1`];;
  val it : term = `1`
\end{verbatim}
}

\SEEALSO
disjuncts, is_disj, mk_disj.

\ENDDOC
\DOC{list{\_}mk{\_}exists}

\TYPE {\small\verb%list_mk_exists : term list * term -> term%}\egroup

\SYNOPSIS
Multiply existentially quantifies both sides of an equation using the given
variables.

\DESCRIBE
When applied to a list of terms {\small\verb%[x1;...;xn]%}, where the {\small\verb%ti%} are all
variables, and a theorem {\small\verb%A |- t1 = t2%}, the inference rule
{\small\verb%LIST_MK_EXISTS%} existentially quantifies both sides of the equation
using the variables given, none of which should be free in the assumption
list.
{\par\samepage\setseps\small
\begin{verbatim}
              A |- t1 <=> t2
   ----------------------------------------  LIST_MK_EXISTS [`x1`;...;`xn`]
    A |- (?x1...xn. t1) <=> (?x1...xn. t2)
\end{verbatim}
}
\FAILURE
Fails if any term in the list is not a variable or is free in the assumption
list, or if the theorem is not equational.

\SEEALSO
EXISTS_EQ, MK_EXISTS.

\ENDDOC
\DOC{list{\_}mk{\_}forall}

\TYPE {\small\verb%list_mk_forall : term list * term -> term%}\egroup

\SYNOPSIS
Iteratively constructs a universal quantification.

\DESCRIBE
{\small\verb%list_mk_forall([`x1`;...;`xn`],`t`)%} returns {\small\verb%`!x1 ... xn. t`%}.

\FAILURE
Fails if any term in the list is not a variable or if {\small\verb%t%} is not of type
{\small\verb%`:bool`%} and the list of terms is non-empty. If the list of terms is empty the
type of {\small\verb%t%} can be anything.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_forall([`x:num`; `y:num`],`x + y + 1 = SUC z`);;
  val it : term = `!x y. x + y + 1 = SUC z`
\end{verbatim}
}

\SEEALSO
mk_forall, strip_forall.

\ENDDOC
\DOC{list{\_}mk{\_}gabs}

\TYPE {\small\verb%list_mk_gabs : term list * term -> term%}\egroup

\SYNOPSIS
Iteratively makes a generalized abstraction.

\DESCRIBE
The call {\small\verb%list_mk_gabs([vs1; ...; vsn],t)%} constructs an interated generalized
abstraction {\small\verb%\vs1. \vs2. ... \vsn. t%}. See {\small\verb%mk_gabs%} for more details on
constructing generalized abstractions.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_gabs([`(x:num,y:num)`; `(w:num,z:num)`],`x + w + 1`);;
  val it : term = `\(x,y). \(w,z). x + w + 1`
\end{verbatim}
}

\SEEALSO
dest_gabs, is_gabs, mk_gabs.

\ENDDOC
\DOC{list{\_}mk{\_}icomb}

\TYPE {\small\verb%list_mk_icomb : string -> term list -> term%}\egroup

\SYNOPSIS
Applies constant to list of arguments, instantiating constant type as needed.

\DESCRIBE
The call {\small\verb%list_mk_icomb "c" [a1; ...; an]%} will make the term {\small\verb%c a1 ... an%}
where c is a constant, after first instantiating {\small\verb%c%}'s generic type so that the
types are compatible.

\FAILURE
Fails if {\small\verb%c%} is not a constant or if the types cannot be instantiated to match
up with the argument list.

\EXAMPLE
This would fail with the basic {\small\verb%list_mk_comb%} function
{\par\samepage\setseps\small
\begin{verbatim}
  # list_mk_icomb "=" [`1`; `2`];;
  val it : term = `1 = 2`
\end{verbatim}
}

\COMMENTS
Note that in general the generic type of the constant is only instantiated
sufficiently to make its type match the arguments, which does not necessarily
determine it completely. Unless you are sure this will be sufficient, it is
safer and probably more efficient to instantiate the type manually using {\small\verb%inst%}
first.

\SEEALSO
list_mk_comb, mk_mconst, mk_icomb.

\ENDDOC
\DOC{LIST{\_}OF{\_}SEQ{\_}CONV}

\TYPE {\small\verb%LIST_OF_SEQ_CONV : conv%}\egroup

\SYNOPSIS
Evaluate the list construction function {\small\verb%list_of_seq%} on specific numeral.

\DESCRIBE
When applied to  a term {\small\verb%`list_of_seq f k`%} where {\small\verb%k%} is a specific
numeral, the conversion {\small\verb%LIST_OF_SEQ_CONV%} returns the appropriate
theorem {\small\verb%|- list_of_seq f k = [f 0; ...; f(k-1)]%}. If the function
{\small\verb%f%} is a lambda-abstraction, then beta-reduction will also be applied
to each term {\small\verb%f i%}.

\FAILURE
Fails if the term is not of the expected form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # LIST_OF_SEQ_CONV `list_of_seq (f:num->A) 3`;;
  val it : thm = |- list_of_seq f 3 = [f 0; f 1; f 2]

  # LIST_OF_SEQ_CONV `list_of_seq (\n. f n > 0) 3`;;
  val it : thm = |- list_of_seq (\n. f n > 0) 3 = [f 0 > 0; f 1 > 0; f 2 > 0]
\end{verbatim}
}

\SEEALSO
EL_CONV, LENGTH_CONV, LIST_CONV, REVERSE_CONV.

\ENDDOC
\DOC{loaded{\_}files}

\TYPE {\small\verb%loaded_files : (string * Digest.t) list ref%}\egroup

\SYNOPSIS
List of files loaded so far.

\DESCRIBE
This reference variable stores a list of previously loaded files together with
MD5 digests. It is updated by all the main loading functions {\small\verb%load_on_path%},
{\small\verb%loads%}, {\small\verb%loadt%} and {\small\verb%needs%}, and is used by {\small\verb%needs%} to avoid reloading the
same file multiple times.

\FAILURE
Not applicable.

\USES
Not really intended for average users to examine or modify.

\SEEALSO
load_on_path, loads, loadt, needs.

\ENDDOC
\DOC{loads}

\TYPE {\small\verb%loads : string -> unit%}\egroup

\SYNOPSIS
Load a file from the HOL Light system tree.

\DESCRIBE
Finds the named file, either by its absolute pathname or by starting in the
base of the HOL installation stored by {\small\verb%hol_dir%}, and loads it.

\FAILURE
Fails if the file is not found or generates an exception.

\EXAMPLE
To load a library with more number theory:
{\par\samepage\setseps\small
\begin{verbatim}
  # loads "Library/prime.ml";;
  - : unit = ()
  val ( MULT_MONO_EQ ) : thm = |- !m i n. SUC n * m = SUC n * i <=> m = i
  ...
  ...
  val ( GCD_CONV ) : term -> thm = <fun>
  val it : unit = ()
\end{verbatim}
}

\USES
Loading HOL Light standard libraries without accidentally picking up other
files of the same name in the current directory or on {\small\verb%load_path%}

\SEEALSO
load_path, loadt, needs.

\ENDDOC
\DOC{loadt}

\TYPE {\small\verb%loadt : string -> unit%}\egroup

\SYNOPSIS
Finds a file on the load path and loads it.

\DESCRIBE
The function {\small\verb%loadt%} takes a string indicating an OCaml file name as
argument and loads it. If the filename is relative, it is found on the load
path {\small\verb%load_path%}, and it is then loaded, updating the list of loaded files.

Additional paths can be added to {\small\verb%load_path%} by setting the
{\small\verb%HOLLIGHT_LOAD_PATH%} environment variable. Each path must be separated by
an OS-specific delimiter (':' for Unix and ';' for Windows).

\FAILURE
{\small\verb%loadt%} will fail if the file named by the argument does not exist in
the search path. It will of course fail if the file is not a valid OCaml
file. Failure in the OCaml file will also terminate loading.

\EXAMPLE
If we have an ML file called {\small\verb%foo.ml%} on the load path, e.g. in the current
directory, which contains the line
{\par\samepage\setseps\small
\begin{verbatim}
   let x=2+2;;
\end{verbatim}
}
\noindent this can be loaded as follows:
{\par\samepage\setseps\small
\begin{verbatim}
   # loadt "foo.ml";;
\end{verbatim}
}
\noindent and the system would respond with:
{\par\samepage\setseps\small
\begin{verbatim}
  # loadt "foo.ml";;
  val x : int = 4
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
load_path, loads, needs.

\ENDDOC
\DOC{load{\_}on{\_}path}

\TYPE {\small\verb%load_on_path : string list -> string -> unit%}\egroup

\SYNOPSIS
Finds a file on a path and loads it into HOL Light.

\DESCRIBE
When given a filename and a path, the file is found either directly by its
filename or on the given path, as explained in {\small\verb%file_on_path%}. An initial
dollar sign {\small\verb%$%} in each path is interpreted as a reference to the current
setting of {\small\verb%hol_dir%}. (To get an actual {\small\verb%$%} at the start of the filename,
actually use two dollar signs {\small\verb%$$%}.) It is then loaded into HOL, updating the
list of loaded files.

\FAILURE
Fails if the file is not found or generates an exception when loaded (e.g. a
syntax problem or runtime exception).

\SEEALSO
file_on_path, hol_expand_directory, load_path, loads, loadt, needs.

\ENDDOC
\DOC{load{\_}path}

\TYPE {\small\verb%load_path : string list ref%}\egroup

\SYNOPSIS
Path where HOL Light tries to find files to load.

\DESCRIBE
The reference variable {\small\verb%load_path%} gives a list of directories. When HOL loads
files with {\small\verb%loadt%}, it will try these places in order on all non-absolute
filenames. An initial dollar sign {\small\verb%$%} in each path is interpreted as a
reference to the current setting of {\small\verb%hol_dir%}. To get an actual {\small\verb%$%} character
at the start of the filename, use two dollar signs {\small\verb%$$%}.

Additional paths can be added to {\small\verb%load_path%} by setting the
{\small\verb%HOLLIGHT_LOAD_PATH%} environment variable. Each path must be separated by
an OS-specific delimiter (':' for Unix and ';' for Windows).

\FAILURE
Not applicable.

\SEEALSO
file_on_path, help_path, hol_dir, hol_expand_directory, load_on_path, loads,
loadt, needs.

\ENDDOC
\DOC{lookup}

\TYPE {\small\verb%lookup : term -> 'a net -> 'a list%}\egroup

\SYNOPSIS
Look up term in a term net.

\DESCRIBE
Term nets (type {\small\verb%'a net%}) are a lookup structure associating objects of type
{\small\verb%'a%}, e.g. conversions, with a corresponding `pattern' term. For a given term,
one can then relatively quickly look up all objects whose pattern terms might
possibly match to it. This is used, for example, in rewriting to quickly filter
out obviously inapplicable rewrites rather than attempting each one in turn.
The call {\small\verb%lookup t net%} for a term {\small\verb%t%} returns the list of objects whose
patterns might possibly be matchable to {\small\verb%t%}. Note that this is conservative: if
the pattern could be matched (even higher-order matched) in the sense of
{\small\verb%term_match%}, it will be in the list, but it is possible that some
non-matchable objects will be returned. (For example, a pattern term {\small\verb%x + x%}
will match any term of the form {\small\verb%a + b%}, even if {\small\verb%a%} and {\small\verb%b%} are the same.) It
is intended that nets are a first-level filter for efficiency; finer
discrimination may be embodied in the subsequent action with the list of
returned objects.

\FAILURE
Never fails.

\EXAMPLE
If we want to create ourselves the kind of automated rewriting with the basic
rewrites that is done by {\small\verb%REWRITE_CONV%}, we could simply try in succession all
the rewrites:
{\par\samepage\setseps\small
\begin{verbatim}
  # let BASIC_REWRITE_CONV' = FIRST_CONV (map REWR_CONV (basic_rewrites()));;
  val ( BASIC_REWRITE_CONV' ) : conv = <fun>
\end{verbatim}
}
However, it would be more efficient to use the left-hand sides as patterns
in a term net to organize the different rewriting conversions:
{\par\samepage\setseps\small
\begin{verbatim}
  # let rewr_net =
      let enter_thm th = enter (freesl(hyp th)) (lhs(concl th),REWR_CONV th) in
      itlist enter_thm (basic_rewrites()) empty_net;;
\end{verbatim}
}
Now given a term, we get only the items with matchable patterns, usually much
less than the full list:
{\par\samepage\setseps\small
\begin{verbatim}
  # lookup `(\x. x + 1) 2` rewr_net;;
  val it : (term -> thm) list = [<fun>]

  # lookup `T /\ T` rewr_net;;
  val it : (term -> thm) list = [<fun>; <fun>; <fun>]
\end{verbatim}
}
The three items returned in the last call are rewrites based on the theorems
{\small\verb%|- T /\ t <=> t%}, {\small\verb%|- t /\ T <=> t%} and {\small\verb%|- t /\ t <=> t%}, which are the only
ones matchable. We can use this net for a more efficient version of the same
conversion:
{\par\samepage\setseps\small
\begin{verbatim}
  # let BASIC_REWRITE_CONV tm = FIRST_CONV (lookup tm rewr_net) tm;;
  val ( BASIC_REWRITE_CONV ) : term -> conv = <fun>
\end{verbatim}
}
To see that it is indeed more efficient, consider:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = funpow 8 (fun x -> mk_conj(x,x)) `T`;;
  ...
  time (DEPTH_CONV BASIC_REWRITE_CONV) tm;;
  CPU time (user): 0.08
  ...
  time (DEPTH_CONV BASIC_REWRITE_CONV') tm;;
  CPU time (user): 1.121
  ...
\end{verbatim}
}

\SEEALSO
empty_net, enter, merge_nets.

\ENDDOC
\DOC{make{\_}args}

\TYPE {\small\verb%make_args : string -> term list -> hol_type list -> term list%}\egroup

\SYNOPSIS
Make a list of terms with stylized variable names

\DESCRIBE
The call {\small\verb%make_args "s" avoids [ty0; ...; tyn]%} constructs a list of variables
of types {\small\verb%ty0%}, ..., {\small\verb%tyn%}, normally called {\small\verb%s0%}, ..., {\small\verb%sn%} but primed if
necessary to avoid clashing with any in {\small\verb%avoids%}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # make_args "arg" [`arg2:num`] [`:num`; `:num`; `:num`];;
  val it : term list = [`arg0`; `arg1`; `arg2'`]
\end{verbatim}
}

\USES
Constructing arbitrary but relatively natural names for argument lists.

\SEEALSO
genvar, variant.

\ENDDOC
\DOC{make{\_}overloadable}

\TYPE {\small\verb%make_overloadable : string -> hol_type -> unit%}\egroup

\SYNOPSIS
Makes a symbol overloadable within the specified type skeleton.

\DESCRIBE
HOL Light allows the same identifier to denote several different underlying
constants, with the choice being determined by types and/or an order of
priority (see {\small\verb%prioritize_overload%}). However, any identifier {\small\verb%ident%} to be
overloaded must first be declared overloadable using
{\small\verb%make_overloadable "ident" `:ty`%}. The ``type skeleton'' argument {\small\verb%`:ty`%} is
the most general type that the various instances may have.

The type skeleton can simply be a type variable, in which case any type is
acceptable, but it is good practice to constrain it where possible to allow
more information to be inferred during typechecking. For example, the symbol
`{\small\verb%+%}' has the type skeleton {\small\verb%`:A->A->A`%} (as you can find out by examining the
list {\small\verb%the_overload_skeletons%}) indicating that it is always overloaded to a
binary operator that returns and element of the same type as its two arguments.

\FAILURE
Fails if the symbol has previously been made overloadable but with a different
type skeleton.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # make_overloadable "<=" `:A->A->bool`;;
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
overload_interface, override_interface, prioritize_overload, reduce_interface,
remove_interface, the_implicit_types, the_interface, the_overload_skeletons.

\ENDDOC
\DOC{many}

\TYPE {\small\verb%many : ('a -> 'b * 'a) -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Parses zero or more successive items using given parser.

\DESCRIBE
If {\small\verb%p%} is a parser then {\small\verb%many p%} gives a new parser that parses a series of
successive items using {\small\verb%p%} and returns the result as a list, with the expected
left-to-right order.

\FAILURE
The immediate call {\small\verb%many%} never fails. The resulting parser may fail when
applied, though any {\small\verb%Noparse%} exception in the core parser will be trapped.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, nothing,
possibly, rightbin, some.

\ENDDOC
\DOC{map}

\TYPE {\small\verb%map : ('a -> 'b) -> 'a list -> 'b list%}\egroup

\SYNOPSIS
Applies a function to every element of a list.

\DESCRIBE
{\small\verb%map f [x1;...;xn]%} returns {\small\verb%[(f x1);...;(f xn)]%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # map (fun x -> x * 2) [];;
  val it : int list = []
  # map (fun x -> x * 2) [1;2;3];;
  val it : int list = [2; 4; 6]
\end{verbatim}
}

\ENDDOC
\DOC{map2}

\TYPE {\small\verb%map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list%}\egroup

\SYNOPSIS
Maps a binary function over two lists to create one new list.

\DESCRIBE
{\small\verb%map2 f ([x1;...;xn],[y1;...;yn])%} returns {\small\verb%[f(x1,y1);...;f(xn,yn)]%}.

\FAILURE
Fails with {\small\verb%map2%} if the two lists are of different lengths.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # map2 (+) [1;2;3] [30;20;10];;
  val it : int list = [31; 22; 13]
\end{verbatim}
}

\SEEALSO
map, uncurry.

\ENDDOC
\DOC{mapf}

\TYPE {\small\verb%mapf : ('a -> 'b) -> ('c, 'a) func -> ('c, 'b) func%}\egroup

\SYNOPSIS
Maps a function over the range of a finite partial function

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The function {\small\verb%mapf f p%} applies the (ordinary OCaml) function {\small\verb%f%} to all
the range elements of a finite partial function, so if it originally mapped
{\small\verb%xi%} to {\small\verb%yi%} for it now maps {\small\verb%xi%} to {\small\verb%f(yi)%}.

\FAILURE
Fails if the function fails on one of the {\small\verb%yi%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = (1 |=> 2);;
  val f : (int, int) func = <func>
  # mapf string_of_int f;;
  val it : (int, string) func = <func>
  # apply it 1;;
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{mapfilter}

\TYPE {\small\verb%mapfilter : ('a -> 'b) -> 'a list -> 'b list%}\egroup

\SYNOPSIS
Applies a function to every element of a list, returning a list of results
for those elements for which application succeeds.

\FAILURE
Fails if an exception not of the form {\small\verb%Failure _%} is generated by any
application to the elements.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mapfilter hd [[1;2;3];[4;5];[];[6;7;8];[]];;
  val it : int list = [1; 4; 6]

  # mapfilter (fun (h::t) -> h) [[1;2;3];[4;5];[];[6;7;8];[]];;
  Warning: this pattern-matching is not exhaustive.
  Here is an example of a value that is not matched:
  []
  Exception: Match_failure ("", 24547, -35120).
\end{verbatim}
}

\SEEALSO
filter, map.

\ENDDOC
\DOC{MAP{\_}EVERY}

\TYPE {\small\verb%MAP_EVERY : ('a -> tactic) -> 'a list -> tactic%}\egroup

\SYNOPSIS
Sequentially applies all tactics given by mapping a function over a list.

\DESCRIBE
When applied to a tactic-producing function {\small\verb%f%} and an operand list
{\small\verb%[x1;...;xn]%}, the elements of which have the same type as {\small\verb%f%}'s domain type,
{\small\verb%MAP_EVERY%} maps the function {\small\verb%f%} over the list, producing a list of
tactics, then applies these tactics in sequence as in the case of {\small\verb%EVERY%}.
The effect is:
{\par\samepage\setseps\small
\begin{verbatim}
   MAP_EVERY f [x1;...;xn] = (f x1) THEN ... THEN (f xn)
\end{verbatim}
}
\noindent If the operand list is empty, then {\small\verb%MAP_EVERY%} has no effect.

\FAILURE
The application of {\small\verb%MAP_EVERY%} to a function and operand list fails iff
the function fails when applied to any element in the list. The
resulting tactic fails iff any of the resulting tactics fails.

\EXAMPLE
A convenient way of doing case analysis over several boolean variables is:
{\par\samepage\setseps\small
\begin{verbatim}
  MAP_EVERY BOOL_CASES_TAC [`v1:bool`;...;`vn:bool`]
\end{verbatim}
}

\SEEALSO
EVERY, FIRST, MAP_FIRST, THEN.

\ENDDOC
\DOC{MAP{\_}FIRST}

\TYPE {\small\verb%MAP_FIRST : ('a -> tactic) -> 'a list -> tactic%}\egroup

\SYNOPSIS
Applies first tactic that succeeds in a list given by mapping a function over a
list.

\DESCRIBE
When applied to a tactic-producing function {\small\verb%f%} and an operand list
{\small\verb%[x1;...;xn]%}, the elements of which have the same type as {\small\verb%f%}'s domain
type, {\small\verb%MAP_FIRST%} maps the function {\small\verb%f%} over the list, producing a list of
tactics, then tries applying these tactics to the goal till one succeeds.
If {\small\verb%f(xm)%} is the first to succeed, then the overall effect is the same
as applying {\small\verb%f(xm)%}. Thus:
{\par\samepage\setseps\small
\begin{verbatim}
   MAP_FIRST f [x1;...;xn] = (f x1) ORELSE ... ORELSE (f xn)
\end{verbatim}
}

\FAILURE
The application of {\small\verb%MAP_FIRST%} to a function and tactic list fails iff
the function does when applied to any of the elements of the list. The
resulting tactic fails iff all the resulting tactics fail when
applied to the goal.

\EXAMPLE
Using the definition of integer-valued real numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  # needs "Library/floor.ml";;
\end{verbatim}
}
\noindent we have a set of `composition' theorems asserting that the predicate
is closed under various arithmetic operations:
{\par\samepage\setseps\small
\begin{verbatim}
  # INTEGER_CLOSED;;
  val it : thm =
    |- (!n. integer (&n)) /\
       (!x y. integer x /\ integer y ==> integer (x + y)) /\
       (!x y. integer x /\ integer y ==> integer (x - y)) /\
       (!x y. integer x /\ integer y ==> integer (x * y)) /\
       (!x r. integer x ==> integer (x pow r)) /\
       (!x. integer x ==> integer (--x)) /\
       (!x. integer x ==> integer (abs x))
\end{verbatim}
}
\noindent if we want to prove that some composite term has integer type:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `integer(x) /\ integer(y)
       ==> integer(&2 * (x - &1) pow 7 + &11 * (y + &1))`;;
  ...
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`integer x`]
   1 [`integer y`]

  `integer (&2 * (x - &1) pow 7 + &11 * (y + &1))`
\end{verbatim}
}
A direct proof using {\small\verb%ASM_MESON_TAC[INTEGER_CLOSED]%} works fine. However if we
want to control the application of composition theorems more precisely we
might do:
{\par\samepage\setseps\small
\begin{verbatim}
  # let INT_CLOSURE_TAC =
      MAP_FIRST MATCH_MP_TAC (CONJUNCTS(CONJUNCT2 INTEGER_CLOSED)) THEN
      TRY CONJ_TAC;;
\end{verbatim}
}
\noindent and then could solve the goal by:
{\par\samepage\setseps\small
\begin{verbatim}
  e(REPEAT INT_CLOSURE_TAC THEN ASM_REWRITE_TAC[CONJUNCT1 INTEGER_CLOSED]);;
\end{verbatim}
}

\SEEALSO
EVERY, FIRST, MAP_EVERY, ORELSE.

\ENDDOC
\DOC{MATCH{\_}ACCEPT{\_}TAC}

\TYPE {\small\verb%MATCH_ACCEPT_TAC : thm_tactic%}\egroup

\SYNOPSIS
Solves a goal which is an instance of the supplied theorem.

\DESCRIBE
When given a theorem {\small\verb%A' |- t%} and a goal {\small\verb%A ?- t'%} where {\small\verb%t%} can be matched
to {\small\verb%t'%} by instantiating variables which are either free or
universally quantified at the outer level, including appropriate type
instantiation, {\small\verb%MATCH_ACCEPT_TAC%} completely solves the goal.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t'
   =========  MATCH_ACCEPT_TAC (A' |- t)

\end{verbatim}
}
\noindent Unless {\small\verb%A'%} is a subset of {\small\verb%A%}, this is an invalid tactic.

\FAILURE
Fails unless the theorem has a conclusion which is instantiable to match that
of the goal.

\EXAMPLE
The following example shows variable and type instantiation at work. Suppose we
have the following simple goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `HD [1;2] = 1`;;
\end{verbatim}
}
\noindent we can do it via the polymorphic theorem
{\small\verb%HD = |- !h t. HD(CONS h t) = h%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MATCH_ACCEPT_TAC HD);;
\end{verbatim}
}

\SEEALSO
ACCEPT_TAC.

\ENDDOC
\DOC{MATCH{\_}CONV}

\TYPE {\small\verb%MATCH_CONV : term -> thm%}\egroup

\SYNOPSIS
Expands application of pattern-matching construct to particular case.

\DESCRIBE
The conversion {\small\verb%MATCH_CONV%} will reduce the application of a pattern to a
specific argument, either for a term {\small\verb%match x with ...%} or {\small\verb%(function ...) x%}.
In the case of a sequential pattern, the first match will be reduced, resulting
either in a conditional expression or simply one of the cases if it can be
deduced just from the pattern. In the case of a single pattern, it will be
reduced immediately.

\FAILURE
{\small\verb%MATCH_CONV tm%} fails if {\small\verb%tm%} is neither of the two applications of a pattern
to an argument.

\EXAMPLE
In cases where the structure of the argument determines the match, a complete
reduction is performed:
{\par\samepage\setseps\small
\begin{verbatim}
  # MATCH_CONV `match [1;2;3;4;5] with CONS x (CONS y z) -> z`;;
  val it : thm =
    |- (match [1; 2; 3; 4; 5] with CONS x (CONS y z) -> z) = [3; 4; 5]
\end{verbatim}
}
\noindent However, only one reduction is performed for a sequential match:
{\par\samepage\setseps\small
\begin{verbatim}
  # MATCH_CONV `(function [] -> 0 | CONS h t -> h + 1) [1;2;3;4]`;;
  val it : thm =
    |- (function [] -> 0 | CONS h t -> h + 1) [1; 2; 3; 4] =
       (function CONS h t -> h + 1) [1; 2; 3; 4]
\end{verbatim}
}
\noindent so the conversion may need to be repeated:
{\par\samepage\setseps\small
\begin{verbatim}
  # TOP_DEPTH_CONV MATCH_CONV
     `(function [] -> 0 | CONS h t -> h + 1) [1;2;3;4]`;;
  val it : thm = |- (function [] -> 0 | CONS h t -> h + 1) [1; 2; 3; 4] = 1 + 1
\end{verbatim}
}
\noindent In cases where the structure of the argument cannot be determined, a
conditional expression or other more involved result may be returned:
{\par\samepage\setseps\small
\begin{verbatim}
  # MATCH_CONV `(function [] -> 0 | CONS h t -> h + 1) l`;;
  val it : thm =
    |- (function [] -> 0 | CONS h t -> h + 1) l =
       (if [] = l then (function [] -> 0) l else (function CONS h t -> h + 1) l)
\end{verbatim}
}

\COMMENTS
The simple cases where the structure completely determines the result are built
into the default rewrites, though nothing will happen in more general cases,
even if the conditions can be discharged straightforwardly, e.g:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_CONV[] `match [1;2;3] with CONS h t when h = 1  -> h + LENGTH t`;;
  val it : thm =
    |- (match [1; 2; 3] with CONS h t when h = 1 -> h + LENGTH t) =
       1 + LENGTH [2; 3]
  # REWRITE_CONV[] `match [1;2;3] with CONS h t when h < 7 -> h + LENGTH t`;;
  val it : thm =
    |- (match [1; 2; 3] with CONS h t when h < 7 -> h + LENGTH t) =
       (match [1; 2; 3] with CONS h t when h < 7 -> h + LENGTH t)
\end{verbatim}
}

\SEEALSO
BETA_CONV, GEN_BETA_CONV.

\ENDDOC
\DOC{MATCH{\_}MP}

\TYPE {\small\verb%MATCH_MP : thm -> thm -> thm%}\egroup

\SYNOPSIS
Modus Ponens inference rule with automatic matching.

\DESCRIBE
When applied to theorems {\small\verb%A1 |- !x1...xn. t1 ==> t2%} and {\small\verb%A2 |- t1'%}, the
inference rule {\small\verb%MATCH_MP%} matches {\small\verb%t1%} to {\small\verb%t1'%} by instantiating free or
universally quantified variables in the first theorem (only), and returns a
theorem {\small\verb%A1 u A2 |- !xa..xk. t2'%}, where {\small\verb%t2'%} is a correspondingly
instantiated version of {\small\verb%t2%}. Polymorphic types are also instantiated if
necessary.

Variables free in the consequent but not the antecedent of the first argument
theorem will be replaced by variants if this is necessary to maintain the full
generality of the theorem, and any which were universally quantified over in
the first argument theorem will be universally quantified over in the result,
and in the same order.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- !x1..xn. t1 ==> t2   A2 |- t1'
   --------------------------------------  MATCH_MP
          A1 u A2 |- !xa..xk. t2'
\end{verbatim}
}

\FAILURE
Fails unless the first theorem is a (possibly repeatedly universally
quantified) implication whose antecedent can be instantiated to match
the conclusion of the second theorem, without instantiating any variables
which are free in {\small\verb%A1%}, the first theorem's assumption list.

\EXAMPLE
In this example, automatic renaming occurs to maintain the most general form of
the theorem, and the variant corresponding to {\small\verb%z%} is universally quantified
over, since it was universally quantified over in the first argument theorem.
{\par\samepage\setseps\small
\begin{verbatim}
  # let ith = ARITH_RULE `!x z:num. x = y ==> (w + z) + x = (w + z) + y`;;
  val ith : thm = |- !x z. x = y ==> (w + z) + x = (w + z) + y

  # let th = ASSUME `w:num = z`;;
  val th : thm = w = z |- w = z

  # MATCH_MP ith th;;
  val it : thm = w = z |- !z'. (w + z') + w = (w + z') + z
\end{verbatim}
}

\SEEALSO
EQ_MP, MATCH_MP_TAC, MP, MP_TAC.

\ENDDOC
\DOC{MATCH{\_}MP{\_}TAC}

\TYPE {\small\verb%MATCH_MP_TAC : thm_tactic%}\egroup

\SYNOPSIS
Reduces the goal using a supplied implication, with matching.

\DESCRIBE
When applied to a theorem of the form
{\par\samepage\setseps\small
\begin{verbatim}
   A' |- !x1...xn. s ==> t
\end{verbatim}
}
\noindent {\small\verb%MATCH_MP_TAC%} produces a tactic that reduces a goal whose conclusion
{\small\verb%t'%} is a substitution and/or type instance of {\small\verb%t%} to the corresponding
instance of {\small\verb%s%}. Any variables free in {\small\verb%s%} but not in {\small\verb%t%} will be existentially
quantified in the resulting subgoal:
{\par\samepage\setseps\small
\begin{verbatim}
     A ?- t'
  ======================  MATCH_MP_TAC (A' |- !x1...xn. s ==> t)
     A ?- ?z1...zp. s'
\end{verbatim}
}
\noindent where {\small\verb%z1%}, ..., {\small\verb%zp%} are (type instances of) those variables among
{\small\verb%x1%}, ..., {\small\verb%xn%} that do not occur free in {\small\verb%t%}. Note that this is not a valid
tactic unless {\small\verb%A'%} is a subset of {\small\verb%A%}.

\EXAMPLE
The following goal might be solved by case analysis:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!n:num. n <= n * n`;;
\end{verbatim}
}
We can ``manually'' perform induction by using the following theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # num_INDUCTION;;
  val it : thm = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
\end{verbatim}
}
\noindent which is useful with {\small\verb%MATCH_MP_TAC%} because of higher-order matching:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MATCH_MP_TAC num_INDUCTION);;
  val it : goalstack = 1 subgoal (1 total)

  `0 <= 0 * 0 /\ (!n. n <= n * n ==> SUC n <= SUC n * SUC n)`
\end{verbatim}
}
\noindent The goal can be finished with {\small\verb%ARITH_TAC%}.

\FAILURE
Fails unless the theorem is an (optionally universally quantified) implication
whose consequent can be instantiated to match the goal.

\SEEALSO
EQ_MP, MATCH_MP, MP, MP_TAC, PART_MATCH, TRANS_TAC.

\ENDDOC
\DOC{mem}

\TYPE {\small\verb%mem : 'a -> 'a list -> bool%}\egroup

\SYNOPSIS
Tests whether a list contains a certain member.

\DESCRIBE
{\small\verb%mem x [x1;...;xn]%} returns {\small\verb%true%} if some {\small\verb%xi%} in the list is equal to {\small\verb%x%}.
Otherwise it returns {\small\verb%false%}.

\FAILURE
Never fails.

\SEEALSO
find, tryfind, exists, forall, assoc, rev_assoc.

\ENDDOC
\DOC{mem'}

\TYPE {\small\verb%mem' : ('a -> 'b -> bool) -> 'a -> 'b list -> bool%}\egroup

\SYNOPSIS
Tests if an element is equivalent to a member of a list w.r.t. some relation.

\DESCRIBE
If {\small\verb%r%} is a binary relation, {\small\verb%x%} an element and {\small\verb%l%} a list, the call
{\small\verb%mem' r x l%} tests if there is an element in the list {\small\verb%l%} that is equivalent to
{\small\verb%x%} according to {\small\verb%r%}, that is, if {\small\verb%r x x'%} holds for some {\small\verb%x'%} in {\small\verb%l%}. The
function {\small\verb%mem%} is the special case where the relation is equality.

\FAILURE
Fails only if the relation {\small\verb%r%} fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mem' (fun x y -> abs(x) = abs(y)) (-1) [1;2;3];;
  val it : bool = true
  # mem' (fun x y -> abs(x) = abs(y)) (-1) [2;3;4];;
  val it : bool = false
\end{verbatim}
}

\USES
Set operations modulo some equivalence such as alpha-equivalence.

\SEEALSO
insert', mem, subtract', union', unions'.

\ENDDOC
\DOC{merge}

\TYPE {\small\verb%merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Merges together two sorted lists with respect to a given ordering.

\DESCRIBE
If two lists {\small\verb%l1%} and {\small\verb%l2%} are sorted with respect to the given ordering {\small\verb%ord%},
then {\small\verb%merge ord l1 l2%} will merge them into a sorted list of all the elements.
The merge keeps any duplicates; it is not a set operation.

\FAILURE
Never fails, but if the lists are not appropriately sorted the results will not
in general be correct.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # merge (<) [1;2;3;4;5;6] [2;4;6;8];;
  val it : int list = [1; 2; 2; 3; 4; 4; 5; 6; 6; 8]
\end{verbatim}
}

\SEEALSO
mergesort, sort, uniq.

\ENDDOC
\DOC{mergesort}

\TYPE {\small\verb%mergesort : ('a -> 'a -> bool) -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Sorts the list with respect to given ordering using mergesort algorithm.

\DESCRIBE
If {\small\verb%ord%} is a total order, a call {\small\verb%mergesort ord l%} will sort the list {\small\verb%l%}
according to the order {\small\verb%ord%}. It works internally by a mergesort algorithm.
From a user's point of view, this just means: (i) its worst-case performance is
much better than {\small\verb%sort%}, which uses quicksort, but (ii) it will not reliably
topologically sort for a non-total order, whereas {\small\verb%sort%} will.

\FAILURE
Never fails unless the ordering function fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mergesort (<) [6;2;5;9;2;5;3];;
  val it : int list = [2; 2; 3; 5; 5; 6; 9]
\end{verbatim}
}

\SEEALSO
merge, sort.

\ENDDOC
\DOC{merge{\_}nets}

\TYPE {\small\verb%merge_nets : 'a net * 'a net -> 'a net%}\egroup

\SYNOPSIS
Merge together two term nets.

\DESCRIBE
Term nets (type {\small\verb%'a net%}) are a lookup structure associating objects of type
{\small\verb%'a%}, e.g. conversions, with a corresponding `pattern' term. For a given term,
one can then relatively quickly look up all objects whose pattern terms might
possibly match to it. This is used, for example, in rewriting to quickly filter
out obviously inapplicable rewrites rather than attempting each one in turn.
The call {\small\verb%merge_nets(net1,net2)%} merges two nets together; the list of objects
is the union of those objects in the two nets {\small\verb%net1%} and {\small\verb%net2%}, with the term
patterns adjusted appropriately.

\FAILURE
Never fails.

\EXAMPLE
If we have one term net containing the addition conversion:
{\par\samepage\setseps\small
\begin{verbatim}
  # let net1 = enter [] (`x + y`,NUM_ADD_CONV) empty_net;;
  ...
\end{verbatim}
}
\noindent and another with beta-conversion:
{\par\samepage\setseps\small
\begin{verbatim}
  # let net2 = enter [] (`(\x. t) y`,BETA_CONV) empty_net;;
  ...
\end{verbatim}
}
\noindent we can combine them into a single net:
{\par\samepage\setseps\small
\begin{verbatim}
  # let net = merge_nets(net1,net2);;
  ...
\end{verbatim}
}

\SEEALSO
empty_net, enter, lookup.

\ENDDOC
\DOC{MESON}

\TYPE {\small\verb%MESON : thm list -> term -> thm%}\egroup

\SYNOPSIS
Attempt to prove a term by first-order proof search.

\DESCRIBE
A call {\small\verb%MESON[theorems] `tm`%} will attempt to prove {\small\verb%tm%} using pure first-order
reasoning, taking {\small\verb%theorems%} as the starting-point. It will usually either
solve it completely or run for an infeasible length of time before terminating,
but it may sometimes fail quickly.

Although {\small\verb%MESON%} is capable of some fairly non-obvious pieces of first-order
reasoning, and will handle equality adequately, it does purely logical
reasoning. It will exploit no special properties of the constants in the goal,
other than equality and logical primitives. Any properties that are needed must
be supplied explicitly in the theorem list, e.g. {\small\verb%LE_REFL%} to tell it that {\small\verb%<=%}
on natural numbers is reflexive, or {\small\verb%REAL_ADD_SYM%} to tell it that addition on
real numbers is symmetric.

For more challenging first-order problems the related {\small\verb%METIS%} rule often
performs better.

\FAILURE
Will fail if the term is not provable, but not necessarily in a feasible amount
of time.

\EXAMPLE
A typical application is to prove some elementary logical lemma for use inside
a tactic proof:
{\par\samepage\setseps\small
\begin{verbatim}
  # MESON[] `!P. P F /\ P T ==> !x. P x`;;
  ...
  val it : thm = |- !P. P F /\ P T ==> (!x. P x)
\end{verbatim}
}
To prove the following lemma, we need to provide the key property of real
negation:
{\par\samepage\setseps\small
\begin{verbatim}
  # MESON[REAL_NEG_NEG] `(!x. P(--x)) ==> !x:real. P x`;;
  ...
  val it : thm = |- (!x. P (--x)) ==> (!x. P x)
\end{verbatim}
}
\noindent If the lemma is not supplied, {\small\verb%MESON%} will fail:
{\par\samepage\setseps\small
\begin{verbatim}
  # MESON[] `(!x. P(--x)) ==> !x:real. P x`;;
  ...
  Exception: Failure "solve_goal: Too deep".
\end{verbatim}
}
{\small\verb%MESON%} is also capable of proving less straightforward results; see the
documentation for {\small\verb%MESON_TAC%} to find more examples.

\USES
Generating simple logical lemmas as part of a large proof.

\SEEALSO
ASM_MESON_TAC, GEN_MESON_TAC, LEANCOP, MESON_TAC, METIS, NANOCOP.

\ENDDOC
\DOC{meson{\_}brand}

\TYPE {\small\verb%meson_brand : bool ref%}\egroup

\SYNOPSIS
Makes {\small\verb%MESON%} handle equations using Brand's transformation.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. When {\small\verb%meson_brand%} is {\small\verb%true%},
equations are handled inside {\small\verb%MESON%} by applying Brand's transformation. When
it is {\small\verb%false%}, as it is by default, equations are handled in a more ``naive''
way, which nevertheless appears generally better.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\COMMENTS
For more details of Brand's modification, see his paper ``Proving theorems with
the modification method'', SIAM Journal on Computing volume 4, 1975.
See also Moser and Steinbach's Munich technical report ``STE-modification
revisited'' (AR-97-03, 1997) for another look at the subject.

\SEEALSO
meson_chatty, meson_dcutin, meson_depth, meson_prefine, meson_skew,
meson_split_limit,

\ENDDOC
\DOC{meson{\_}chatty}

\TYPE {\small\verb%meson_chatty : bool ref%}\egroup

\SYNOPSIS
Make {\small\verb%MESON%}'s output more verbose and detailed.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. When {\small\verb%meson_chatty%} is set to
{\small\verb%true%}, {\small\verb%MESON%} provides more verbose output, reporting at each level of
iterative deepening search the current size limit and number of inferences on a
fresh line. When {\small\verb%meson_chatty%} is {\small\verb%false%}, as it is by default, the core
inference numbers are condensed into 1-line output.

\FAILURE
Not applicable.

\SEEALSO
copverb, meson_brand, meson_dcutin, meson_depth, meson_prefine, meson_skew,
meson_split_limit, MESON, MESON_TAC, metisverb.

\ENDDOC
\DOC{meson{\_}dcutin}

\TYPE {\small\verb%meson_dcutin : int ref%}\egroup

\SYNOPSIS
Determines cut-in point for divide-and-conquer refinement in {\small\verb%MESON%}.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. This number (by default 1)
determines the number of current subgoals at which point a special
divide-and-conquer refinement will be invoked.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\COMMENTS
For more details of this optimization, see Harrison's paper ``Optimizing
Proof Search in Model Elimination'', CADE-13, 1996.

\SEEALSO
meson_brand, meson_chatty, meson_depth, meson_prefine, meson_skew,
meson_split_limit,

\ENDDOC
\DOC{meson{\_}depth}

\TYPE {\small\verb%meson_depth : bool ref%}\egroup

\SYNOPSIS
Make {\small\verb%MESON%}'s search algorithm work by proof depth rather than size.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. The basic search strategy is
iterated deepening, searching for proofs with higher and higher limits on the
search space. The flag {\small\verb%meson_depth%}, when set to {\small\verb%true%}, limits the search
space based on proof depth, i.e. the longest branch. When set to {\small\verb%false%}, as it
is by default, the proof is limited based on total size.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\SEEALSO
meson_brand, meson_chatty, meson_dcutin, meson_prefine, meson_skew,
meson_split_limit,

\ENDDOC
\DOC{meson{\_}prefine}

\TYPE {\small\verb%meson_prefine : bool ref%}\egroup

\SYNOPSIS
Makes {\small\verb%MESON%} apply Plaisted's positive refinement.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. When the flag {\small\verb%meson_prefine%} is
{\small\verb%true%}, as it is by default, Plaisted's ``positive refinement'' is used in
proof search; this limits the search space at the cost of sometimes requiring
longer proofs. When {\small\verb%meson_prefine%} is false, this refinement is not applied.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\COMMENTS
For more details, see Plaisted's article ``A Sequent-Style Model Elimination
Strategy and a Positive Refinement'', Journal of Automated Reasoning volume 6,
1990.

\SEEALSO
meson_brand, meson_chatty, meson_dcutin, meson_depth, meson_skew,
meson_split_limit,

\ENDDOC
\DOC{meson{\_}skew}

\TYPE {\small\verb%meson_skew : int ref%}\egroup

\SYNOPSIS
Determines skew in {\small\verb%MESON%} proof tree search limits.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. During search, {\small\verb%MESON%} successively
searches for proofs of larger and larger `size'. The ``skew'' value determines
what proportion of the entire proof size is permitted in the left-hand half of
the list of subgoals. The symmetrical value is {\small\verb%2%} (meaning one half), the
default setting of {\small\verb%3%} (one third) seems generally better because it can cut
down on redundancy in proofs.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\COMMENTS
For more details of {\small\verb%MESON%}'s search strategy, see Harrison's paper
``Optimizing Proof Search in Model Elimination'', CADE-13, 1996.

\SEEALSO
meson_brand, meson_chatty, meson_dcutin, meson_depth, meson_prefine,
meson_split_limit,

\ENDDOC
\DOC{meson{\_}split{\_}limit}

\TYPE {\small\verb%meson_split_limit : int ref%}\egroup

\SYNOPSIS
Limit initial case splits before {\small\verb%MESON%} proper is applied.

\DESCRIBE
This is one of several parameters determining the behavior of {\small\verb%MESON%},
{\small\verb%MESON_TAC%} and related rules and tactics. Before these rules or tactics are
applied, the formula to be proved is often decomposed by splitting, for example
an equivalence {\small\verb%p <=> q%} to two separate implications {\small\verb%p ==> q%} and {\small\verb%q ==> p%}.
This often makes the eventual proof much easier for {\small\verb%MESON%}. On the other hand,
if splitting is applied too many times, it can become inefficient. The value
{\small\verb%meson_split_limit%} (default {\small\verb%8%}) is the maximum number of times that splitting
can be applied before {\small\verb%MESON%} proper.

\FAILURE
Not applicable.

\USES
For users requiring fine control over the algorithms used in {\small\verb%MESON%}'s
first-order proof search.

\SEEALSO
meson_brand, meson_chatty, meson_dcutin, meson_depth, meson_prefine,
meson_skew.

\ENDDOC
\DOC{MESON{\_}TAC}

\TYPE {\small\verb%MESON_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic.

\DESCRIBE
A call to {\small\verb%MESON_TAC[theorems]%} will attempt to establish the current goal
using pure first-order reasoning, taking {\small\verb%theorems%} as the starting-point. (It
does not take the assumptions of the goal into account, but the similar
function {\small\verb%ASM_MESON_TAC%} does.) It will usually either solve the goal
completely or run for an infeasible length of time before terminating, but it
may sometimes fail quickly.

Although {\small\verb%MESON_TAC%} is capable of some fairly non-obvious pieces of
first-order reasoning, and will handle equality adequately, it does purely
logical reasoning. It will exploit no special properties of the constants in
the goal, other than equality and logical primitives. Any properties that are
needed must be supplied explicitly in the theorem list, e.g. {\small\verb%LE_REFL%} to tell
it that {\small\verb%<=%} on natural numbers is reflexive, or {\small\verb%REAL_ADD_SYM%} to tell it that
addition on real numbers is symmetric.

For more challenging first-order problems, {\small\verb%METIS_TAC%} may be recommended.

\FAILURE
Fails if the goal is unprovable within the search bounds, though not
necessarily in a feasible amount of time.

\EXAMPLE
Here is a simple logical property taken from Dijstra's EWD 1062-1, which we set
as our goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!x. x <= x) /\
       (!x y z. x <= y /\ y <= z ==> x <= z) /\
       (!x y. f(x) <= y <=> x <= g(y))
       ==> (!x y. x <= y ==> f(x) <= f(y))`;;
\end{verbatim}
}
It is solved quickly by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MESON_TAC[]);;
  0..0..1..3..8..17..solved at 25
  CPU time (user): 0.
  val it : goalstack = No subgoals
\end{verbatim}
}
Note however that the proof did not rely on any special features of `{\small\verb%<=%}'; any
binary relation symbol would have worked. Even simple proofs that rely on
special properties of the constants need to have those properties supplied in
the list. Note also that {\small\verb%MESON%} is limited to essentially first-order
reasoning, meaning that it cannot invent higher-order quantifier
instantiations. Thus, it cannot prove the following, which involves a
quantification over a function {\small\verb%g%}:
{\par\samepage\setseps\small
\begin{verbatim}
 # g `!f:A->B s.
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) <=>
        (?g. !x. x IN s ==> (g(f(x)) = x))`;;
\end{verbatim}
}
\noindent However, we can manually reduce it to two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN MATCH_MP_TAC EQ_TRANS THEN
      EXISTS_TAC `?g:B->A. !y x. x IN s /\ y = f x ==> g y = x` THEN
      CONJ_TAC THENL
       [REWRITE_TAC[GSYM SKOLEM_THM]; AP_TERM_TAC THEN ABS_TAC]);;
  val it : goalstack = 2 subgoals (2 total)

  `(!y x. x IN s /\ y = f x ==> g y = x) <=> (!x. x IN s ==> g (f x) = x)`

  `(!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) <=>
   (!y. ?g. !x. x IN s /\ y = f x ==> g = x)`
\end{verbatim}
}
\noindent and both of those are solvable directly by {\small\verb%MESON_TAC[]%}.

\SEEALSO
ASM_MESON_TAC, GEN_MESON_TAC, LEANCOP_TAC, MESON, METIS_TAC, NANOCOP_TAC.

\ENDDOC
\DOC{META{\_}EXISTS{\_}TAC}

\TYPE {\small\verb%META_EXISTS_TAC : (string * thm) list * term -> goalstate%}\egroup

\SYNOPSIS
Changes existentially quantified variable to metavariable.

\DESCRIBE
Given a goal of the form {\small\verb%A ?- ?x. t[x]%}, the tactic {\small\verb%X_META_EXISTS_TAC%} gives
the new goal {\small\verb%A ?- t[x]%} where {\small\verb%x%} is a new metavariable. In the resulting
proof, it is as if the variable has been assigned here to the later choice for
this metavariable, which can be made through for example {\small\verb%UNIFY_ACCEPT_TAC%}.

\FAILURE
Never fails.

\EXAMPLE
See {\small\verb%UNIFY_ACCEPT_TAC%} for an example of using metavariables.

\USES
Delaying instantiations until the correct term becomes clearer.

\COMMENTS
Users should probably steer clear of using metavariables if possible. Note that
the metavariable instantiations apply across the whole fringe of goals, not
just the current goal, and can lead to confusion.

\SEEALSO
EXISTS_TAC, META_SPEC_TAC, UNIFY_ACCEPT_TAC, X_META_EXISTS_TAC.

\ENDDOC
\DOC{META{\_}SPEC{\_}TAC}

\TYPE {\small\verb%META_SPEC_TAC : term -> thm -> tactic%}\egroup

\SYNOPSIS
Replaces universally quantified variable in theorem with metavariable.

\DESCRIBE
Given a variable {\small\verb%v%} and a theorem {\small\verb%th%} of the form {\small\verb%A |- !x. p[x]%}, the
tactic {\small\verb%META_SPEC_TAC `v` th%} is a tactic that adds the theorem {\small\verb%A |- p[v]%} to
the assumptions of the goal, with {\small\verb%v%} a new metavariable. This can later be
instantiated, e.g. by {\small\verb%UNIFY_ACCEPT_TAC%}, and it is as if the instantiation
were done at this point.

\FAILURE
Fails if {\small\verb%v%} is not a variable.

\EXAMPLE
See {\small\verb%UNIFY_ACCEPT_TAC%} for an example of using metavariables.

\USES
Delaying instantiations until the right choice becomes clearer.

\COMMENTS
Users should probably steer clear of using metavariables if possible. Note that
the metavariable instantiations apply across the whole fringe of goals, not
just the current goal, and can lead to confusion.

\SEEALSO
EXISTS_TAC, EXISTS_TAC, UNIFY_ACCEPT_TAC, X_META_EXISTS_TAC.

\ENDDOC
\DOC{METIS}

\TYPE {\small\verb%METIS : thm list -> term -> thm%}\egroup

\SYNOPSIS
Attempt to prove a term by first-order proof search using Metis algorithm.

\DESCRIBE
A call {\small\verb%METIS[theorems] `tm`%} will attempt to prove {\small\verb%tm%} using pure first-order
reasoning, taking {\small\verb%theorems%} as the starting-point. It will usually either
prove it completely or run for an infeasibly long time, but it may sometimes
fail quickly.

Although {\small\verb%METIS%} is capable of some fairly non-obvious pieces of first-order
reasoning, and will handle equality adequately, it does purely logical
reasoning. It will exploit no special properties of the constants in the goal,
other than equality and logical primitives. Any properties that are needed must
be supplied explicitly in the theorem list, e.g. {\small\verb%LE_REFL%} to tell it that {\small\verb%<=%}
on natural numbers is reflexive, or {\small\verb%REAL_ADD_SYM%} to tell it that addition on
real numbers is symmetric.

Sometimes the similar {\small\verb%MESON%} rule is faster, especially on simpler problems.

\FAILURE
Fails if the term is unprovable within the search bounds.

\EXAMPLE
A typical application is to prove some elementary logical lemma for use inside
a tactic proof:
{\par\samepage\setseps\small
\begin{verbatim}
  # METIS[num_CASES] `(!n. P n) <=> P 0 /\ (!n. P (SUC n))`;;
\end{verbatim}
}

\USES
Generating simple logical lemmas as part of a large proof.

\SEEALSO
ASM_METIS_TAC, LEANCOP, MESON, METIS_TAC, NANOCOP.

\ENDDOC
\DOC{metisverb}

\TYPE {\small\verb%metisverb : bool ref%}\egroup

\SYNOPSIS
Make {\small\verb%METIS%}'s output more verbose and detailed.

\DESCRIBE
When this reference variable is set to {\small\verb%true%}, it makes any applications of
{\small\verb%METIS%}, {\small\verb%METIS_TAC%} and related rules and tactics provide more verbose output
about their working.

\FAILURE
Not applicable.

\SEEALSO
meson_chatty.ml

\ENDDOC
\DOC{METIS{\_}TAC}

\TYPE {\small\verb%METIS_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic using Metis algorithm.

\DESCRIBE
A call to {\small\verb%METIS_TAC[theorems]%} will attempt to establish the current goal
using pure first-order reasoning, taking {\small\verb%theorems%} as the starting-point. (It
does not take the assumptions of the goal into account, but the similar
function {\small\verb%ASM_METIS_TAC%} does.) It will usually either solve the goal
completely or run for an infeasibly long time, but it may sometimes fail
quickly.

This tactic is closely related to {\small\verb%MESON_TAC%}, and many of the same general
comments apply. Generally speaking, {\small\verb%METIS_TAC%} is capable of solving more
challenging problems than {\small\verb%MESON_TAC%}, though the latter is often faster where
it succeeds. Like {\small\verb%MESON_TAC%}, it will exploit no special properties of the
constants in the goal, other than equality and logical primitives. Any
properties that are needed must be supplied explicitly in the theorem list,
e.g. {\small\verb%LE_REFL%} to tell it that {\small\verb%<=%} on natural numbers is reflexive, or
{\small\verb%REAL_ADD_SYM%} to tell it that addition on real numbers is symmetric.

Sometimes the similar {\small\verb%MESON_TAC%} tactic is faster, especially on simpler
goals.

\FAILURE
Fails if the goal is unprovable within the search bounds.

\EXAMPLE
Here is a simple `group theory' type property about a binary function {\small\verb%m%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!x y z. m(x, m(y,z)) = m(m(x,y), z) /\ m(x,y) = m(y,x))
       ==> m(a, m(b, m(c, m(d, m(e, f))))) = m(f, m(e, m(d, m(c, m(b, a)))))`;;

\end{verbatim}
}
It is solved in a fraction of a second by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(METIS_TAC[]);;
  val it : goalstack = No subgoals
\end{verbatim}
}
This is an example where {\small\verb%METIS_TAC%} substantially outperforms {\small\verb%MESON_TAC%},
which does not seem to be able to solve that problem in a reasonable time.

\SEEALSO
ASM_METIS_TAC, LEANCOP_TAC, MESON_TAC, METIS, NANOCOP_TAC.

\ENDDOC
\DOC{mk{\_}abs}

\TYPE {\small\verb%mk_abs : term * term -> term%}\egroup

\SYNOPSIS
Constructs an abstraction.

\DESCRIBE
If {\small\verb%v%} is a variable and {\small\verb%t%} any term, then {\small\verb%mk_abs(v,t)%} produces the
abstraction term {\small\verb%\v. t%}. It is not necessary that {\small\verb%v%} should occur free in
{\small\verb%t%}.

\FAILURE
Fails if {\small\verb%v%} is not a variable. See {\small\verb%mk_gabs%} for constructing generalized
abstraction terms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_abs(`x:num`,`x + 1`);;
  val it : term = `\x. x + 1`
\end{verbatim}
}

\SEEALSO
dest_abs, is_abs, mk_gabs.

\ENDDOC
\DOC{mk{\_}binary}

\TYPE {\small\verb%mk_binary : string -> term * term -> term%}\egroup

\SYNOPSIS
Constructs an instance of a named monomorphic binary operator.

\DESCRIBE
The call {\small\verb%mk_binary s (l,r)%} constructs a binary application {\small\verb%(op l) r%} where
{\small\verb%op%} is the monomorphic constant with name {\small\verb%s%}. Note that it will in general
{\em not} work if the constant is polymorphic.

\FAILURE
If there is no constant at all with name {\small\verb%s%}, or if the constant is polymorphic
and the terms do not match its most general type.

\EXAMPLE
This case works fine:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_binary "+" (`1`,`2`);;
  val it : term = `1 + 2`
\end{verbatim}
}
\noindent but here we hit the monomorphism restriction:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_binary "=" (`a:A`,`b:A`);;
  val it : term = `a = b`
  # mk_binary "=" (`1`,`2`);;
  Exception: Failure "mk_binary".
\end{verbatim}
}

\SEEALSO
dest_binary, is_binary, mk_binop.

\ENDDOC
\DOC{mk{\_}binder}

\TYPE {\small\verb%mk_binder : string -> term * term -> term%}\egroup

\SYNOPSIS
Constructs a term with a named constant applied to an abstraction.

\DESCRIBE
The call {\small\verb%mk_binder "c" (x,t)%} returns the term {\small\verb%c (\x. t)%} where {\small\verb%c%} is a
constant with the given name appropriately type-instantiated. Note that the
binder parsing status of {\small\verb%c%} is irrelevant, though only if it is parsed as a
binder will the resulting term be printed and parseable as {\small\verb%c x. t%}.

\FAILURE
Failus if {\small\verb%x%} is not a variable, if there is no constant {\small\verb%c%} or if the type of
that constant cannot be instantiated to match the abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_binder "!" (`x:num`,`x + 1 > 0`);;
  val it : term = `!x. x + 1 > 0`
\end{verbatim}
}

\SEEALSO
dest_binder, is_binder.

\ENDDOC
\DOC{mk{\_}binop}

\TYPE {\small\verb%mk_binop : term -> term -> term -> term%}\egroup

\SYNOPSIS
The call {\small\verb%mk_binop op l r%} returns the term {\small\verb%(op l) r%}.

\DESCRIBE
The call {\small\verb%mk_binop op l r%} returns the term {\small\verb%(op l) r%} provided that is
well-typed. Otherwise it fails. The term {\small\verb%op%} need not be a constant nor parsed
as infix, but that is the usual case. Note that type variables in {\small\verb%op%} are not
instantiated, so it needs to be the correct instance for the terms {\small\verb%l%} and {\small\verb%r%}.

\FAILURE
Fails if the types are incompatible.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_binop `(+):num->num->num` `1` `2`;;
  val it : term = `1 + 2`
\end{verbatim}
}

\SEEALSO
dest_binop, is_binop, mk_binary.

\ENDDOC
\DOC{MK{\_}BINOP}

\TYPE {\small\verb%MK_BINOP : term -> thm * thm -> thm%}\egroup

\SYNOPSIS
Compose equational theorems with binary operator.

\DESCRIBE
Given a term {\small\verb%op%} and the pair of theorems {\small\verb%(|- l = l'),(|- r = r')%}, the
function {\small\verb%MK_BINOP%} returns the theorem {\small\verb%|- op l r = op l' r'%}, provided the
types are compatible.

\FAILURE
Fails if the types are incompatible for the term {\small\verb%op l r%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = NUM_REDUCE_CONV `2 * 2`
    and th2 = NUM_REDUCE_CONV `2 EXP 2`;;
  val th1 : thm = |- 2 * 2 = 4
  val th2 : thm = |- 2 EXP 2 = 4
  # MK_BINOP `(+):num->num->num` (th1,th2);;
  val it : thm = |- 2 * 2 + 2 EXP 2 = 4 + 4
\end{verbatim}
}

\SEEALSO
BINOP_CONV, DEPTH_BINOP_CONV, MK_COMB.

\ENDDOC
\DOC{mk{\_}char}

\TYPE {\small\verb%mk_char : char -> term%}\egroup

\SYNOPSIS
Constructs object-level character from OCaml character.

\DESCRIBE
{\small\verb%mk_char 'c'%} produces the HOL term of type {\small\verb%char%} corresponding to the OCaml
character {\small\verb%c%}.

\FAILURE
Never fails

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_char 'c';;
  val it : term = `ASCII F T T F F F T T`
\end{verbatim}
}

\COMMENTS
There is no particularly convenient parser/printer support for the HOL {\small\verb%char%}
type, but when combined into lists they are considered as strings and provided
with more intuitive parser/printer support.

\SEEALSO
dest_char, dest_string, mk_string.

\ENDDOC
\DOC{mk{\_}comb}

\TYPE {\small\verb%mk_comb : term * term -> term%}\egroup

\SYNOPSIS
Constructs a combination.

\DESCRIBE
Given two terms {\small\verb%f%} and {\small\verb%x%}, the call {\small\verb%mk_comb(f,x)%} returns the combination or
application {\small\verb%f x%}. It is necessary that {\small\verb%f%} has a function type with domain
type the same as {\small\verb%x%}'s type.

\FAILURE
Fails if the types of the terms are not compatible as specified above.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_comb(`SUC`,`0`);;
  val it : term = `SUC 0`

  # mk_comb(`SUC`,`T`);;
  Exception: Failure "mk_comb: types do not agree".
\end{verbatim}
}

\SEEALSO
dest_comb, is_comb, list_mk_comb, list_mk_icomb, mk_icomb.

\ENDDOC
\DOC{MK{\_}COMB{\_}TAC}

\TYPE {\small\verb%MK_COMB_TAC : tactic%}\egroup

\SYNOPSIS
Breaks down a goal between function applications into equality of functions and
arguments.

\DESCRIBE
Given a goal whose conclusion is an equation between function applications
{\small\verb%A ?- f x = g y%}, the tactic {\small\verb%MK_COMB_TAC%} breaks it down to two subgoals
expressing equality of the corresponding rators and rands:
{\par\samepage\setseps\small
\begin{verbatim}
            A ?- f x = g y
   ================================  MK_COMB_TAC
      A ?- f = g      A ?- x = y
\end{verbatim}
}

\FAILURE
Fails if the conclusion of the goal is not an equation between applications.

\SEEALSO
ABS_TAC, AP_TERM_TAC, AP_THM_TAC, BINOP_TAC, MK_COMB.

\ENDDOC
\DOC{MK{\_}COMB}

\TYPE {\small\verb%MK_COMB : thm * thm -> thm%}\egroup

\SYNOPSIS
Proves equality of combinations constructed from equal
functions and operands.

\DESCRIBE
When applied to theorems {\small\verb%A1 |- f = g%} and {\small\verb%A2 |- x = y%}, the inference
rule {\small\verb%MK_COMB%} returns the theorem {\small\verb%A1 u A2 |- f x = g y%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- f = g   A2 |- x = y
   ---------------------------  MK_COMB
       A1 u A2 |- f x = g y
\end{verbatim}
}

\FAILURE
Fails unless both theorems are equational and {\small\verb%f%} and {\small\verb%g%} are
functions whose domain types are the same as the types of {\small\verb%x%} and {\small\verb%y%}
respectively.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = ABS `n:num` (ARITH_RULE `SUC n = n + 1`)
    and th2 = NUM_REDUCE_CONV `2 + 2`;;
  val th1 : thm = |- (\n. SUC n) = (\n. n + 1)
  val th2 : thm = |- 2 + 2 = 4
  # let th3 = MK_COMB(th1,th2);;
  val th3 : thm = |- (\n. SUC n) (2 + 2) = (\n. n + 1) 4

  # let th1 = NOT_DEF and th2 = TAUT `p /\ p <=> p`;;
  val th1 : thm = |- (~) = (\p. p ==> F)
  val th2 : thm = |- p /\ p <=> p
  # MK_COMB(th1,th2);;
  val it : thm = |- ~(p /\ p) <=> (\p. p ==> F) p
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules. It underlies, among
other things, the replacement of subterms in rewriting.

\SEEALSO
AP_TERM, AP_THM, BETA_CONV, TRANS.

\ENDDOC
\DOC{mk{\_}cond}

\TYPE {\small\verb%mk_cond : term * term * term -> term%}\egroup

\SYNOPSIS
Constructs a conditional term.

\DESCRIBE
{\small\verb%mk_cond(`t`,`t1`,`t2`)%} returns {\small\verb%`if t then t1 else t2`%}.

\FAILURE
Fails with {\small\verb%mk_cond%} if {\small\verb%t%} is not of type {\small\verb%`:bool`%} or if {\small\verb%t1%} and {\small\verb%t2%} are
of different types.

\SEEALSO
dest_cond, is_cond.

\ENDDOC
\DOC{mk{\_}conj}

\TYPE {\small\verb%mk_conj : term * term -> term%}\egroup

\SYNOPSIS
Constructs a conjunction.

\DESCRIBE
{\small\verb%mk_conj(`t1`,`t2`)%} returns {\small\verb%`t1 /\ t2`%}.

\FAILURE
Fails with {\small\verb%mk_conj%} if either {\small\verb%t1%} or {\small\verb%t2%} are not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_conj(`1 + 1 = 2`,`2 + 2 = 4`);;
  val it : term = `1 + 1 = 2 /\ 2 + 2 = 4`
\end{verbatim}
}

\SEEALSO
dest_conj, is_conj, list_mk_conj.

\ENDDOC
\DOC{MK{\_}CONJ}

\TYPE {\small\verb%MK_CONJ : thm -> thm -> thm%}\egroup

\SYNOPSIS
Conjoin both sides of two equational theorems.

\DESCRIBE
Given two theorems, each with a Boolean equation as conclusion, {\small\verb%MK_CONJ%}
returns the equation resulting from conjoining their respective sides:
{\par\samepage\setseps\small
\begin{verbatim}
         A |- p <=> p'   B |- q <=> q'
      ----------------------------------- MK_CONJ
           A u B |- p /\ q <=> p' /\ q'
\end{verbatim}
}

\FAILURE
Fails unless both input theorems are Boolean equations (iff).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = ARITH_RULE `0 < n <=> ~(n = 0)`
    and th2 = ARITH_RULE `1 <= n <=> ~(n = 0)`;;
  val th1 : thm = |- 0 < n <=> ~(n = 0)
  val th2 : thm = |- 1 <= n <=> ~(n = 0)

  # MK_CONJ th1 th2;;
  val it : thm = |- 0 < n /\ 1 <= n <=> ~(n = 0) /\ ~(n = 0)
\end{verbatim}
}

\SEEALSO
AP_TERM, AP_THM, MK_BINOP, MK_COMB, MK_DISJ, MK_EXISTS, MK_FORALL.

\ENDDOC
\DOC{mk{\_}cons}

\TYPE {\small\verb%mk_cons : term -> term -> term%}\egroup

\SYNOPSIS
Constructs a {\small\verb%CONS%} pair.

\DESCRIBE
{\small\verb%mk_cons `h` `t`%} returns {\small\verb%`CONS h t`%}.

\FAILURE
Fails if second term is not of list type or if the first term is not of the
same type as the elements of the list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_cons `1` `l:num list`;;
  val it : term = `CONS 1 l`

  # mk_cons `1` `[2;3;4]`;;
  val it : term = `[1; 2; 3; 4]`
\end{verbatim}
}

\SEEALSO
dest_cons, dest_list, is_cons, is_list, mk_flist, mk_list.

\ENDDOC
\DOC{mk{\_}const}

\TYPE {\small\verb%mk_const : string * (hol_type * hol_type) list -> term%}\egroup

\SYNOPSIS
Produce constant term by applying an instantiation to its generic type.

\DESCRIBE
This is the basic way of constructing a constant term in HOL Light, applying a
specific instantiation (by {\small\verb%type_subst%}) to its generic type. It may sometimes
be more convenient to use {\small\verb%mk_mconst%}, which just takes the desired type for
the constant and finds the instantiation itself; that is also a natural inverse
for {\small\verb%dest_const%}. However, {\small\verb%mk_const%} is likely to be significantly faster.

\FAILURE
Fails if there is no constant of the given type.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # get_const_type "=";;
  val it : hol_type = `:A->A->bool`

  # mk_const("=",[`:num`,`:A`]);;
  val it : term = `(=)`
  # type_of it;;
  val it : hol_type = `:num->num->bool`

  # mk_const("=",[`:num`,`:A`]) = mk_mconst("=",`:num->num->bool`);;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
dest_const, is_const, mk_mconst, type_subst.

\ENDDOC
\DOC{mk{\_}disj}

\TYPE {\small\verb%mk_disj : term * term -> term%}\egroup

\SYNOPSIS
Constructs a disjunction.

\DESCRIBE
{\small\verb%mk_disj(`t1`,`t2`)%} returns {\small\verb%`t1 \/ t2`%}.

\FAILURE
Fails with {\small\verb%mk_disj%} if either {\small\verb%t1%} or {\small\verb%t2%} are not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_disj(`x = 1`,`y <= 2`);;
  val it : term = `x = 1 \/ y <= 2`
\end{verbatim}
}

\SEEALSO
dest_disj, is_disj, list_mk_disj.

\ENDDOC
\DOC{MK{\_}DISJ}

\TYPE {\small\verb%MK_DISJ : thm -> thm -> thm%}\egroup

\SYNOPSIS
Disjoin both sides of two equational theorems.

\DESCRIBE
Given two theorems, each with a Boolean equation as conclusion, {\small\verb%MK_DISJ%}
returns the equation resulting from disjoining their respective sides:
{\par\samepage\setseps\small
\begin{verbatim}
         A |- p <=> p'   B |- q <=> q'
      ----------------------------------- MK_DISJ
           A u B |- p \/ q <=> p' \/ q'
\end{verbatim}
}

\FAILURE
Fails unless both input theorems are Boolean equations (iff).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = ARITH_RULE `1 < x <=> 1 <= x - 1`
    and th2 = ARITH_RULE `~(1 < x) <=> x = 0 \/ x = 1`;;
  val th1 : thm = |- 1 < x <=> 1 <= x - 1
  val th2 : thm = |- ~(1 < x) <=> x = 0 \/ x = 1

  # MK_DISJ th1 th2;;
  val it : thm = |- 1 < x \/ ~(1 < x) <=> 1 <= x - 1 \/ x = 0 \/ x = 1
\end{verbatim}
}

\SEEALSO
AP_TERM, AP_THM, MK_BINOP, MK_COMB, MK_CONJ, MK_EXISTS, MK_FORALL.

\ENDDOC
\DOC{mk{\_}eq}

\TYPE {\small\verb%mk_eq : term * term -> term%}\egroup

\SYNOPSIS
Constructs an equation.

\DESCRIBE
{\small\verb%mk_eq(`t1`,`t2`)%} returns {\small\verb%`t1 = t2`%}.

\FAILURE
Fails with {\small\verb%mk_eq%} if {\small\verb%t1%} and {\small\verb%t2%} have different types.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_eq(`1`,`2`);;
  val it : term = `1 = 2`
\end{verbatim}
}

\SEEALSO
dest_eq, is_eq.

\ENDDOC
\DOC{mk{\_}exists}

\TYPE {\small\verb%mk_exists : term * term -> term%}\egroup

\SYNOPSIS
Term constructor for existential quantification.

\DESCRIBE
{\small\verb%mk_exists(`v`,`t`)%} returns {\small\verb%`?v. t`%}.

\FAILURE
Fails with if first term is not a variable or if {\small\verb%t%} is not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_exists(`x:num`,`x + 1 = 1 + x`);;
  val it : term = `?x. x + 1 = 1 + x`
\end{verbatim}
}

\SEEALSO
dest_exists, is_exists, list_mk_exists.

\ENDDOC
\DOC{MK{\_}EXISTS}

\TYPE {\small\verb%MK_EXISTS : term -> thm -> thm%}\egroup

\SYNOPSIS
Existentially quantifies both sides of equational theorem.

\DESCRIBE
Given a theorem {\small\verb%th%} whose conclusion is a Boolean equation (iff), the rule
{\small\verb%MK_EXISTS `v` th%} existentially quantifies both sides of {\small\verb%th%} over the
variable {\small\verb%v%}, provided it is not free in the hypotheses
{\par\samepage\setseps\small
\begin{verbatim}
             A |- p <=> q
      ---------------------------- MK_EXISTS `v` [where v not free in A]
        A |- (?v. p) <=> (?v. q)
\end{verbatim}
}

\FAILURE
Fails if the term is not a variable or is free in the hypotheses of the
theorem, or if the theorem does not have a Boolean equation for its conclusion.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ARITH_RULE `f(x:A) >= 1 <=> ~(f(x) = 0)`;;
  val th : thm = |- f x >= 1 <=> ~(f x = 0)

  # MK_EXISTS `x:A` th;;
  val it : thm = |- (?x. f x >= 1) <=> (?x. ~(f x = 0))
\end{verbatim}
}

\SEEALSO
AP_TERM, AP_THM, MK_BINOP, MK_COMB, MK_CONJ, MK_DISJ, MK_FORALL.

\ENDDOC
\DOC{mk{\_}finty}

\TYPE {\small\verb%mk_finty :num -> hol_type%}\egroup

\SYNOPSIS
Converts an integer to a standard finite type.

\DESCRIBE
Finite types parsed and printed as numerals are provided, and this operation
when applied to a number gives a type of that size.

\FAILURE
Fails if the number is not a strictly positive integer.

\EXAMPLE
Here we use a 6-element type:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_finty (Int 6);;
  val it : hol_type = `:6`
\end{verbatim}
}

\SEEALSO
dest_finty, DIMINDEX_CONV, DIMINDEX_TAC, HAS_SIZE_DIMINDEX_RULE, mk_type.

\ENDDOC
\DOC{mk{\_}flist}

\TYPE {\small\verb%mk_flist : term list -> term%}\egroup

\SYNOPSIS
Constructs object-level list from nonempty list of terms.

\DESCRIBE
{\small\verb%mk_flist [`t1`;...;`tn`]%} returns {\small\verb%`[t1;...;tn]`%}. The list must be nonempty,
since the type could not be inferred for that case. For cases where you may
need to construct an empty list, use {\small\verb%mk_list%}.

\FAILURE
Fails if the list is empty or if the types of any elements differ from each
other.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_flist(map mk_small_numeral (1--10));;
  val it : term = `[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]`
\end{verbatim}
}

\SEEALSO
dest_cons, dest_list, is_cons, is_list, mk_cons, mk_list.

\ENDDOC
\DOC{mk{\_}forall}

\TYPE {\small\verb%mk_forall : term * term -> term%}\egroup

\SYNOPSIS
Term constructor for universal quantification.

\DESCRIBE
{\small\verb%mk_forall(`v`,`t`)%} returns {\small\verb%`!v. t`%}.

\FAILURE
Fails with if first term is not a variable or if {\small\verb%t%} is not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_forall(`x:num`,`x + 1 = 1 + x`);;
  val it : term = `!x. x + 1 = 1 + x`
\end{verbatim}
}

\SEEALSO
dest_forall, is_forall, list_mk_forall.

\ENDDOC
\DOC{MK{\_}FORALL}

\TYPE {\small\verb%MK_FORALL : term -> thm -> thm%}\egroup

\SYNOPSIS
Universally quantifies both sides of equational theorem.

\DESCRIBE
Given a theorem {\small\verb%th%} whose conclusion is a Boolean equation (iff), the rule
{\small\verb%MK_FORALL `v` th%} universally quantifies both sides of {\small\verb%th%} over the variable
{\small\verb%v%}, provided it is not free in the hypotheses
{\par\samepage\setseps\small
\begin{verbatim}
             A |- p <=> q
      ---------------------------- MK_FORALL `v` [where v not free in A]
        A |- (!v. p) <=> (!v. q)
\end{verbatim}
}

\FAILURE
Fails if the term is not a variable or is free in the hypotheses of the
theorem, or if the theorem does not have a Boolean equation for its conclusion.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ARITH_RULE `f(x:A) >= 1 <=> ~(f(x) = 0)`;;
  val th : thm = |- f x >= 1 <=> ~(f x = 0)

  # MK_FORALL `x:A` th;;
  val it : thm = |- (!x. f x >= 1) <=> (!x. ~(f x = 0))
\end{verbatim}
}

\SEEALSO
AP_TERM, AP_THM, MK_BINOP, MK_COMB, MK_CONJ, MK_DISJ, MK_EXISTS.

\ENDDOC
\DOC{mk{\_}fset}

\TYPE {\small\verb%mk_fset : term list -> term%}\egroup

\SYNOPSIS
Constructs an explicit set enumeration from a nonempty list of elements.

\DESCRIBE
When applied to a list of terms {\small\verb%[`t1`; ...; `tn`]%} of the same type, the
function {\small\verb%mk_fset%} constructs an explicit set enumeration term {\small\verb%`{t1, ...,
tn}`%}. Note that duplicated elements are maintained in the resulting term,
though this is logically the same as the set without them. If you need to
generate enumerations for empty sets, use {\small\verb%mk_setenum%}; in this case the type
also needs to be specified.

\FAILURE
Fails if there are terms of more than one type in the list, or if the list is
empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_fset (map mk_small_numeral (0--7));;
  val it : term = `{0, 1, 2, 3, 4, 5, 6, 7}`
\end{verbatim}
}

\SEEALSO
dest_setenum, is_setenum, mk_flist, mk_setenum.

\ENDDOC
\DOC{mk{\_}fthm}

\TYPE {\small\verb%mk_fthm : term list * term -> thm%}\egroup

\SYNOPSIS
Create arbitrary theorem by adding additional `false' assumption.

\DESCRIBE
The call {\small\verb%mk_fthm(asl,c)%} returns a theorem with conclusion {\small\verb%c%} and assumption
list {\small\verb%asl%} together with the special assumption {\small\verb%_FALSITY_%}, which is defined
to be logically equivalent to {\small\verb%F%} (false). This is the closest approach to
{\small\verb%mk_thm%} that does not involve adding a new axiom and so potentially
compromising soundness.

\FAILURE
Fails if any of the given terms does not have Boolean type.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_fthm([],`1 = 2`);;
  val it : thm = _FALSITY_ |- 1 = 2
\end{verbatim}
}

\USES
Used for validity-checking of justification functions as a sanity check in
tactic applications: see {\small\verb%VALID%}.

\SEEALSO
CHEAT_TAC, mk_thm, new_axiom, VALID.

\ENDDOC
\DOC{mk{\_}fun{\_}ty}

\TYPE {\small\verb%mk_fun_ty : hol_type -> hol_type -> hol_type%}\egroup

\SYNOPSIS
Construct a function type.

\DESCRIBE
The call {\small\verb%mk_fun_ty ty1 ty2%} gives the function type {\small\verb%ty1->ty2%}. This is an
exact synonym of {\small\verb%mk_type("fun",[ty1; ty2])%}, but a little more convenient.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_fun_ty `:num` `:num`;;
  val it : hol_type = `:num->num`

  # itlist mk_fun_ty [`:A`; `:B`; `:C`] `:bool`;;
  val it : hol_type = `:A->B->C->bool`
\end{verbatim}
}

\SEEALSO
dest_type, mk_type.

\ENDDOC
\DOC{mk{\_}gabs}

\TYPE {\small\verb%mk_gabs : term * term -> term%}\egroup

\SYNOPSIS
Constructs a generalized abstraction.

\DESCRIBE
Given a pair of terms {\small\verb%s%} and {\small\verb%t%}, the call {\small\verb%mk_gabs(s,t)%} constructs a
canonical `generalized abstraction' that is thought of as `some function that
always maps {\small\verb%s%} to {\small\verb%t%}'. In the case where {\small\verb%s%} is a variable, the result is an
ordinary abstraction as constructed by {\small\verb%mk_abs%}. In other cases, the canonical
composite structure is created. Note that the logical construct is welldefined
even if there is no function mapping {\small\verb%s%} to {\small\verb%t%}, and this function will
always succeed, even if the resulting structure is not really useful.

\FAILURE
Never fails.

\EXAMPLE
Here is a simple abstraction:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_gabs(`x:bool`,`~x`);;
  val it : term = `\x. ~x`
\end{verbatim}
}
\noindent and here are a couple of potentially useful generalized ones:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_gabs(`(x:num,y:num)`,`x + y + 1`);;
  val it : term = `\(x,y). x + y + 1`

  # mk_gabs(`CONS (h:num) t`,`if h = 0 then t else CONS h t`);;
  val it : term = `\CONS h t. if h = 0 then t else CONS h t`
\end{verbatim}
}
\noindent while here is a vacuous one about which nothing interesting will be
proved, because there is no welldefined function that always maps {\small\verb%x + y%} to
{\small\verb%x%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_gabs(`x + y:num`,`x:num`);;
  val it : term = `\(x + y). x`
\end{verbatim}
}

\SEEALSO
dest_gabs, GEN_BETA_CONV, is_gabs, list_mk_gabs.

\ENDDOC
\DOC{mk{\_}goalstate}

\TYPE {\small\verb%mk_goalstate : goal -> goalstate%}\egroup

\SYNOPSIS
Converts a goal into a 1-element goalstate.

\DESCRIBE
Given a goal {\small\verb%g%}, the call {\small\verb%mk_goalstate g%} converts it into a goalstate with
that goal as its only member. (A goalstate consists of a list of subgoals as
well as justification and metavariable information.)

\FAILURE
Never fails.

\SEEALSO
g, set_goal, TAC_PROOF.

\ENDDOC
\DOC{mk{\_}icomb}

\TYPE {\small\verb%mk_icomb : term * term -> term%}\egroup

\SYNOPSIS
Makes a combination, instantiating types in rator if necessary.

\DESCRIBE
The call {\small\verb%mk_icomb(f,x)%} makes the combination {\small\verb%f x%}, just as with {\small\verb%mk_comb%},
but if necessary to ensure the types are compatible it will instantiate type
variables in {\small\verb%f%} first.

\FAILURE
Fails if the rator type is impossible to instantiate compatibly.

\EXAMPLE
The analogous call to the following using plain {\small\verb%mk_const%} would fail:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_icomb(`(!)`,`\x. x = 1`);;
  Warning: inventing type variables
  val it : term = `!x. x = 1`
\end{verbatim}
}

\USES
A handy way of making combinations involving polymorphic constants, without
needing a manual instantiation of the generic type.

\SEEALSO
list_mk_icomb, mk_comb, type_match.

\ENDDOC
\DOC{mk{\_}iff}

\TYPE {\small\verb%mk_iff : term * term -> term%}\egroup

\SYNOPSIS
Constructs a logical equivalence (Boolean equation).

\DESCRIBE
{\small\verb%mk_iff(`t1`,`t2`)%} returns {\small\verb%`t1 <=> t2`%}.

\FAILURE
Fails with unless {\small\verb%t1%} and {\small\verb%t2%} both have Boolean type.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_iff(`x = 1`,`1 = x`);;
  val it : term = `x = 1 <=> 1 = x`
\end{verbatim}
}

\COMMENTS
Simply {\small\verb%mk_eq%} has the same effect on successful calls. However {\small\verb%mk_iff%} is
slightly more efficient, and will fail if the terms do not have Boolean type.

\SEEALSO
dest_iff, is_iff,mk_eq.

\ENDDOC
\DOC{mk{\_}imp}

\TYPE {\small\verb%mk_imp : term * term -> term%}\egroup

\SYNOPSIS
Constructs an implication.

\DESCRIBE
{\small\verb%mk_imp(`t1`,`t2`)%} returns {\small\verb%`t1 ==> t2`%}.

\FAILURE
Fails with {\small\verb%mk_imp%} if either {\small\verb%t1%} or {\small\verb%t2%} are not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_imp(`p /\ q`,`r:bool`);;
  val it : term = `p /\ q ==> r`
\end{verbatim}
}

\SEEALSO
dest_imp, is_imp, list_mk_imp.

\ENDDOC
\DOC{mk{\_}intconst}

\TYPE {\small\verb%mk_intconst : num -> term%}\egroup

\SYNOPSIS
Converts an OCaml number to a canonical integer literal of type {\small\verb%:int%}.

\DESCRIBE
The call {\small\verb%mk_intconst n%} where {\small\verb%n%} is an OCaml number (type {\small\verb%num%}) produces
the canonical integer literal of type {\small\verb%:int%} representing the integer {\small\verb%n%}. This
will be of the form `{\small\verb%&m%}' for a numeral {\small\verb%m%} (when {\small\verb%n%} is nonnegative) or
`{\small\verb%-- &m%}' for a nonzero numeral {\small\verb%m%} (when {\small\verb%n%} is negative).

\FAILURE
Fails if applied to a number that is not an integer (type {\small\verb%num%} also includes
rational numbers).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_intconst (Int (-101));;
  val it : term = `-- &101`

  # type_of it;;
  val it : hol_type = `:int`
\end{verbatim}
}

\SEEALSO
dest_intconst, is_intconst, mk_realintconst.

\ENDDOC
\DOC{mk{\_}let}

\TYPE {\small\verb%mk_let : (term * term) list * term -> term%}\egroup

\SYNOPSIS
Constructs a let-expression.

\DESCRIBE
Given argument {\small\verb%([l1,r1; ...; ln,rn],bod)%}, the {\small\verb%mk_let%} constructor produces
the let-expression {\small\verb%let l1 = r1 and ... and ln = rn in bod%}.

\FAILURE
Fails if the list of left-hand and right-hand sides is empty or if some
corresponding pair of left-hand and right-hand sides have different types.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_let([`x:num`,`1`],`x + 2`);;
  val it : term = `let x = 1 in x + 2`

  # mk_let([`CONS (h:bool) t`,`[F;F;F;F]`; `z:num`,`1`],`h ==> z = 2`);;
  val it : term = `let CONS h t = [F; F; F; F] and z = 1 in h ==> z = 2`
\end{verbatim}
}
\SEEALSO
mk_let, is_let.

\ENDDOC
\DOC{mk{\_}list}

\TYPE {\small\verb%mk_list : term list * hol_type -> term%}\egroup

\SYNOPSIS
Constructs object-level list from list of terms.

\DESCRIBE
{\small\verb%mk_list([`t1`;...;`tn`],`:ty`)%} returns {\small\verb%`[t1;...;tn]:(ty)list`%}.
The type argument is required so that empty lists can be constructed. If you
know the list is nonempty, you can just use {\small\verb%mk_flist%} where this is not
required.

\FAILURE
Fails with if any term in the list is not of the type specified as the second
argument.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_list([`1`; `2`],`:num`);;
  val it : term = `[1; 2]`

  # mk_list([],`:num`);;
  val it : term = `[]`

  # type_of it;;
  val it : hol_type = `:(num)list`
\end{verbatim}
}

\SEEALSO
dest_cons, dest_list, is_cons, is_list, mk_cons, mk_flist.

\ENDDOC
\DOC{mk{\_}mconst}

\TYPE {\small\verb%mk_mconst : string * hol_type -> term%}\egroup

\SYNOPSIS
Constructs a constant with type matching.

\DESCRIBE
{\small\verb%mk_mconst("const",`:ty`)%} returns the constant {\small\verb%`const:ty`%}.

\FAILURE
Fails with {\small\verb%mk_mconst: ...%} if the string supplied is not the name of a known
constant, or if it is known but the type supplied is not the correct type for
the constant.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_mconst ("T",`:bool`);;
  val it : term = `T`

  # mk_mconst ("T",`:num`);;
  Exception: Failure "mk_const: generic type cannot be instantiated".
\end{verbatim}
}

\COMMENTS
The primitive HOL Light facility for making constants is {\small\verb%mk_const%}, which
takes a type instantiation to apply to the constant's generic type. The
function {\small\verb%mk_mconst%} requires type matching and so is in general somewhat less
efficient. However it is sometimes more convenient, and a natural inverse for
{\small\verb%dest_const%}.

\SEEALSO
mk_const, dest_const, is_const, mk_var, mk_comb, mk_abs.

\ENDDOC
\DOC{mk{\_}neg}

\TYPE {\small\verb%mk_neg : term -> term%}\egroup

\SYNOPSIS
Constructs a logical negation.

\DESCRIBE
{\small\verb%mk_neg `t`%} returns {\small\verb%`~t`%}.

\FAILURE
Fails with {\small\verb%mk_neg%} unless {\small\verb%t%} is of type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_neg `p /\ q`;;
  val it : term = `~(p /\ q)`

  # mk_neg `~p`;;
  val it : term = `~ ~p`
\end{verbatim}
}

\SEEALSO
dest_neg, is_neg.

\ENDDOC
\DOC{mk{\_}numeral}

\TYPE {\small\verb%mk_numeral : num -> term%}\egroup

\SYNOPSIS
Maps a nonnegative integer to corresponding numeral term.

\DESCRIBE
The call {\small\verb%mk_numeral n%} where {\small\verb%n%} is a nonnegative integer of type {\small\verb%num%} (this
is OCaml's type of unlimited-precision numbers) returns the HOL numeral
representation of {\small\verb%n%}.

\FAILURE
Fails if the argument is negative or not integral (type {\small\verb%num%} can include
rationals).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_numeral (Int 10);;
  val it : term = `10`

  # mk_numeral(pow2 64);;
  val it : term = `18446744073709551616`
\end{verbatim}
}

\COMMENTS
The similar function {\small\verb%mk_small_numeral%} works from a regular machine integer,
Ocaml type {\small\verb%int%}. If that suffices, it may be simpler.

\SEEALSO
dest_numeral, dest_small_numeral, is_numeral, mk_small_numeral, term_of_rat.

\ENDDOC
\DOC{mk{\_}pair}

\TYPE {\small\verb%mk_pair : term * term -> term%}\egroup

\SYNOPSIS
Constructs object-level pair from a pair of terms.

\DESCRIBE
{\small\verb%mk_pair(`t1`,`t2`)%} returns {\small\verb%`(t1,t2)`%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_pair(`x:real`,`T`);;
  val it : term = `x,T`
\end{verbatim}
}

\SEEALSO
dest_pair, is_pair, mk_cons.

\ENDDOC
\DOC{mk{\_}primed{\_}var}

\TYPE {\small\verb%mk_primed_var : term list -> term -> term%}\egroup

\SYNOPSIS
Rename variable to avoid specified names and constant names.

\DESCRIBE
The call {\small\verb%mk_primed_var avoid v%} will return a renamed variant of {\small\verb%v%}, by
adding primes, so that its name is not the same as any of the variables in the
list {\small\verb%avoid%}, nor the same as any constant name. It is a more conservative
version of the renaming function {\small\verb%variant%}.

\FAILURE
Fails if one of the items in the list {\small\verb%avoids%} is not a variable, or if {\small\verb%v%}
itself is not.

\EXAMPLE
This shows how the effect is more conservative than {\small\verb%variant%} because it even
avoids variables of the same name and different type:
{\par\samepage\setseps\small
\begin{verbatim}
  # variant [`x:bool`] `x:num`;;
  val it : term = `x`
  # mk_primed_var [`x:bool`] `x:num`;;
  val it : term = `x'`
\end{verbatim}
}
\noindent and this shows how it also avoids constant names:
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_primed_var [] (mk_var("T",`:num`));;
  val it : term = `T'`
\end{verbatim}
}

\SEEALSO
variant, variants.

\ENDDOC
\DOC{mk{\_}prover}

\TYPE {\small\verb%mk_prover : ('a -> conv) -> ('a -> thm list -> 'a) -> 'a -> prover%}\egroup

\SYNOPSIS
Construct a prover from applicator and state augmentation function.

\DESCRIBE
The HOL Light simplifier (e.g. as invoked by {\small\verb%SIMP_TAC%}) allows provers of type
{\small\verb%prover%} to be installed into simpsets, to automatically dispose of
side-conditions. These may maintain a state dynamically and augment it as more
theorems become available (e.g. a theorem {\small\verb%p |- p%} becomes available when
simplifying the consequent of an implication {\small\verb%`p ==> q`%}). In order to allow
maximal flexibility in the data structure used to maintain state, provers are
set up in an `object-oriented' style, where the context is part of the prover
function itself. A call {\small\verb%mk_prover app aug%} where {\small\verb%app: 'a -> conv%} is an
application operation to prove a term using the context of type {\small\verb%'a%} and {\small\verb%aug :
'a -> thm list -> 'a%} is an augmentation operation to add whatever
representation of the theorem list in the state of the prover is chosen, gives
a canonical prover of this form. The crucial point is that the type {\small\verb%'a%} is
invisible in the resulting prover, so different provers can maintain their
state in different ways. (In the trivial case, one might just use {\small\verb%thm list%}
for the state, and appending for the augmentation.)

\FAILURE
Does not normally fail unless the functions provided are abnormal.

\USES
This is mostly for experts wishing to customize the simplifier.

\COMMENTS
I learned of this ingenious trick for maintaining context from Don Syme, who
discovered it by reading some code written by Richard Boulton. I was told by
Simon Finn that there are similar ideas in the functional language literature
for simulating existential types.

\SEEALSO
apply_prover, augment, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{mk{\_}realintconst}

\TYPE {\small\verb%mk_realintconst : num -> term%}\egroup

\SYNOPSIS
Converts an OCaml number to a canonical integer literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%mk_realintconst n%} where {\small\verb%n%} is an OCaml number (type {\small\verb%num%}) produces
the canonical literal of type {\small\verb%:real%} representing the integer {\small\verb%n%}. This will
be of the form `{\small\verb%&m%}' for a numeral {\small\verb%m%} (when {\small\verb%n%} is nonnegative) or `{\small\verb%-- &m%}'
for a nonzero numeral {\small\verb%m%} (when {\small\verb%n%} is negative).

\FAILURE
Fails if applied to a number that is not an integer (type {\small\verb%num%} also includes
rational numbers).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_realintconst (Int (-101));;
  val it : term = `-- &101`

  # type_of it;;
  val it : hol_type = `:real`
\end{verbatim}
}

\SEEALSO
dest_realintconst, is_realintconst, mk_intconst, rat_of_term.

\ENDDOC
\DOC{mk{\_}rewrites}

\TYPE {\small\verb%mk_rewrites : bool -> thm -> thm list -> thm list%}\egroup

\SYNOPSIS
Turn theorem into list of (conditional) rewrites.

\DESCRIBE
Given a Boolean flag {\small\verb%b%}, a theorem {\small\verb%th%} and a list of theorems {\small\verb%thl%}, the call
{\small\verb%mk_rewrites b th thl%} breaks {\small\verb%th%} down into a collection of rewrites (for
example, splitting conjunctions up into several sub-theorems) and appends them
to the front of {\small\verb%thl%} (which are normally theorems already processed in this
way). Non-equational theorems {\small\verb%|- p%} are converted to {\small\verb%|- p <=> T%}. If the flag
{\small\verb%b%} is true, then implicational theorems {\small\verb%|- p ==> s = t%} are used as
conditional rewrites; otherwise they are converted to {\small\verb%|- (p ==> s = t) <=> T%}.
This function is applied inside {\small\verb%extend_basic_rewrites%} and
{\small\verb%set_basic_rewrites%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD_CLAUSES;;
  val it : thm =
    |- (!n. 0 + n = n) /\
       (!m. m + 0 = m) /\
       (!m n. SUC m + n = SUC (m + n)) /\
       (!m n. m + SUC n = SUC (m + n))

  # mk_rewrites false ADD_CLAUSES [];;
  val it : thm list =
    [|- 0 + n = n; |- m + 0 = m; |- SUC m + n = SUC (m + n);
     |- m + SUC n = SUC (m + n)]
\end{verbatim}
}

\SEEALSO
extend_basic_rewrites, GEN_REWRITE_CONV, REWRITE_CONV, set_basic_rewrites,
SIMP_CONV.

\ENDDOC
\DOC{mk{\_}select}

\TYPE {\small\verb%mk_select : term * term -> term%}\egroup

\SYNOPSIS
Constructs a choice binding.

\DESCRIBE
The call {\small\verb%mk_select(`v`,`t`)%} returns the choice term {\small\verb%`@v. t`%}.

\FAILURE
Fails if {\small\verb%v%} is not a variable.

\SEEALSO
is_slect, mk_select.

\ENDDOC
\DOC{mk{\_}setenum}

\TYPE {\small\verb%mk_setenum : term list * hol_type -> term%}\egroup

\SYNOPSIS
Constructs an explicit set enumeration from a list of elements.

\DESCRIBE
When applied to a list of terms {\small\verb%[`t1`; ...; `tn`]%} and a type {\small\verb%ty%}, where each
term in the list has type {\small\verb%ty%}, the function {\small\verb%mk_setenum%} constructs an
explicit set enumeration term {\small\verb%`{t1, ..., tn}`%}. Note that duplicated
elements are maintained in the resulting term, though this is logically the
same as the set without them. The type is needed so that the empty set can be
constructed; if you know that the list is nonempty, you can use {\small\verb%mk_fset%}
instead.

\FAILURE
Fails if some term in the list has the wrong type, i.e. not {\small\verb%ty%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_setenum([`1`; `2`; `3`],`:num`);;
  val it : term = `{1, 2, 3}`
\end{verbatim}
}

\SEEALSO
dest_setenum, is_setenum, mk_fset, mk_list.

\ENDDOC
\DOC{mk{\_}small{\_}numeral}

\TYPE {\small\verb%mk_small_numeral : int -> term%}\egroup

\SYNOPSIS
Maps a nonnegative integer to corresponding numeral term.

\DESCRIBE
The call {\small\verb%mk_small_numeral n%} where {\small\verb%n%} is a nonnegative OCaml machine integer
returns the HOL numeral representation of {\small\verb%n%}.

\FAILURE
Fails if the argument is negative.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_small_numeral 12;;
  val it : term = `12`
\end{verbatim}
}

\COMMENTS
The similar function {\small\verb%mk_numeral%} works from an unlimited precision integer,
OCaml type {\small\verb%num%}. However, none of HOL's inference rules depend on the
behaviour of machine integers, so logical soundness is not an issue.

\SEEALSO
dest_numeral, dest_small_numeral, is_numeral, mk_numeral, term_of_rat.

\ENDDOC
\DOC{mk{\_}string}

\TYPE {\small\verb%mk_string : string -> term%}\egroup

\SYNOPSIS
Constructs object-level string from OCaml string.

\DESCRIBE
{\small\verb%mk_string "..."%} produces the HOL term of type {\small\verb%string%} (which is an
abbreviation for {\small\verb%char list%}) corresponding to the OCaml string {\small\verb%"..."%}.

\FAILURE
Never fails

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_string "hello";;
  val it : term = `"hello"`

  # type_of it;;
  val it : hol_type = `:(char)list`
\end{verbatim}
}

\SEEALSO
dest_char, dest_list, dest_string, mk_char, mk_list.

\ENDDOC
\DOC{mk{\_}thm}

\TYPE {\small\verb%mk_thm : term list * term -> thm%}\egroup

\SYNOPSIS
Creates an arbitrary theorem as an axiom (dangerous!)

\DESCRIBE
The function {\small\verb%mk_thm%} can be used to construct an arbitrary theorem. It is
applied to a pair consisting of the desired assumption list (possibly empty)
and conclusion. All the terms therein should be of type {\small\verb%bool%}.
{\par\samepage\setseps\small
\begin{verbatim}
   mk_thm([`a1`;...;`an`],`c`) = ({a1,...,an} |- c)
\end{verbatim}
}
\FAILURE
Fails unless all the terms provided for assumptions and conclusion are of type
{\small\verb%bool%}.

\EXAMPLE
The following shows how to create a simple contradiction:
{\par\samepage\setseps\small
\begin{verbatim}
   #mk_thm([],`F`);;
   |- F
\end{verbatim}
}

\COMMENTS
Although {\small\verb%mk_thm%} can be useful for experimentation or temporarily plugging
gaps, its use should be avoided if at all possible in important proofs, because
it can be used to create theorems leading to contradictions. You can check
whether any axioms have been asserted by {\small\verb%mk_thm%} or {\small\verb%new_axiom%} by the call
{\small\verb%axioms()%}.

\SEEALSO
CHEAT_TAC, mk_fthm, new_axiom.

\ENDDOC
\DOC{mk{\_}type}

\TYPE {\small\verb%mk_type : string * hol_type list -> hol_type%}\egroup

\SYNOPSIS
Constructs a type (other than a variable type).

\DESCRIBE
{\small\verb%mk_type("op",[`:ty1`;...;`:tyn`])%} returns {\small\verb%`:(ty1,...,tyn)op`%} where {\small\verb%op%}
is the name of a known {\small\verb%n%}-ary type constructor.

\FAILURE
Fails with {\small\verb%mk_type%} if the string is not the name of a known type, or if the
type is known but the length of the list of argument types is not equal to
the arity of the type constructor.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_type ("bool",[]);;
  val it : hol_type = `:bool`

  # mk_type ("list",[`:bool`]);;
  val it : hol_type = `:(bool)list`

  # mk_type ("fun",[`:num`;`:bool`]);;
  val it : hol_type = `:num->bool`
\end{verbatim}
}

\SEEALSO
dest_type, mk_vartype.

\ENDDOC
\DOC{mk{\_}uexists}

\TYPE {\small\verb%mk_uexists : term * term -> term%}\egroup

\SYNOPSIS
Term constructor for unique existence.

\DESCRIBE
{\small\verb%mk_uexists(`v`,`t`)%} returns {\small\verb%`?!v. t`%}.

\FAILURE
Fails with if first term is not a variable or if {\small\verb%t%} is not of type {\small\verb%`:bool`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_uexists(`n:num`,`prime(n) /\ EVEN(n)`);;
  val it : term = `?!n. prime n /\ EVEN n`
\end{verbatim}
}

\SEEALSO
dest_uexists, is_uexists, mk_exists.

\ENDDOC
\DOC{mk{\_}var}

\TYPE {\small\verb%mk_var : string * hol_type -> term%}\egroup

\SYNOPSIS
Constructs a variable of given name and type.

\DESCRIBE
{\small\verb%mk_var("var",`:ty`)%} returns the variable {\small\verb%`var:ty`%}.

\FAILURE
Never fails.

\COMMENTS
{\small\verb%mk_var%} can be used to construct variables with names which are not
acceptable to the term parser. In particular, a variable with the name of a
known constant can be constructed using {\small\verb%mk_var%}.

\SEEALSO
dest_var, is_var, mk_const, mk_comb, mk_abs.

\ENDDOC
\DOC{mk{\_}vartype}

\TYPE {\small\verb%mk_vartype : string -> hol_type%}\egroup

\SYNOPSIS
Constructs a type variable of the given name.

\DESCRIBE
{\small\verb%mk_vartype "A"%} returns a type variable {\small\verb%`:A`%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # mk_vartype "Test";;
  val it : hol_type = `:Test`

  # mk_vartype "bool";;
  val it : hol_type = `:bool`
\end{verbatim}
}
Note that the second type is {\em not} the inbuilt type of Booleans, even
though it prints like it.

\COMMENTS
{\small\verb%mk_vartype%} can be used to create type variables with names which will not
parse, i.e. they cannot be entered by quotation. Using such type variables is
probably bad practice. HOL Light convention is to start type variables with an
uppercase letter.

\SEEALSO
dest_vartype, is_vartype, mk_type.

\ENDDOC
\DOC{MOD{\_}DOWN{\_}CONV}

\TYPE {\small\verb%MOD_DOWN_CONV : conv%}\egroup

\SYNOPSIS
Combines nested {\small\verb%MOD%} terms into a single toplevel one.

\DESCRIBE
When applied to a term containing natural number arithmetic operations of
successor, addition, multiplication and exponentiation, interspersed with
applying {\small\verb%MOD%} with a fixed modulus {\small\verb%n%}, and a toplevel {\small\verb%... MOD n%} too, the
conversion {\small\verb%MOD_DOWN_CONV%} proves that this is equal to a simplified term with
only the toplevel {\small\verb%MOD%}.

\FAILURE
Never fails but may have no effect

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `((x MOD n) + (y MOD n * 3) EXP 2) MOD n`;;
  val tm : term = `(x MOD n + (y MOD n * 3) EXP 2) MOD n`

  # MOD_DOWN_CONV tm;;
  val it : thm =
    |- (x MOD n + (y MOD n * 3) EXP 2) MOD n = (x + (y * 3) EXP 2) MOD n
\end{verbatim}
}

\SEEALSO
INT_REM_DOWN_CONV.

\ENDDOC
\DOC{monotonicity{\_}theorems}

\TYPE {\small\verb%monotonicity_theorems : thm list ref%}\egroup

\SYNOPSIS
List of monotonicity theorems for inductive definitions package.

\DESCRIBE
The various tools for making inductive definitions, such as
{\small\verb%new_inductive_definition%}, need to prove certain `monotonicity'
side-conditions. They attempt to do so automatically by using various
pre-proved theorems asserting the monotonicity of certain operators. Normally,
all this happens smoothly without user intervention, but if the inductive
definition involves new operators, you may need to augment this list with
corresponding monotonicity theorems.

\FAILURE
Not applicable.

\EXAMPLE
Suppose we define a `lexical order' construct:
{\par\samepage\setseps\small
\begin{verbatim}
  # let LEX = define
     `(LEX(<<) [] l <=> F) /\
      (LEX(<<) l [] <=> F) /\
      (LEX(<<) (CONS h1 t1) (CONS h2 t2) <=>
            if h1 << h2 then LENGTH t1 = LENGTH t2
            else (h1 = h2) /\ LEX(<<) t1 t2)`;;
\end{verbatim}
}
If we want to make an inductive definition that uses this --- for example a
lexicographic path order on a representation of first-order terms --- we need
to add a theorem asserting that this operation is monotonic. To prove it, we
first establish a lemma:
{\par\samepage\setseps\small
\begin{verbatim}
  # let LEX_LENGTH = prove
     (`!l1 l2 R. LEX(R) l1 l2 ==> (LENGTH l1 = LENGTH l2)`,
      REPEAT(LIST_INDUCT_TAC THEN SIMP_TAC[LEX]) THEN ASM_MESON_TAC[LENGTH]);;
\end{verbatim}
}
\noindent and hence derive monotonicity:
{\par\samepage\setseps\small
\begin{verbatim}
  # let MONO_LEX = prove
     (`(!x:A y:A. R x y ==> S x y) ==> LEX R x y ==> LEX S x y`,
      DISCH_TAC THEN
      MAP_EVERY (fun t -> SPEC_TAC(t,t)) [`x:A list`; `y:A list`] THEN
      REPEAT(LIST_INDUCT_TAC THEN REWRITE_TAC[LEX]) THEN
      ASM_MESON_TAC[LEX_LENGTH]);;
\end{verbatim}
}
\noindent We can now make the inductive definitions package aware of it by:
{\par\samepage\setseps\small
\begin{verbatim}
  # monotonicity_theorems := MONO_LEX::(!monotonicity_theorems);;
\end{verbatim}
}

\SEEALSO
new_inductive_definition.

\ENDDOC
\DOC{MONO{\_}TAC}

\TYPE {\small\verb%MONO_TAC : tactic%}\egroup

\SYNOPSIS
Attempt to prove monotonicity theorem automatically.

\DESCRIBE

\FAILURE
Never fails but may have no effect.

\EXAMPLE
We set up the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!x. P x ==> Q x) ==> (?y. P y /\ ~Q y) ==> (?y. Q y /\ ~P y)`;;
  ...
\end{verbatim}
}
\noindent and after breaking it down, we reach the standard form expected for
monotonicity goals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e STRIP_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`!x. P x ==> Q x`]

  `(?y. P y /\ ~Q y) ==> (?y. Q y /\ ~P y)`
\end{verbatim}
}
\noindent Indeed, it is solved automatically:
{\par\samepage\setseps\small
\begin{verbatim}
  # e MONO_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\COMMENTS
Normally, this kind of reasoning is automated by the inductive definitions
package, so explicit use of this tactic is rare.

\SEEALSO
monotonicity_theorems, new_inductive_definition,
prove_inductive_relations_exist, prove_monotonicity_hyps.

\ENDDOC
\DOC{MP}

\TYPE {\small\verb%MP : thm -> thm -> thm%}\egroup

\SYNOPSIS
Implements the Modus Ponens inference rule.

\DESCRIBE
When applied to theorems {\small\verb%A1 |- t1 ==> t2%} and {\small\verb%A2 |- t1%},
the inference rule {\small\verb%MP%} returns the theorem {\small\verb%A1 u A2 |- t2%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- t1 ==> t2   A2 |- t1
   ----------------------------  MP
          A1 u A2 |- t2
\end{verbatim}
}

\FAILURE
Fails unless the first theorem is an implication whose antecedent is the
same as the conclusion of the second theorem (up to alpha-conversion).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = TAUT `p ==> p \/ q`
    and th2 = ASSUME `p:bool`;;
  val th1 : thm = |- p ==> p \/ q
  val th2 : thm = p |- p

  # MP th1 th2;;
  val it : thm = p |- p \/ q
\end{verbatim}
}

\SEEALSO
EQ_MP, MATCH_MP, MATCH_MP_TAC, MP_TAC.

\ENDDOC
\DOC{MP{\_}CONV}

\TYPE {\small\verb%MP_CONV : conv -> thm -> thm%}\egroup

\SYNOPSIS
Removes antecedent of implication theorem by solving it with a conversion.

\DESCRIBE
The call {\small\verb%MP_CONV conv th%}, where the theorem {\small\verb%th%} has the form {\small\verb%A |- p ==> q%},
attempts to solve the antecedent {\small\verb%p%} by applying the conversion {\small\verb%conv%} to it.
If this conversion returns either {\small\verb%|- p%} or {\small\verb%|- p <=> T%}, then {\small\verb%MP_CONV%}
returns {\small\verb%A |- q%}. Otherwise it fails.

\FAILURE
Fails if the conclusion of the theorem is not implicational or if the
conversion fails to prove its antecedent.

\EXAMPLE
Suppose we generate this `epsilon-delta' theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = MESON[LE_REFL]
     `(!e. &0 < e / &2 <=> &0 < e) /\
      (!a x y e. abs(x - a) < e / &2 /\ abs(y - a) < e / &2 ==> abs(x - y) < e)
      ==> (!e. &0 < e ==> ?n. !m. n <= m ==> abs(x m - a) < e)
          ==> (!e. &0 < e ==> ?n. !m. n <= m ==> abs(x m - x n) < e)`;;
\end{verbatim}
}
\noindent We can eliminate the antecedent:
{\par\samepage\setseps\small
\begin{verbatim}
  # MP_CONV REAL_ARITH th;;
  val it : thm =
    |- (!e. &0 < e ==> (?n. !m. n <= m ==> abs (x m - a) < e))
       ==> (!e. &0 < e ==> (?n. !m. n <= m ==> abs (x m - x n) < e))
\end{verbatim}
}

\SEEALSO
MP, MATCH_MP.

\ENDDOC
\DOC{MP{\_}TAC}

\TYPE {\small\verb%MP_TAC : thm_tactic%}\egroup

\SYNOPSIS
Adds a theorem as an antecedent to the conclusion of the goal.

\DESCRIBE
When applied to the theorem {\small\verb%A' |- s%} and the goal {\small\verb%A ?- t%}, the tactic
{\small\verb%MP_TAC%} reduces the goal to {\small\verb%A ?- s ==> t%}. Unless {\small\verb%A'%} is a subset of
{\small\verb%A%}, this is an invalid tactic.
{\par\samepage\setseps\small
\begin{verbatim}
       A ?- t
   ==============  MP_TAC (A' |- s)
    A ?- s ==> t
\end{verbatim}
}

\FAILURE
Never fails.

\USES
For moving assumptions into the conclusion of the goal, which often makes it
easier to manipulate via {\small\verb%REWRITE_TAC%} or decompose by {\small\verb%ANTS_TAC%}.

\SEEALSO
MATCH_MP_TAC, MP, UNDISCH_TAC.

\ENDDOC
\DOC{name}

\TYPE {\small\verb%name : string -> term%}\egroup

\SYNOPSIS
Query to {\small\verb%search%} for a theorem whose name contains a string.

\DESCRIBE
The function {\small\verb%name%} is intended for use solely with the {\small\verb%search%} function.

\FAILURE
Never fails.

\SEEALSO
search.

\ENDDOC
\DOC{NAME{\_}ASSUMS{\_}TAC}

\TYPE {\small\verb%NAME_ASSUMS_TAC : tactic%}\egroup

\SYNOPSIS
Label unnamed assumptions.

\DESCRIBE
{\small\verb%NAME_ASSUMS_TAC%} labels unnamed assumptions with "H0", "H1", ....
It skips named assumptions.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
	# g `!(a: A) b c d. a = b ==> b = c ==> c = d ==> a = d`;;
	val it : goalstack = 1 subgoal (1 total)

	`!a b c d. a = b ==> b = c ==> c = d ==> a = d`

	# e(REPEAT GEN_TAC);;
	val it : goalstack = 1 subgoal (1 total)

	`a = b ==> b = c ==> c = d ==> a = d`

	# e(DISCH_THEN (LABEL_TAC "Hnamed"));;
	val it : goalstack = 1 subgoal (1 total)

		0 [`a = b`] (Hnamed)

	`b = c ==> c = d ==> a = d`

	# e(REPEAT STRIP_TAC);;
	val it : goalstack = 1 subgoal (1 total)

		0 [`a = b`] (Hnamed)
		1 [`b = c`]
		2 [`c = d`]

	`a = d`

	# e(NAME_ASSUMS_TAC);;
	val it : goalstack = 1 subgoal (1 total)

		0 [`a = b`] (Hnamed)
		1 [`b = c`] (H1)
		2 [`c = d`] (H0)

	`a = d`
\end{verbatim}
}

\SEEALSO
HYP, LABEL_TAC, REMOVE_THEN, USE_THEN.

\ENDDOC
\DOC{name{\_}of}

\TYPE {\small\verb%name_of : term -> string%}\egroup

\SYNOPSIS
Gets the name of a constant or variable.

\DESCRIBE
When applied to a term that is either a constant or a variable, {\small\verb%name_of%}
returns its name (its true name, even if there is an interface mapping for it
in effect). When applied to any other term, it returns the empty string.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # name_of `x:int`;;
  val it : string = "x"

  # name_of `SUC`;;
  val it : string = "SUC"

  # name_of `x + 1`;;
  val it : string = ""

\end{verbatim}
}

\SEEALSO
dest_const, dest_var.

\ENDDOC
\DOC{NANOCOP}

\TYPE {\small\verb%NANOCOP : thm list -> term -> thm%}\egroup

\SYNOPSIS
Attempt to prove a term by first-order proof search using nanoCop
connection-based prover.

\DESCRIBE
A call {\small\verb%NANOCOP[theorems] `tm`%} will attempt to prove {\small\verb%tm%} using pure
first-order reasoning, taking {\small\verb%theorems%} as the starting-point. It will usually
either prove it completely or run for an infeasibly long time, but it may
sometimes fail quickly.

Although {\small\verb%NANOCOP%} is capable of some fairly non-obvious pieces of first-order
reasoning, and will handle equality adequately, it does purely logical
reasoning. It will exploit no special properties of the constants in the goal,
other than equality and logical primitives. Any properties that are needed must
be supplied explicitly in the theorem list, e.g. {\small\verb%LE_REFL%} to tell it that {\small\verb%<=%}
on natural numbers is reflexive, or {\small\verb%REAL_ADD_SYM%} to tell it that addition on
real numbers is symmetric.

\FAILURE
Fails if the term is unprovable within the search bounds.

\EXAMPLE
A typical application is to prove some elementary logical lemma for use inside
a tactic proof:
{\par\samepage\setseps\small
\begin{verbatim}
  # NANOCOP [EXTENSION; IN_INSERT]
      `x INSERT y INSERT s = y INSERT x INSERT s`;;
\end{verbatim}
}

\USES
Generating simple logical lemmas as part of a large proof.

\SEEALSO
LEANCOP, MESON, METIS, NANOCOP_TAC.

\ENDDOC
\DOC{NANOCOP{\_}TAC}

\TYPE {\small\verb%NANOCOP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Automated first-order proof search tactic using nanoCoP algorithm.

\DESCRIBE
A call to {\small\verb%NANOCOP_TAC[theorems]%} will attempt to establish the current goal
using pure first-order reasoning, taking {\small\verb%theorems%} as the starting-point.
It will usually either solve the goal completely or run for an infeasibly long
time, but it may sometimes fail quickly. This tactic is analogous to
{\small\verb%MESON_TAC%}, and many of the same general comments apply.

\FAILURE
Fails if the goal is unprovable within the search bounds.

\EXAMPLE
Here is a simple fact about natural number sums as a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum u f`;;

\end{verbatim}
}
It is solved in a fraction of a second by {\small\verb%NANOCOP_TAC%} with some relevant
lemmas:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(NANOCOP_TAC[SUBSET; NSUM_SUPERSET; IN_UNION]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
LEANCOP_TAC, MESON_TAC, METIS_TAC, NANOCOP.

\ENDDOC
\DOC{needs}

\TYPE {\small\verb%needs : string -> unit%}\egroup

\SYNOPSIS
Load a file if not already loaded.

\DESCRIBE
The given file is loaded from the path as for {\small\verb%loadt%}, unless it has already
been loaded into the current session (by {\small\verb%loads%}, {\small\verb%loadt%} or {\small\verb%needs%}) and has
apparently (based on an MD5 checksum) not changed since then.

\FAILURE
Fails if the file is not found or generates a failure on loading.

\EXAMPLE
If a proof relies on more number theory, you might start it with
{\par\samepage\setseps\small
\begin{verbatim}
  needs "Library/prime.ml";;
  needs "Library/pocklington.ml";;
\end{verbatim}
}
If necessary, these files will be loaded as for {\small\verb%loadt%}. However, if they have
already been loaded (e.g. if the current proof is a component of a larger proof
that has already used them), they will not be reloaded.

\USES
The {\small\verb%needs%} function gives a simple form of dependency management. It is good
practice to start every file with a {\small\verb%needs%} declaration for any library that it
depends on.

\SEEALSO
load_path, loads, loadt.

\ENDDOC
\DOC{net{\_}of{\_}cong}

\TYPE {\small\verb%net_of_cong : thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net%}\egroup

\SYNOPSIS
Add a congruence rule to a net.

\DESCRIBE
The underlying machinery in rewriting and simplification assembles
(conditional) rewrite rules and other conversions into a net, including a
priority number so that, for example, pure rewrites get applied before
conditional rewrites. The congruence rules used by the simplifier to establish
context (see {\small\verb%extend_basic_congs%}) are also stored in this structure, with the
lowest priority 4. A call {\small\verb%net_of_cong th net%} adds {\small\verb%th%} as a new congruence
rule to {\small\verb%net%} to yield an updated net.

\FAILURE
Fails unless the congruence is of the appropriate implicational form.

\SEEALSO
extend_basic_congs, net_of_conv, net_of_thm.

\ENDDOC
\DOC{net{\_}of{\_}conv}

\TYPE {\small\verb%net_of_conv : term -> 'a -> (int * 'a) net -> (int * 'a) net%}\egroup

\SYNOPSIS
The underlying machinery in rewriting and simplification assembles
(conditional) rewrite rules and other conversions into a net, including a
priority number so that, for example, pure rewrites get applied before
conditional rewrites. A call {\small\verb%net_of_conv `pat` cnv net%} will add {\small\verb%cnv%} to
{\small\verb%net%} with priority 2 (lower than pure rewrites but higher than conditional
ones) to give a new net; this net can be used by {\small\verb%REWRITES_CONV%}, for example.
The term {\small\verb%pat%} is a pattern used inside the net to place {\small\verb%conv%} appropriately
(see {\small\verb%enter%} for more details). This means that {\small\verb%cnv%} will never even be tried
on terms that clearly cannot be instances of {\small\verb%pat%}.

\FAILURE
Never fails.

\SEEALSO
enter, net_of_cong, lookup, net_of_thm, REWRITES_CONV.

\ENDDOC
\DOC{net{\_}of{\_}thm}

\TYPE {\small\verb%net_of_thm : bool -> thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net%}\egroup

\SYNOPSIS
Insert a theorem into a net as a (conditional) rewrite.

\DESCRIBE
The underlying machinery in rewriting and simplification assembles
(conditional) rewrite rules and other conversions into a net, including a
priority number so that, for example, pure rewrites get applied before
conditional rewrites. Such a net can then be used by {\small\verb%REWRITES_CONV%}. A call
{\small\verb%net_of_thm rf th net%} where {\small\verb%th%} is a pure or conditional equation (as
constructed by {\small\verb%mk_rewrites%}, for example) will insert that rewrite rule into
the net with priority 1 (the highest) for a pure rewrite or 3 for a
conditional rewrite, to yield an updated net.

If {\small\verb%rf%} is {\small\verb%true%}, it indicates that this net will be used for repeated
rewriting (e.g. as in {\small\verb%REWRITE_CONV%} rather than {\small\verb%ONCE_REWRITE_CONV%}), and
therefore equations are simply discarded without changing the net if the LHS
occurs free in the RHS. This does not exclude more complicated looping
situations, but is still useful.

\FAILURE
Fails on a theorem that is neither a pure nor conditional equation.

\SEEALSO
mk_rewrites, net_of_cong, net_of_conv, REWRITES_CONV.

\ENDDOC
\DOC{new{\_}axiom}

\TYPE {\small\verb%new_axiom : term -> thm%}\egroup

\SYNOPSIS
Sets up a new axiom.

\DESCRIBE
If {\small\verb%tm%} is a term of type {\small\verb%bool%}, a call {\small\verb%new_axiom tm%} creates a
theorem
{\par\samepage\setseps\small
\begin{verbatim}
   |- tm
\end{verbatim}
}

\FAILURE
Fails if the given term does not have type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let ax = new_axiom `x = 1`;;
  val ax : thm = |- x = 1
\end{verbatim}
}
Note that as with all theorems, variables are implicitly universally
quantified, so this axiom asserts that all numbers are equal to 1. Of course,
we can then derive a contradiction:
{\par\samepage\setseps\small
\begin{verbatim}
  CONV_RULE NUM_REDUCE_CONV (INST [`0`,`x:num`] ax);;
  val it : thm = |- F
\end{verbatim}
}
Normal use of HOL Light should avoid asserting axioms. They can lead to
inconsistency, albeit not in such an obvious way. Provided theories are
extended by definitions, consistency is preserved.

\COMMENTS
For most purposes, it is unnecessary to declare new axioms: all of classical
mathematics can be derived by definitional extension alone. Proceeding by
definition is not only more elegant, but also guarantees the consistency of the
deductions made. However, there are certain entities which cannot be modelled
in simple type theory without further axioms, such as higher transfinite
ordinals.

\SEEALSO
axioms, mk_thm, new_definition.

\ENDDOC
\DOC{new{\_}basic{\_}definition}

\TYPE {\small\verb%new_basic_definition : term -> thm%}\egroup

\SYNOPSIS
Makes a simple new definition of the form {\small\verb%c = t%}.

\DESCRIBE
If {\small\verb%t%} is a closed term and {\small\verb%c%} a variable whose name has not been used as a
constant, then {\small\verb%new_basic_definition `c = t`%} will define a new constant {\small\verb%c%}
and return the theorem {\small\verb%|- c = t%} for that new constant (not the variable in
the given term). There is an additional restriction that all type variables
involved in {\small\verb%t%} must occur in the constant's type.

\FAILURE
Fails if {\small\verb%c%} is already a constant.

\EXAMPLE
Here is a simple example
{\par\samepage\setseps\small
\begin{verbatim}
  # let googolplex = new_basic_definition
     `googolplex = 10 EXP (10 EXP 100)`;;
  val googolplex : thm = |- googolplex = 10 EXP (10 EXP 100)
\end{verbatim}
}
\noindent and of course we can equally well use logical equivalence:
{\par\samepage\setseps\small
\begin{verbatim}
  # let true_def = new_basic_definition `true <=> T`;;
  val true_def : thm = |- true <=> T
\end{verbatim}
}
\noindent The following example helps to explain why the restriction on type
variables is present:
{\par\samepage\setseps\small
\begin{verbatim}
  # new_basic_definition `trivial <=> !x y:A. x = y`;;
  Exception:
  Failure "new_definition: Type variables not reflected in constant".
\end{verbatim}
}
If we had been allowed to get back a definitional theorem, we could separately
type-instantiate it to the 1-element type {\small\verb%1%} and the 2-element type {\small\verb%bool%}. In
one case the RHS is true, and in the other it is false, yet both are asserted
equal to the constant {\small\verb%trivial%}.

\COMMENTS
There are simpler or more convenient ways of making definitions, such as
{\small\verb%define%} and {\small\verb%new_definition%}, but this is the primitive principle underlying
them all.

\SEEALSO
define, new_definition, new_inductive_definition, new_recursive_definition,
new_specification.

\ENDDOC
\DOC{new{\_}basic{\_}type{\_}definition}

\TYPE {\small\verb%new_basic_type_definition : string -> string * string -> thm -> thm * thm%}\egroup

\SYNOPSIS
Introduces a new type in bijection with a nonempty subset of an existing type.

\DESCRIBE
The call {\small\verb%new_basic_type_definition "ty" ("mk","dest") th%} where {\small\verb%th%} is
a theorem of the form {\small\verb%|- P x%} (say {\small\verb%x%} has type {\small\verb%rep%}) will introduce a new
type called {\small\verb%ty%} plus two new constants {\small\verb%mk:rep->ty%} and {\small\verb%dest:ty->rep%},
and return two theorems that together assert that {\small\verb%mk%} and {\small\verb%dest%} establish a
bijection between the universe of the new type {\small\verb%ty%} and the subset of the type
{\small\verb%rep%} identified by the predicate {\small\verb%P%}: {\small\verb%|- mk(dest a) = a%} and
{\small\verb%|- P r <=> dest(mk r) = r%}. If the theorem involves type variables {\small\verb%A1,...,An%}
then the new type will be an $n$-ary type constructor rather than a basic type.
The theorem is needed to ensure that that set is nonempty; all types in HOL are
nonempty.

\FAILURE
Fails if any of the type or constant names is already in use, if the theorem
has a nonempty list of hypotheses, if the conclusion of the theorem is not a
combination, or if its rator {\small\verb%P%} contains free variables.

\EXAMPLE
Here we define a basic type with 32 elements:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ARITH_RULE `(\x. x < 32) 0`;;
  val th : thm = |- (\x. x < 32) 0
  # let absth,repth = new_basic_type_definition "32" ("mk_32","dest_32") th;;
  val absth : thm = |- mk_32 (dest_32 a) = a
  val repth : thm = |- (\x. x < 32) r <=> dest_32 (mk_32 r) = r
\end{verbatim}
}
\noindent and here is a declaration of a type of finite sets over a base type,
a unary type constructor:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = CONJUNCT1 FINITE_RULES;;
  val th : thm = |- FINITE {}

  # let tybij = new_basic_type_definition "fin" ("mk_fin","dest_fin") th;;
  val tybij : thm * thm =
    (|- mk_fin (dest_fin a) = a, |- FINITE r <=> dest_fin (mk_fin r) = r)
\end{verbatim}
}
\noindent so now types like {\small\verb%:(num)fin%} make sense.

\COMMENTS
This is the primitive principle of type definition in HOL Light, but other
functions like {\small\verb%define_type%} or {\small\verb%new_type_definition%} are usually more
convenient.

\SEEALSO
define_type, new_type_definition.

\ENDDOC
\DOC{new{\_}constant}

\TYPE {\small\verb%new_constant : string * hol_type -> unit%}\egroup

\SYNOPSIS
Declares a new constant.

\DESCRIBE
A call {\small\verb%new_constant("c",`:ty`)%} makes {\small\verb%c%} a constant with most general type
{\small\verb%ty%}.

\FAILURE
Fails if there is already a constant of that name in the current theory.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}

  #new_constant("graham's_number",`:num`);;
  val it : unit = ()
\end{verbatim}
}

\USES
Can be useful for declaring some arbitrary parameter, but more usually a
prelude to some new axioms about the constant introduced. Take care when using
{\small\verb%new_axiom%}!

\SEEALSO
constants, new_axiom, new_definition.

\ENDDOC
\DOC{new{\_}definition}

\TYPE {\small\verb%new_definition : term -> thm%}\egroup

\SYNOPSIS
Declare a new constant and a definitional axiom.

\DESCRIBE
The function {\small\verb%new_definition%} provides a facility for definitional extensions.
It takes a term giving the desired definition.  The value returned by
{\small\verb%new_definition%} is a theorem stating the definition requested by the user.

Let {\small\verb%v_1%},...,{\small\verb%v_n%} be tuples of distinct variables, containing the variables
{\small\verb%x_1,...,x_m%}.  Evaluating {\small\verb%new_definition `c v_1 ... v_n = t`%}, where {\small\verb%c%} is a
variable whose name is not already used as a constant, declares {\small\verb%c%} to be a new
constant and returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- !x_1 ... x_m. c v_1 ... v_n = t
\end{verbatim}
}
Optionally, the definitional term argument may have any of its variables
universally quantified.

\FAILURE
{\small\verb%new_definition%} fails if {\small\verb%c%} is already a constant or if the definition does
not have the right form.

\EXAMPLE
A NAND relation on signals indexed by `time' can be defined as follows.
{\par\samepage\setseps\small
\begin{verbatim}
  # new_definition
       `NAND2   (in_1,in_2) out <=> !t:num. out t <=> ~(in_1 t /\ in_2 t)`;;
  val it : thm =
    |- !out in_1 in_2.
           NAND2 (in_1,in_2) out <=> (!t. out t <=> ~(in_1 t /\ in_2 t))
\end{verbatim}
}

\COMMENTS
Note that the conclusion of the theorem returned is essentially the same as the
term input by the user, except that {\small\verb%c%} was a variable in the original term but
is a constant in the returned theorem. The function {\small\verb%define%} is significantly
more flexible in the kinds of definition it allows, but for some purposes this
more basic principle is fine.

\SEEALSO
define, new_basic_definition, new_inductive_definition,
new_recursive_definition, new_specification.

\ENDDOC
\DOC{new{\_}inductive{\_}definition}

\TYPE {\small\verb%new_inductive_definition : term -> thm * thm * thm%}\egroup

\SYNOPSIS
Define a relation or family of relations inductively.

\DESCRIBE
The function {\small\verb%new_inductive_definition%} is applied to a conjunction of
``rules'' of the form {\small\verb%!x1...xn. Pi ==> Ri t1 ... tk%}. This conjunction is
interpreted as an inductive definition of a set of relations {\small\verb%Ri%} (however many
appear in the consequents of the rules). That is, the relations are defined to
be the smallest ones closed under the rules. The function
{\small\verb%new_inductive_definition%} will convert this into explicit definitions, define
a new constant for each {\small\verb%Ri%}, and return a triple of theorems. The first one
will be the ``rule'' theorem, which essentially matches the input clauses
except that the {\small\verb%Ri%} are now the new constants; this simply says that the new
relations are indeed closed under the rules. The second theorem is an induction
theorem, asserting that the relations are the least ones closed under the
rules. Finally, the cases theorem gives a case analysis theorem showing how
each set of values satisfying the relation may be composed.

\FAILURE
Fails if the clauses are malformed, if the constants are already in use, or if
there are unproven monotonicity hypotheses. In the last case, you can try
{\small\verb%prove_inductive_relations_exist%} to examine these hypotheses, and either try
to prove them manually or extend {\small\verb%monotonicity_theorems%} to let HOL do it.

\EXAMPLE
A classic example where we have mutual induction is the set of even and odd
numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  # let eo_RULES,eo_INDUCT, eo_CASES = new_inductive_definition
     `even(0) /\ odd(1) /\
      (!n. even(n) ==> odd(n + 1)) /\
      (!n. odd(n) ==> even(n + 1))`;;
  val eo_RULES : thm =
    |- even 0 /\
       odd 1 /\
       (!n. even n ==> odd (n + 1)) /\
       (!n. odd n ==> even (n + 1))
  val eo_INDUCT : thm =
    |- !odd' even'.
           even' 0 /\
           odd' 1 /\
           (!n. even' n ==> odd' (n + 1)) /\
           (!n. odd' n ==> even' (n + 1))
           ==> (!a0. odd a0 ==> odd' a0) /\ (!a1. even a1 ==> even' a1)
  val eo_CASES : thm =
    |- (!a0. odd a0 <=> a0 = 1 \/ (?n. a0 = n + 1 /\ even n)) /\
       (!a1. even a1 <=> a1 = 0 \/ (?n. a1 = n + 1 /\ odd n))
\end{verbatim}
}
Note that the `rules' theorem corresponds exactly to the input, and says that
indeed the relations do satisfy the rules. The `induction' theorem says that
the relations are the minimal ones satisfying the rules. You can use this to
prove properties by induction, e.g. the relationship with the pre-defined
concepts of odd and even:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!n. odd(n) ==> ODD(n)) /\ (!n. even(n) ==> EVEN(n))`;;
\end{verbatim}
}
\noindent applying the induction theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MATCH_MP_TAC eo_INDUCT);;
  val it : goalstack = 1 subgoal (1 total)

  `EVEN 0 /\
   ODD 1 /\
   (!n. EVEN n ==> ODD (n + 1)) /\
   (!n. ODD n ==> EVEN (n + 1))`
\end{verbatim}
}
\noindent This is easily finished off by, for example:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[GSYM NOT_EVEN; EVEN_ADD; ARITH]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

For another example, consider defining a simple propositional logic:
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_as_infix("-->",(13,"right"));;
  val it : unit = ()
  # let form_tybij = define_type "form = False | --> form form";;
  val form_tybij : thm * thm =
    (|- !P. P False /\ (!a0 a1. P a0 /\ P a1 ==> P (a0 --> a1)) ==> (!x. P x),
     |- !f0 f1.
            ?fn. fn False = f0 /\
                 (!a0 a1. fn (a0 --> a1) = f1 a0 a1 (fn a0) (fn a1)))
\end{verbatim}
}
\noindent and making an inductive definition of the provability relation:
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_as_infix("|--",(11,"right"));;
  val it : unit = ()

  # let provable_RULES,provable_INDUCT,provable_CASES = new_inductive_definition
   `(!p. p IN A ==> A |-- p) /\
    (!p q. A |-- p --> (q --> p)) /\
    (!p q r. A |-- (p --> q --> r) --> (p --> q) --> (p --> r)) /\
    (!p. A |-- ((p --> False) --> False) --> p) /\
    (!p q. A |-- p --> q /\ A |-- p ==> A |-- q)`;;
  val provable_RULES : thm =
    |- !A. (!p. p IN A ==> A |-- p) /\
           (!p q. A |-- p --> q --> p) /\
           (!p q r. A |-- (p --> q --> r) --> (p --> q) --> p --> r) /\
           (!p. A |-- ((p --> False) --> False) --> p) /\
           (!p q. A |-- p --> q /\ A |-- p ==> A |-- q)
  val provable_INDUCT : thm =
    |- !A |--'.
           (!p. p IN A ==> |--' p) /\
           (!p q. |--' (p --> q --> p)) /\
           (!p q r. |--' ((p --> q --> r) --> (p --> q) --> p --> r)) /\
           (!p. |--' (((p --> False) --> False) --> p)) /\
           (!p q. |--' (p --> q) /\ |--' p ==> |--' q)
           ==> (!a. A |-- a ==> |--' a)
  val provable_CASES : thm =
    |- !A a.
           A |-- a <=>
           a IN A \/
           (?p q. a = p --> q --> p) \/
           (?p q r. a = (p --> q --> r) --> (p --> q) --> p --> r) \/
           (?p. a = ((p --> False) --> False) --> p) \/
           (?p. A |-- p --> a /\ A |-- p)
\end{verbatim}
}
Note that {\small\verb%A%} is not universally quantified in the clauses, and is therefore
treated as a parameter.

\SEEALSO
derive_strong_induction, new_inductive_set, prove_inductive_relations_exist,
prove_monotonicity_hyps.

\ENDDOC
\DOC{new{\_}inductive{\_}set}

\TYPE {\small\verb%new_inductive_set : term -> thm * thm * thm%}\egroup

\SYNOPSIS
Define a set or family of sets inductively.

\DESCRIBE
The function {\small\verb%new_inductive_set%} is applied to a conjunction of ``rules'', each
of the form {\small\verb%!x1...xn. Pi ==> ti IN Sk%}. This conjunction is interpreted as an
inductive definition of a family of sets {\small\verb%Sk%} (however many appear in the
consequents of the rules). That is, the sets are defined to be the smallest
ones closed under the rules. The function {\small\verb%new_inductive_set%} will convert this
into explicit definitions, define a new constant for each {\small\verb%Sk%}, and return a
triple of theorems. The first one will be the ``rule'' theorem, which
essentially matches the input clauses except that the {\small\verb%Si%} are now the new
constants; this simply says that the new sets are indeed closed under the
rules. The second theorem is an induction theorem, asserting that the sets are
the least ones closed under the rules. Finally, the cases theorem gives a case
analysis theorem showing how each set of values satisfying the set may be
composed.

\FAILURE
Fails if the clauses are malformed, if the constants are already in use, or if
there are unproven monotonicity hypotheses. See {\small\verb%new_inductive_definition%} for
more detailed discussion in the similar case of indunctive relations.

\EXAMPLE
A classic example where we have mutual induction is the set of even and odd
numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  # let EO_RULES, EO_INDUCT, EO_CASES = new_inductive_set
    `0 IN even_numbers /\
     (!n. n IN even_numbers ==> SUC n IN odd_numbers) /\
     1 IN odd_numbers /\
     (!n. n IN odd_numbers ==> SUC n IN even_numbers)`;;
  val EO_RULES : thm =
    |- 0 IN even_numbers /\
       (!n. n IN even_numbers ==> SUC n IN odd_numbers) /\
       1 IN odd_numbers /\
       (!n. n IN odd_numbers ==> SUC n IN even_numbers)
  val EO_INDUCT : thm =
    |- !odd_numbers' even_numbers'.
           even_numbers' 0 /\
           (!n. even_numbers' n ==> odd_numbers' (SUC n)) /\
           odd_numbers' 1 /\
           (!n. odd_numbers' n ==> even_numbers' (SUC n))
           ==> (!a0. a0 IN odd_numbers ==> odd_numbers' a0) /\
               (!a1. a1 IN even_numbers ==> even_numbers' a1)
  val EO_CASES : thm =
    |- (!a0. a0 IN odd_numbers <=>
             (?n. a0 = SUC n /\ n IN even_numbers) \/ a0 = 1) /\
       (!a1. a1 IN even_numbers <=>
             a1 = 0 \/ (?n. a1 = SUC n /\ n IN odd_numbers))
\end{verbatim}
}
Note that the `rules' theorem corresponds exactly to the input, and says that
indeed the sets do satisfy the rules. The `induction' theorem says that
the sets are the minimal ones satisfying the rules. You can use this to
prove properties by induction, e.g. the relationship with the pre-defined
concepts of odd and even:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(!n. n IN odd_numbers ==> ODD(n)) /\
       (!n. n IN even_numbers ==> EVEN(n))`;;
\end{verbatim}
}
\noindent applying the induction theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MATCH_MP_TAC EO_INDUCT);;
  val it : goalstack = 1 subgoal (1 total)

  `EVEN 0 /\
   (!n. EVEN n ==> ODD (SUC n)) /\
   ODD 1 /\
   (!n. ODD n ==> EVEN (SUC n))`
\end{verbatim}
}
\noindent This is easily finished off by, for example:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[GSYM NOT_EVEN; EVEN; ARITH]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

This function uses {\small\verb%new_inductive_relation%} internally, and the documentation
for that function gives additional information and other relevant examples.

\SEEALSO
derive_strong_induction, new_inductive_definition,
prove_inductive_relations_exist, prove_monotonicity_hyps.

\ENDDOC
\DOC{new{\_}recursive{\_}definition}

\TYPE {\small\verb%new_recursive_definition : thm -> term -> thm%}\egroup

\SYNOPSIS
Define recursive function over inductive type.

\DESCRIBE
{\small\verb%new_recursive_definition%} provides the facility for defining primitive
recursive functions on arbitrary inductive types.  The first argument is the
primitive recursion theorem for the concrete type in question; this is normally
the second theorem obtained from {\small\verb%define_type%}. The second argument is a term
giving the desired primitive recursive function definition. The value returned
by {\small\verb%new_recursive_definition%} is a theorem stating the primitive recursive
definition requested by the user. This theorem is derived by formal proof from
an instance of the general primitive recursion theorem given as the second
argument.

Let {\small\verb%C1%}, ..., {\small\verb%Cn%} be the constructors of the type, and let `{\small\verb%(Ci vs)%}'
represent a (curried) application of the {\small\verb%i%}th constructor to a sequence of
variables.  Then a curried primitive recursive function {\small\verb%fn%} over {\small\verb%ty%} can be
specified by a conjunction of (optionally universally-quantified) clauses of
the form:
{\par\samepage\setseps\small
\begin{verbatim}
   fn v1 ... (C1 vs1) ... vm  =  body1   /\
   fn v1 ... (C2 vs2) ... vm  =  body2   /\
                             .
                             .
   fn v1 ... (Cn vsn) ... vm  =  bodyn
\end{verbatim}
}
\noindent where the variables {\small\verb%v1%}, ..., {\small\verb%vm%}, {\small\verb%vs%} are distinct in each
clause, and where in the {\small\verb%i%}th clause {\small\verb%fn%} appears (free) in {\small\verb%bodyi%} only
as part of an application of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   `fn t1 ... v ... tm`
\end{verbatim}
}
\noindent in which the variable {\small\verb%v%} of type {\small\verb%ty%} also occurs among the
variables {\small\verb%vsi%}.

If {\small\verb%<definition>%} is a conjunction of clauses, as described above, then
evaluating:
{\par\samepage\setseps\small
\begin{verbatim}
   new_recursive_definition th `<definition>`;;
\end{verbatim}
}
\noindent automatically proves the existence of a function {\small\verb%fn%} that satisfies
the defining equations, and then declares a new constant with this definition
as its specification.

{\small\verb%new_recursive_definition%} also allows the supplied definition to omit clauses
for any number of constructors.  If a defining equation for the {\small\verb%i%}th
constructor is omitted, then the value of {\small\verb%fn%} at that constructor:
{\par\samepage\setseps\small
\begin{verbatim}
   fn v1 ... (Ci vsi) ... vn
\end{verbatim}
}
\noindent is left unspecified ({\small\verb%fn%}, however, is still a total function).

\FAILURE
Fails if the definition cannot be matched up with the recursion theorem
provided (you may find that {\small\verb%define%} still works in such cases), or if there is
already a constant of the given name.

\EXAMPLE
The following defines a function to produce the union of a list of sets:
{\par\samepage\setseps\small
\begin{verbatim}
  # let LIST_UNION = new_recursive_definition list_RECURSION
    `(LIST_UNION [] = {}) /\
     (LIST_UNION (CONS h t) = h UNION (LIST_UNION t))`;;
      Warning: inventing type variables
  val ( LIST_UNION ) : thm =
    |- LIST_UNION [] = {} /\ LIST_UNION (CONS h t) = h UNION LIST_UNION t
\end{verbatim}
}

\COMMENTS
For many purposes, {\small\verb%define%} is a simpler way of defining recursive types; it
has a simpler interface (no need to specify the recursion theorem to use) and
it is more general. However, for suitably constrained definitions
{\small\verb%new_recursive_definition%} works well and is much more efficient.

\SEEALSO
define, prove_inductive_relations_exist, prove_recursive_functions_exist.

\ENDDOC
\DOC{new{\_}specification}

\TYPE {\small\verb%new_specification : string list -> thm -> thm%}\egroup

\SYNOPSIS
Introduces a constant or constants satisfying a given property.

\DESCRIBE
The ML function {\small\verb%new_specification%} implements the primitive rule of
constant specification for the HOL logic.
Evaluating:
{\par\samepage\setseps\small
\begin{verbatim}
   new_specification ["c1";...;"cn"] |- ?x1...xn. t
\end{verbatim}
}
\noindent simultaneously introduces new constants named {\small\verb%c1%}, ..., {\small\verb%cn%}
satisfying the property:
{\par\samepage\setseps\small
\begin{verbatim}
   |- t[c1,...,cn/x1,...,xn]
\end{verbatim}
}
\noindent This theorem is returned by the call to {\small\verb%new_specification%}.

\FAILURE
{\small\verb%new_specification%} fails if any one of {\small\verb%`c1`%}, ..., {\small\verb%`cn`%} is already a
constant.

\USES
{\small\verb%new_specification%} can be used to introduce constants that satisfy a given
property without having to make explicit equational constant definitions for
them.  For example, the built-in constants {\small\verb%MOD%} and {\small\verb%DIV%} are defined in the
system by first proving the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # DIVMOD_EXIST_0;;
  val it : thm =
    |- !m n. ?q r. if n = 0 then q = 0 /\ r = 0 else m = q * n + r /\ r < n
\end{verbatim}
}
\noindent Skolemizing it to made the parametrization explicit:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = REWRITE_RULE[SKOLEM_THM] DIVMOD_EXIST_0;;
  val th : thm =
    |- ?q r.
           !m n.
               if n = 0
               then q m n = 0 /\ r m n = 0
               else m = q m n * n + r m n /\ r m n < n
\end{verbatim}
}
\noindent and then making the constant specification:
{\par\samepage\setseps\small
\begin{verbatim}
  # new_specification ["DIV"; "MOD"] th;;
\end{verbatim}
}
\noindent giving the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # DIVISION_0;;
  val it : thm =
    |- !m n.
           if n = 0
           then m DIV n = 0 /\ m MOD n = 0
           else m = m DIV n * n + m MOD n /\ m MOD n < n
\end{verbatim}
}

\SEEALSO
define, new_definition.

\ENDDOC
\DOC{new{\_}type}

\TYPE {\small\verb%new_type : string * int -> unit%}\egroup

\SYNOPSIS
Declares a new type or type constructor.

\DESCRIBE
A call {\small\verb%new_type("t",n)%} declares a new {\small\verb%n%}-ary type constructor called {\small\verb%t%}; if
{\small\verb%n%} is zero, this is just a new base type.

\FAILURE
Fails if there is already a type operator of that name.

\EXAMPLE
A version of ZF set theory might declare a new type {\small\verb%set%} and start using it as
follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # new_type("set",0);;
  val it : unit = ()
  # new_constant("mem",`:set->set->bool`);;
  val it : unit = ()
  # parse_as_infix("mem",(11,"right"));;
  val it : unit = ()
  # let ZF_EXT = new_axiom `(!z. z mem x <=> z mem y) ==> (x = y)`;;
  val ( ZF_EXT ) : thm = |- (!z. z mem x <=> z mem y) ==> x = y
\end{verbatim}
}

\COMMENTS
As usual, asserting new concepts is discouraged; if possible it is better to
use type definitions; see {\small\verb%new_type_definition%} and {\small\verb%define_type%}.

\SEEALSO
define_type, new_axiom, new_constant, new_definition, new_type_definition.

\ENDDOC
\DOC{new{\_}type{\_}abbrev}

\TYPE {\small\verb%new_type_abbrev : string * hol_type -> unit%}\egroup

\SYNOPSIS
Sets up a new type abbreviation.

\DESCRIBE
A call {\small\verb%new_type_abbrev("ab",`:ty`%} creates a new type abbreviation {\small\verb%ab%} for
the type {\small\verb%ty%}. In future, {\small\verb%`:ab`%} may be used rather than the perhaps
complicated expression {\small\verb%`:ty`%}. Note that the association is purely an
abbreviation for parsing. Type abbreviations have no logical significance;
types are internally represented after the abbreviations have been fully
expanded. At present, type abbreviations are not reversed when printing types,
mainly because this may contract abbreviations where it is unwanted.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # new_type_abbrev("bitvector",`:bool list`);;
  val it : unit = ()

  # `LENGTH(x:bitvector)`;;
  val it : term = `LENGTH x`

  # type_of (rand it);;
  val it : hol_type = `:(bool)list`
\end{verbatim}
}

\SEEALSO
define_type, new_type_definition, remove_type_abbrev, type_abbrevs.

\ENDDOC
\DOC{new{\_}type{\_}definition}

\TYPE {\small\verb%new_type_definition : string -> string * string -> thm -> thm%}\egroup

\SYNOPSIS
Introduces a new type in bijection with a nonempty subset of an existing type.

\DESCRIBE
The call {\small\verb%new_basic_type_definition "ty" ("mk","dest") th%} where {\small\verb%th%} is
a theorem of the form {\small\verb%|- ?x. P[x]%} (say {\small\verb%x%} has type {\small\verb%rep%}) will introduce a
new type called {\small\verb%ty%} plus two new constants {\small\verb%mk:rep->ty%} and {\small\verb%dest:ty->rep%},
and return a theorem asserting that {\small\verb%mk%} and {\small\verb%dest%} establish a bijection
between the universe of the new type {\small\verb%ty%} and the subset of the type {\small\verb%rep%}
identified by the predicate {\small\verb%P%}:
{\par\samepage\setseps\small
\begin{verbatim}
  |- (!a. mk(dest a) = a) /\ (!r. P[r] <=> dest(mk r) = r)
\end{verbatim}
}
\noindent If the theorem involves type variables {\small\verb%A1,...,An%} then the new type
will be an $n$-ary type constructor rather than a basic type. The theorem is
needed to ensure that that set is nonempty; all types in HOL are nonempty.

\EXAMPLE
Here we define a basic type with 7 elements:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = prove(`?x. x < 7`,EXISTS_TAC `0` THEN ARITH_TAC);;
  val th : thm = |- ?x. x < 7

  # let tybij = new_type_definition "7" ("mk_7","dest_7") th;;
  val tybij : thm =
    |- (!a. mk_7 (dest_7 a) = a) /\ (!r. r < 7 <=> dest_7 (mk_7 r) = r)
\end{verbatim}
}
\noindent and here is a declaration of a type of finite sets over a base type,
a unary type constructor:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = MESON[FINITE_RULES] `?s:A->bool. FINITE s`;;
   0..0..solved at 2
  CPU time (user): 0.
  val th : thm = |- ?s. FINITE s

  # let tybij = new_type_definition "finiteset" ("mk_fin","dest_fin") th;;
  val tybij : thm =
    |- (!a. mk_fin (dest_fin a) = a) /\
       (!r. FINITE r <=> dest_fin (mk_fin r) = r)
\end{verbatim}
}
\noindent so now types like {\small\verb%:(num)finiteset%} make sense.

\FAILURE
Fails if any of the type or constant names is already in use, if the theorem
has a nonempty list of hypotheses, if the conclusion of the theorem is not an
existentially quantified term, or the conclusion contains free variables.

\SEEALSO
define_type, new_basic_type_definition, new_type_abbrev.

\ENDDOC
\DOC{NNFC{\_}CONV}

\TYPE {\small\verb%NNFC_CONV : conv%}\egroup

\SYNOPSIS
Convert a term to negation normal form.

\DESCRIBE
The conversion {\small\verb%NNFC_CONV%} proves a term equal to an equivalent in `negation
normal form' (NNF). This means that other propositional connectives are
eliminated in favour of conjunction (`{\small\verb%/\%}'), disjunction (`{\small\verb%\/%}') and negation
(`{\small\verb%~%}'), and the negations are pushed down to the level of atomic formulas,
also through universal and existential quantifiers, with double negations
eliminated.

\FAILURE
Never fails; on non-Boolean terms it just returns a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NNFC_CONV `(!x. p(x) <=> q(x)) ==> ~ ?y. p(y) /\ ~q(y)`;;
  Warning: inventing type variables
  val it : thm =
    |- (!x. p x <=> q x) ==> ~(?y. p y /\ ~q y) <=>
       (?x. (p x \/ q x) /\ (~p x \/ ~q x)) \/ (!y. ~p y \/ q y)
\end{verbatim}
}

\USES
Mostly useful as a prelude to automated proof procedures, but users may
sometimes find it useful.

\COMMENTS
A toplevel equivalence {\small\verb%p <=> q%} is converted to {\small\verb%(p \/ ~q) /\ (~p \/ q)%}. In
general this ``splitting'' of equivalences is done with the expectation that
the final formula may be put into conjunctive normal form (CNF), as a prelude
to a proof (rather than refutation) procedure. An otherwise similar conversion
{\small\verb%NNF_CONV%} prefers a `disjunctive' splitting and is better suited for a term
that will later be translated to DNF for refutation.

\SEEALSO
GEN_NNF_CONV, NNF_CONV.

\ENDDOC
\DOC{NNF{\_}CONV}

\TYPE {\small\verb%NNF_CONV : conv%}\egroup

\SYNOPSIS
Convert a term to negation normal form.

\DESCRIBE
The conversion {\small\verb%NNF_CONV%} proves a term equal to an equivalent in `negation
normal form' (NNF). This means that other propositional connectives are
eliminated in favour of conjunction (`{\small\verb%/\%}'), disjunction (`{\small\verb%\/%}') and negation
(`{\small\verb%~%}'), and the negations are pushed down to the level of atomic formulas,
also through universal and existential quantifiers, with double negations
eliminated.

\FAILURE
Never fails; on non-Boolean terms it just returns a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NNF_CONV `(!x. p(x) <=> q(x)) ==> ~ ?y. p(y) /\ ~q(y)`;;
  Warning: inventing type variables
  val it : thm =
    |- (!x. p x <=> q x) ==> ~(?y. p y /\ ~q y) <=>
       (?x. p x /\ ~q x \/ ~p x /\ q x) \/ (!y. ~p y \/ q y)
\end{verbatim}
}

\USES
Mostly useful as a prelude to automated proof procedures, but users may
sometimes find it useful.

\COMMENTS
A toplevel equivalence {\small\verb%p <=> q%} is converted to {\small\verb%(p /\ q) \/ (~p /\ ~q)%}. In
general this ``splitting'' of equivalences is done with the expectation that
the final formula may be put into disjunctive normal form (DNF), as a prelude
to a refutation procedure. An otherwise similar conversion {\small\verb%NNFC_CONV%} prefers
a `conjunctive' splitting and is better suited for a term that will later be
translated to CNF.

\SEEALSO
GEN_NNF_CONV, NNFC_CONV.

\ENDDOC
\DOC{nothing}

\TYPE {\small\verb%nothing : 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Trivial parser that parses nothing.

\DESCRIBE
The parser {\small\verb%nothing%} parses nothing: it returns the empty list as its parsed
item and all the input as its unparsed input.

\FAILURE
Never fails.

\USES
This can be useful in alternations (`{\small\verb%|||%}') with other parsers producing a list
of items.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, many,
possibly, rightbin, some.

\ENDDOC
\DOC{NOT{\_}ELIM}

\TYPE {\small\verb%NOT_ELIM : thm -> thm%}\egroup

\SYNOPSIS
Transforms {\small\verb%|- ~t%} into {\small\verb%|- t ==> F%}.

\DESCRIBE
When applied to a theorem {\small\verb%A |- ~t%}, the inference rule {\small\verb%NOT_ELIM%} returns the
theorem {\small\verb%A |- t ==> F%}.
{\par\samepage\setseps\small
\begin{verbatim}
      A |- ~t
   --------------  NOT_ELIM
    A |- t ==> F
\end{verbatim}
}

\FAILURE
Fails unless the theorem has a negated conclusion.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = UNDISCH(TAUT `p ==> ~ ~p`);;
  val th : thm = p |- ~ ~p

  # NOT_ELIM th;;
  val it : thm = p |- ~p ==> F
\end{verbatim}
}

\SEEALSO
EQF_ELIM, EQF_INTRO, NOT_INTRO.

\ENDDOC
\DOC{NOT{\_}INTRO}

\TYPE {\small\verb%NOT_INTRO : thm -> thm%}\egroup

\SYNOPSIS
Transforms {\small\verb%|- t ==> F%} into {\small\verb%|- ~t%}.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t ==> F%}, the inference rule {\small\verb%NOT_INTRO%}
returns the theorem {\small\verb%A |- ~t%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t ==> F
   --------------  NOT_INTRO
      A |- ~t
\end{verbatim}
}

\FAILURE
Fails unless the theorem has an implicative conclusion with {\small\verb%F%}
as the consequent.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = TAUT `F ==> F`;;
  val th : thm = |- F ==> F

  # NOT_INTRO th;;
  val it : thm = |- ~F
\end{verbatim}
}

\SEEALSO
EQF_ELIM, EQF_INTRO, NOT_ELIM.

\ENDDOC
\DOC{NO{\_}CONV}

\TYPE {\small\verb%NO_CONV : conv%}\egroup

\SYNOPSIS
Conversion that always fails.

\FAILURE
{\small\verb%NO_CONV%} always fails.

\SEEALSO
ALL_CONV.

\ENDDOC
\DOC{NO{\_}TAC}

\TYPE {\small\verb%NO_TAC : tactic%}\egroup

\SYNOPSIS
Tactic that always fails.

\DESCRIBE
Whatever goal it is applied to, {\small\verb%NO_TAC%} always fails with {\small\verb%Failure "NO_TAC"%}.

\FAILURE
Always fails.

\EXAMPLE
However trivial the goal, {\small\verb%NO_TAC%} always fails:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `T`;;
  val it : goalstack = 1 subgoal (1 total)

  `T`

  # e NO_TAC;;
  Exception: Failure "NO_TAC".
\end{verbatim}
}
\noindent however, {\small\verb%tac THEN NO_TAC%} will never reach {\small\verb%NO_TAC%} if {\small\verb%tac%} leaves
no subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[] THEN NO_TAC);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Can be useful in forcing certain ``speculative'' tactics to fail unless they
solve the goal completely. For example, you might wish to break down a huge
conjunction of goals and attempt to solve as many conjuncts as possible by
just rewriting with a list of theorems {\small\verb%[thl]%}. You could do:
{\par\samepage\setseps\small
\begin{verbatim}
  REPEAT CONJ_TAC THEN REWRITE_TAC[thl]
\end{verbatim}
}
\noindent However, if you don't want to apply the rewrites unless they result
in an immediate solution, you can do instead:
{\par\samepage\setseps\small
\begin{verbatim}
  REPEAT CONJ_TAC THEN TRY(REWRITE_TAC[thl] THEN NO_TAC)
\end{verbatim}
}

\SEEALSO
ALL_TAC, ALL_THEN, FAIL_TAC, NO_THEN.

\ENDDOC
\DOC{NO{\_}THEN}

\TYPE {\small\verb%NO_THEN : thm_tactical%}\egroup

\SYNOPSIS
Theorem-tactical which always fails.

\DESCRIBE
When applied to a theorem-tactic and a theorem, the theorem-tactical
{\small\verb%NO_THEN%} always fails with {\small\verb%Failwith "NO_THEN"%}.

\FAILURE
Always fails when applied to a theorem-tactic and a theorem (note that it
never gets as far as being applied to a goal!)

\USES
Writing compound tactics or tacticals.

\SEEALSO
ALL_TAC, ALL_THEN, FAIL_TAC, NO_TAC.

\ENDDOC
\DOC{nsplit}

\TYPE {\small\verb%nsplit : ('a -> 'b * 'a) -> 'c list -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Applies a destructor in right-associative mode a specified number of times.

\DESCRIBE
If {\small\verb%d%} is an inverse to a binary constructor {\small\verb%f%}, then
{\par\samepage\setseps\small
\begin{verbatim}
  nsplit d l (f(x1,f(x2,...f(xn,y))))
\end{verbatim}
}
\noindent where the list {\small\verb%l%} has length {\small\verb%k%}, returns
{\par\samepage\setseps\small
\begin{verbatim}
  ([x1;...;xk],f(x(k+1),...f(xn,y))
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # nsplit dest_conj [1;2;3] `a /\ b /\ c /\ d /\ e /\ f`;;
  val it : term list * term = ([`a`; `b`; `c`], `d /\ e /\ f`)
\end{verbatim}
}

\SEEALSO
splitlist, rev_splitlist, striplist.

\ENDDOC
\DOC{null{\_}inst}

\TYPE {\small\verb%null_inst : instantiation%}\egroup

\SYNOPSIS
Empty instantiation.

\DESCRIBE
Several functions use objects of type {\small\verb%instantiation%}, consisting of type and
term instantiations and higher-order matching information. This instantiation
{\small\verb%null_inst%} is the trivial instantiation that does nothing.

\FAILURE
Not applicable.

\EXAMPLE
Instantiating a term with it has no effect:
{\par\samepage\setseps\small
\begin{verbatim}
  # instantiate null_inst `x + 1 = 2`;;
  val it : term = `x + 1 = 2`
\end{verbatim}
}

\SEEALSO
instantiate, INSTANTIATE, INSTANTIATE_ALL, term_match.

\ENDDOC
\DOC{null{\_}meta}

\TYPE {\small\verb%null_meta : term list * instantiation%}\egroup

\SYNOPSIS
Empty metavariable information.

\DESCRIBE
This is a pair consisting of an empty list of terms and a null instantiation
(see {\small\verb%null_inst%}). It is used inside most tactics to indicate that they do
nothing interesting with metavariables.

\FAILURE
Not applicable.

\COMMENTS
This is not intended for general use, but readers writing custom tactics from
scratch may find it convenient.

\SEEALSO
null_inst.

\ENDDOC
\DOC{NUMBER{\_}RULE}

\TYPE {\small\verb%NUMBER_RULE : term -> thm%}\egroup

\SYNOPSIS
Automatically prove elementary divisibility property over the natural numbers.

\DESCRIBE
{\small\verb%NUMBER_RULE%} is a partly heuristic rule that can often automatically prove
elementary ``divisibility'' properties of the natural numbers. The precise
subset that is dealt with is difficult to describe rigorously, but many
universally quantified combinations of {\small\verb%divides%}, {\small\verb%coprime%}, {\small\verb%gcd%} and
congruences {\small\verb%(x == y) (mod n)%} can be proved automatically, as well as some
existentially quantified goals. See a similar rule {\small\verb%INTEGER_RULE%} for the
integers for a representative set of examples.

\FAILURE
Fails if the goal is not accessible to the methods used.

\EXAMPLE
Here is a typical example, which would be rather tedious to prove manually:
{\par\samepage\setseps\small
\begin{verbatim}
  # NUMBER_RULE
     `!a b a' b'. ~(gcd(a,b) = 0) /\ a = a' * gcd(a,b) /\ b = b' * gcd(a,b)
                  ==> coprime(a',b')`;;
  ...
  val it : thm =
  |- !a b a' b'.
        ~(gcd (a,b) = 0) /\ a = a' * gcd (a,b) /\ b = b' * gcd (a,b)
        ==> coprime (a',b')
\end{verbatim}
}

\SEEALSO
ARITH_RULE, INTEGER_RULE, NUMBER_TAC, NUM_RING.

\ENDDOC
\DOC{NUMBER{\_}TAC}

\TYPE {\small\verb%NUMBER_TAC : tactic%}\egroup

\SYNOPSIS
Automated tactic for elementary divisibility properties over the natural
numbers.

\DESCRIBE
The tactic {\small\verb%NUMBER_TAC%} is a partly heuristic tactic that can often
automatically prove elementary ``divisibility'' properties of the natural
numbers. The precise subset that is dealt with is difficult to describe
rigorously, but many universally quantified combinations of {\small\verb%divides%},
{\small\verb%coprime%}, {\small\verb%gcd%} and congruences {\small\verb%(x == y) (mod n)%} can be proved
automatically, as well as some existentially quantified goals. See the
documentation for {\small\verb%INTEGER_RULE%} for a larger set of representative examples.

\FAILURE
Fails if the goal is not accessible to the methods used.

\EXAMPLE
A typical elementary divisibility property is that if two numbers are congruent
with respect to two coprime (without non-trivial common factors) moduli, then
they are congruent with respect to their product:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m n x y:num. (x == y) (mod m) /\ (x == y) (mod n) /\ coprime(m,n)
                     ==> (x == y) (mod (m * n))`;;
  ...
\end{verbatim}
}
\noindent It can be solved automatically using {\small\verb%NUMBER_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e NUMBER_TAC;;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}
The analogous goal without the coprimality assumption will fail, and indeed the
goal would be false without it.

\SEEALSO
ARITH_TAC, INTEGER_TAC, NUMBER_RULE, NUM_RING.

\ENDDOC
\DOC{numdom}

\TYPE {\small\verb%numdom : num -> num * num%}\egroup

\SYNOPSIS
Returns numerator and denominator of normalized fraction.

\DESCRIBE
Given a rational number as supported by the {\small\verb%Num%} library, {\small\verb%numdom%} returns a
numerator-denominator pair corresponding to that rational number cancelled down
to its reduced form, $p/q$ where $q > 0$ and $p$ and $q$ have no common factor.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # numdom(Int 22 // Int 7);;
  val it : num * num = (22, 7)
  # numdom(Int 0);;
  val it : num * num = (0, 1)
  # numdom(Int 100);;
  val it : num * num = (100, 1)
  # numdom(Int 4 // Int(-2));;
  val it : num * num = (-2, 1)
\end{verbatim}
}

\SEEALSO
denominator, numerator.

\ENDDOC
\DOC{numerator}

\TYPE {\small\verb%numerator : num -> num%}\egroup

\SYNOPSIS
Returns numerator of rational number in canonical form.

\DESCRIBE
Given a rational number as supported by the {\small\verb%Num%} library, {\small\verb%numerator%} returns
the numerator $p$ from the rational number cancelled to its reduced form, $p/q$
where $q > 0$ and $p$ and $q$ have no common factor.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # numerator(Int 22 // Int 7);;
  val it : num = 22
  # numerator(Int 0);;
  val it : num = 0
  # numerator(Int 100);;
  val it : num = 100
  # numerator(Int 4 // Int(-2));;
  val it : num = -2
\end{verbatim}
}

\SEEALSO
denominator, numdom.

\ENDDOC
\DOC{NUMSEG{\_}CONV}

\TYPE {\small\verb%NUMSEG_CONV : conv%}\egroup

\SYNOPSIS
Expands a specific interval {\small\verb%m..n%} to a set enumeration.

\DESCRIBE
When applied to a term {\small\verb%`m..n`%} (the segment of natural numbers between
{\small\verb%m%} and {\small\verb%n%}) for specific numerals {\small\verb%m%} and {\small\verb%n%}, the conversion {\small\verb%NUMSEG_CONV%}
returns a theorem of the form {\small\verb%|- m..n = {m, ..., n}%} expressing that segment
as a set enumeration.

\FAILURE
Fails unless applied to a term of the form {\small\verb%m..n%} for specific numerals {\small\verb%m%} and
{\small\verb%n%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUMSEG_CONV `7..11`;;
  val it : thm = |- 7..11 = {7, 8, 9, 10, 11}

  # NUMSEG_CONV `24..7`;;
  val it : thm = |- 24..7 = {}
\end{verbatim}
}

\SEEALSO
EXPAND_CASES_CONV, EXPAND_NSUM_CONV, EXPAND_SUM_CONV, SET_RULE, SET_TAC.

\ENDDOC
\DOC{num{\_}0}

\TYPE {\small\verb%num_0 : num%}\egroup

\SYNOPSIS
Constant zero in unlimited-size integers.

\DESCRIBE
The constant {\small\verb%num_0%} is bound to the integer constant 0 in the
unlimited-precision numbers provided by the OCaml {\small\verb%Num%} library.

\FAILURE
Not applicable.

\USES
Exactly the same as {\small\verb%Int 0%}, but may save recreation of a cons cell each time.

\SEEALSO
num_1, num_2, num_10.

\ENDDOC
\DOC{num{\_}1}

\TYPE {\small\verb%num_1 : num%}\egroup

\SYNOPSIS
Constant one in unlimited-size integers.

\DESCRIBE
The constant {\small\verb%num_1%} is bound to the integer constant 1 in the
unlimited-precision numbers provided by the OCaml {\small\verb%Num%} library.

\FAILURE
Not applicable.

\USES
Exactly the same as {\small\verb%Int 1%}, but may save recreation of a cons cell each time.

\SEEALSO
num_0, num_2, num_10.

\ENDDOC
\DOC{num{\_}10}

\TYPE {\small\verb%num_10 : num%}\egroup

\SYNOPSIS
Constant ten in unlimited-size integers.

\DESCRIBE
The constant {\small\verb%num_10%} is bound to the integer constant 10 in the
unlimited-precision numbers provided by the OCaml {\small\verb%Num%} library.

\FAILURE
Not applicable.

\USES
Exactly the same as {\small\verb%Int 10%}, but may save recreation of a cons cell each time.

\SEEALSO
num_0, num_1, num_2.

\ENDDOC
\DOC{num{\_}2}

\TYPE {\small\verb%num_2 : num%}\egroup

\SYNOPSIS
Constant two in unlimited-size integers.

\DESCRIBE
The constant {\small\verb%num_2%} is bound to the integer constant 2 in the
unlimited-precision numbers provided by the OCaml {\small\verb%Num%} library.

\FAILURE
Not applicable.

\USES
Exactly the same as {\small\verb%Int 2%}, but may save recreation of a cons cell each time.

\SEEALSO
num_0, num_1, num_10.

\ENDDOC
\DOC{NUM{\_}ADD{\_}CONV}

\TYPE {\small\verb%NUM_ADD_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the sum of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_ADD_CONV `n + m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n + m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the sum of the natural
numbers denoted by {\small\verb%n%} and {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_ADD_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n + m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_ADD_CONV `75 + 25`;;
  val it : thm = |- 75 + 25 = 100
\end{verbatim}
}

\SEEALSO
NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV,
NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV,
NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}CANCEL{\_}CONV}

\TYPE {\small\verb%NUM_CANCEL_CONV : term -> thm%}\egroup

\SYNOPSIS
Cancels identical terms from both sides of natural number equation.

\DESCRIBE
Given an equational term {\small\verb%`t1 + ... + tn = s1 + ... + sm`%} (with arbitrary
association of the additions) where both sides have natural number type, the
conversion identifies common elements among the {\small\verb%ti%} and {\small\verb%si%}, and cancels them
from both sides, returning a theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  |- t1 + ... + tn = s1 + ... + sm <=> u1 + ... + uk = v1 + ... + vl
\end{verbatim}
}
\noindent where the {\small\verb%ui%} and {\small\verb%vi%} are the remaining elements of the {\small\verb%ti%} and
{\small\verb%si%} respectively, in some order.

\FAILURE
Fails if applied to a term that is not an equation between natural number
terms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_CANCEL_CONV `(a + b + x * y + SUC c) + d = SUC c + d + y * z`;;
  val it : thm =
    |- (a + b + x * y + SUC c) + d = SUC c + d + y * z <=>
       x * y + b + a = y * z
\end{verbatim}
}

\USES
Simplifying equations where explicitly directing the cancellation would be
tedious. However, this is mostly intended for ``bootstrapping'', before more
powerful rules like {\small\verb%ARITH_RULE%} and {\small\verb%NUM_RING%} are available.

\SEEALSO
ARITH_RULE, ARITH_TAC, NUM_RING.

\ENDDOC
\DOC{num{\_}CONV}

\TYPE {\small\verb%num_CONV : term -> thm%}\egroup

\SYNOPSIS
Provides definitional axiom for a nonzero numeral.

\DESCRIBE
{\small\verb%num_CONV%} is an axiom-scheme from which one may obtain a defining equation for
any numeral not equal to {\small\verb%0%} (i.e. {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...).  If
{\small\verb%`n`%} is such a constant, then {\small\verb%num_CONV `n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n = SUC m
\end{verbatim}
}
\noindent where {\small\verb%m%} is the numeral that denotes the predecessor of the
number denoted by {\small\verb%n%}.

\FAILURE
{\small\verb%num_CONV tm%} fails if {\small\verb%tm%} is {\small\verb%`0`%} or if not {\small\verb%tm%} is not a numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # num_CONV `3`;;
  val it : thm = |- 3 = SUC 2
\end{verbatim}
}

\ENDDOC
\DOC{NUM{\_}DIV{\_}CONV}

\TYPE {\small\verb%NUM_DIV_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the truncated quotient of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_DIV_CONV `n DIV m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n DIV m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the truncated quotient of the
numbers denoted by {\small\verb%n%} and {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_DIV_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n DIV m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals, or if the second numeral {\small\verb%m%} is zero.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_DIV_CONV `99 DIV 9`;;
  val it : thm = |- 99 DIV 9 = 11

  # NUM_DIV_CONV `334 DIV 3`;;
  val it : thm = |- 334 DIV 3 = 111

  # NUM_DIV_CONV `11 DIV 0`;;
  Exception: Failure "NUM_DIV_CONV".
\end{verbatim}
}

\COMMENTS
For definiteness, quotients with zero denominator are in fact designed to be
zero. However, it is perhaps bad style to rely on this fact, so the conversion
just fails in this case.

\SEEALSO
NUM_ADD_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV,
NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}EQ{\_}CONV}

\TYPE {\small\verb%NUM_EQ_CONV : conv%}\egroup

\SYNOPSIS
Proves equality or inequality of two numerals.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are two numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_EQ_CONV `n = m`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- (n = m) <=> T       or       |- (n = m) <=> F
\end{verbatim}
}
\noindent depending on whether the natural numbers represented by {\small\verb%n%} and {\small\verb%m%}
are equal or not equal, respectively.

\FAILURE
{\small\verb%NUM_EQ_CONV tm%} fails if {\small\verb%tm%} is not of the form {\small\verb%`n = m`%}, where {\small\verb%n%} and {\small\verb%m%}
are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_EQ_CONV `1 = 2`;;
  val it : thm = |- 1 = 2 <=> F

  # NUM_EQ_CONV `12 = 12`;;
  val it : thm = |- 12 = 12 <=> T
\end{verbatim}
}

\USES
Performing basic arithmetic reasoning while producing a proof.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EVEN_CONV, NUM_EXP_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV,
NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV,
NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}EVEN{\_}CONV}

\TYPE {\small\verb%NUM_EVEN_CONV : conv%}\egroup

\SYNOPSIS
Proves whether a natural number numeral is even.

\DESCRIBE
If {\small\verb%n%} is a numeral (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then {\small\verb%NUM_EVEN_CONV `n`%}
returns one of the theorems:
{\par\samepage\setseps\small
\begin{verbatim}
  |- EVEN(n) <=> T
\end{verbatim}
}
\noindent or
{\par\samepage\setseps\small
\begin{verbatim}
  |- EVEN(n) <=> F
\end{verbatim}
}
\noindent according to whether the number denoted by {\small\verb%n%} is even.

\FAILURE
Fails if applied to a term that is not of the form {\small\verb%`EVEN n`%} with {\small\verb%n%} a
numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_EVEN_CONV `EVEN 99`;;
  val it : thm = |- EVEN 99 <=> F
  # NUM_EVEN_CONV `EVEN 123456`;;
  val it : thm = |- EVEN 123456 <=> T
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EXP_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV,
NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV,
NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}EXP{\_}CONV}

\TYPE {\small\verb%NUM_EXP_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the exponential of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_EXP_CONV `n EXP m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n EXP m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the natural number denoted by
{\small\verb%n%} raised to the power of the one denoted by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_EXP_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n EXP m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_EXP_CONV `2 EXP 64`;;
  val it : thm = |- 2 EXP 64 = 18446744073709551616

  # NUM_EXP_CONV `1 EXP 99`;;
  val it : thm = |- 1 EXP 99 = 1

  # NUM_EXP_CONV `0 EXP 0`;;
  val it : thm = |- 0 EXP 0 = 1

  # NUM_EXP_CONV `0 EXP 10000`;;
  val it : thm = |- 0 EXP 10000 = 0
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV,
NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV,
NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}FACT{\_}CONV}

\TYPE {\small\verb%NUM_FACT_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the factorial of a natural number numeral is.

\DESCRIBE
If {\small\verb%n%} is a numeral (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_FACT_CONV `FACT n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- FACT n = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the factorial of the natural
number denoted by {\small\verb%n%}.

\FAILURE
{\small\verb%NUM_FACT_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`FACT n`%}, where {\small\verb%n%} is a
numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_FACT_CONV `FACT 0`;;
  val it : thm = |- FACT 0 = 1

  # NUM_FACT_CONV `FACT 6`;;
  val it : thm = |- FACT 6 = 720

  # NUM_FACT_CONV `FACT 30`;;
  val it : thm = |- FACT 30 = 265252859812191058636308480000000
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV,
NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV,
NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}GE{\_}CONV}

\TYPE {\small\verb%NUM_GE_CONV : conv%}\egroup

\SYNOPSIS
Proves whether one numeral is greater than or equal to another.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are two numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_GE_CONV `n >= m`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- n >= m <=> T       or       |- n >= m <=> F
\end{verbatim}
}
\noindent depending on whether the natural number represented by {\small\verb%n%} is greater
than or equal to the one represented by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_GE_CONV tm%} fails if {\small\verb%tm%} is not of the form {\small\verb%`n >= m`%}, where {\small\verb%n%} and {\small\verb%m%}
are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_GE_CONV `1 >= 0`;;
  val it : thm = |- 1 >= 0 <=> T

  # NUM_GE_CONV `181 >= 211`;;
  val it : thm = |- 181 >= 211 <=> F
\end{verbatim}
}

\USES
Performing basic arithmetic reasoning while producing a proof.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV,
NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}GT{\_}CONV}

\TYPE {\small\verb%NUM_GT_CONV : conv%}\egroup

\SYNOPSIS
Proves whether one numeral is greater than another.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are two numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_GT_CONV `n > m`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- n > m <=> T       or       |- n > m <=> F
\end{verbatim}
}
\noindent depending on whether the natural number represented by {\small\verb%n%} is greater
than the one represented by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_GT_CONV tm%} fails if {\small\verb%tm%} is not of the form {\small\verb%`n > m`%}, where {\small\verb%n%} and {\small\verb%m%}
are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_GT_CONV `3 > 2`;;
  val it : thm = |- 3 > 2 <=> T

  # NUM_GT_CONV `77 > 77`;;
  val it : thm = |- 77 > 77 <=> F
\end{verbatim}
}

\USES
Performing basic arithmetic reasoning while producing a proof.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV,
NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}LE{\_}CONV}

\TYPE {\small\verb%NUM_LE_CONV : conv%}\egroup

\SYNOPSIS
Proves whether one numeral is less than or equal to another.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are two numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_LE_CONV `n <= m`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- n <= m <=> T       or       |- n <= m <=> F
\end{verbatim}
}
\noindent depending on whether the natural number represented by {\small\verb%n%} is less
than or equal to the one represented by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_LE_CONV tm%} fails if {\small\verb%tm%} is not of the form {\small\verb%`n <= m`%}, where {\small\verb%n%} and {\small\verb%m%}
are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_LE_CONV `12 <= 19`;;
  val it : thm = |- 12 <= 19 <=> T

  # NUM_LE_CONV `12345 <= 12344`;;
  val it : thm = |- 12345 <= 12344 <=> F
\end{verbatim}
}

\USES
Performing basic arithmetic reasoning while producing a proof.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LT_CONV, NUM_MAX_CONV,
NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}LT{\_}CONV}

\TYPE {\small\verb%NUM_LT_CONV : conv%}\egroup

\SYNOPSIS
Proves whether one numeral is less than another.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are two numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_LT_CONV `n < m`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- n < m <=> T       or       |- n < m <=> F
\end{verbatim}
}
\noindent depending on whether the natural number represented by {\small\verb%n%} is less
than the one represented by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_LT_CONV tm%} fails if {\small\verb%tm%} is not of the form {\small\verb%`n < m`%}, where {\small\verb%n%} and {\small\verb%m%}
are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_LT_CONV `42 < 42`;;
  val it : thm = |- 42 < 42 <=> F

  # NUM_LT_CONV `11 < 19`;;
  val it : thm = |- 11 < 19 <=> T
\end{verbatim}
}

\USES
Performing basic arithmetic reasoning while producing a proof.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_MAX_CONV,
NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}MAX{\_}CONV}

\TYPE {\small\verb%NUM_MAX_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the maximum of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_MAX_CONV `MAX m n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- MAX m n = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the maximum of the natural
numbers denoted by {\small\verb%n%} and {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_MAX_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`MAX m n`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_MAX_CONV `MAX 11 12`;;
  val it : thm = |- MAX 11 12 = 12
\end{verbatim}
}

\SEEALSO
NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MIN_CONV, NUM_MOD_CONV,
NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV,
NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}MIN{\_}CONV}

\TYPE {\small\verb%NUM_MIN_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the minimum of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_MIN_CONV `MIN m n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- MIN m n = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the minimum of the natural
numbers denoted by {\small\verb%n%} and {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_MIN_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`MIN m n`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_MIN_CONV `MIN 11 12`;;
  val it : thm = |- MIN 11 12 = 12
\end{verbatim}
}

\SEEALSO
NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV, NUM_FACT_CONV,
NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV, NUM_MAX_CONV, NUM_MOD_CONV,
NUM_MULT_CONV, NUM_ODD_CONV, NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV,
NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}MOD{\_}CONV}

\TYPE {\small\verb%NUM_MOD_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the remainder on dividing one natural number numeral by another is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_MOD_CONV `n MOD m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n MOD m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the remainder on dividing
the number denoted by {\small\verb%n%} by the one denoted by {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_MOD_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n MOD m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals, or if the second numeral {\small\verb%m%} is zero.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_MOD_CONV `1089 MOD 9`;;
  val it : thm = |- 1089 MOD 9 = 0

  # NUM_MOD_CONV `1234 MOD 3`;;
  val it : thm = |- 1234 MOD 3 = 1

  # NUM_MOD_CONV `11 MOD 0`;;
  Exception: Failure "NUM_MOD_CONV".
\end{verbatim}
}

\COMMENTS
For definiteness, remainders with zero denominator are in fact designed to be
zero. However, it is perhaps bad style to rely on this fact, so the conversion
just fails in this case.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV,
NUM_EXP_CONV, NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV,
NUM_LT_CONV, NUM_MAX_CONV, NUM_MIN_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV,
NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}MULT{\_}CONV}

\TYPE {\small\verb%NUM_MULT_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the product of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_MULT_CONV `n * m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n * m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the product of the natural
numbers denoted by {\small\verb%n%} and {\small\verb%m%}.

\FAILURE
{\small\verb%NUM_MULT_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n * m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_MULT_CONV `12345 * 12345`;;
  val it : thm = |- 12345 * 12345 = 152399025
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV,
NUM_EXP_CONV,NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_ODD_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}NORMALIZE{\_}CONV}

\TYPE {\small\verb%NUM_NORMALIZE_CONV : term -> thm%}\egroup

\SYNOPSIS
Puts natural number expressions built using addition, multiplication and powers
in canonical polynomial form.

\DESCRIBE
Given a term {\small\verb%t%} of natural number type built up from other ``atomic''
components (not necessarily simple variables) and numeral constants by
addition, multiplication and exponentiation by constant exponents,
{\small\verb%NUM_NORMALIZE_CONV t%} will return {\small\verb%|- t = t'%} where {\small\verb%t'%} is the result of
putting the term into a normalized form, essentially a multiplied-out
polynomial with a specific ordering of and within monomials.

\FAILURE
Should never fail.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_NORMALIZE_CONV `1 + (1 + x + x EXP 2) * (x + (x * x) EXP 2)`;;
  val it : thm =
    |- 1 + (1 + x + x EXP 2) * (x + (x * x) EXP 2) =
       x EXP 6 + x EXP 5 + x EXP 4 + x EXP 3 + x EXP 2 + x + 1
\end{verbatim}
}

\COMMENTS
This can be used to prove simple algebraic equations, but {\small\verb%NUM_RING%} or
{\small\verb%ARITH_RULE%} are generally more powerful and convenient for that. In
particular, this function does not handle cutoff subtraction or other such
operations.

\SEEALSO
ARITH_RULE, NUM_REDUCE_CONV, NUM_RING, REAL_POLY_CONV,
SEMIRING_NORMALIZERS_CONV.

\ENDDOC
\DOC{NUM{\_}ODD{\_}CONV}

\TYPE {\small\verb%NUM_ODD_CONV : conv%}\egroup

\SYNOPSIS
Proves whether a natural number numeral is odd.

\DESCRIBE
If {\small\verb%n%} is a numeral (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then {\small\verb%NUM_ODD_CONV `n`%}
returns one of the theorems:
{\par\samepage\setseps\small
\begin{verbatim}
  |- ODD(n) <=> T
\end{verbatim}
}
\noindent or
{\par\samepage\setseps\small
\begin{verbatim}
  |- ODD(n) <=> F
\end{verbatim}
}
\noindent according to whether the number denoted by {\small\verb%n%} is odd.

\FAILURE
Fails if applied to a term that is not of the form {\small\verb%`ODD n`%} with {\small\verb%n%} a
numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_ODD_CONV `ODD 123`;;
  val it : thm = |- ODD 123 <=> T

  # NUM_ODD_CONV `ODD 1234`;;
  val it : thm = |- ODD 1234 <=> F
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_PRE_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{num{\_}of{\_}string}

\TYPE {\small\verb%num_of_string : string -> num%}\egroup

\SYNOPSIS
Converts decimal, hex or binary string representation into number.

\DESCRIBE
The call {\small\verb%num_of_string "n"%} converts the string {\small\verb%"n"%} into an OCaml
unlimited-precision number (type {\small\verb%num%}). The string may be simply a sequence of
decimal digits (e.g. {\small\verb%"123"%}), or a hexadecimal representation starting with
{\small\verb%0x%} as in C (e.g. {\small\verb%"0xFF"%}), or a binary number starting with {\small\verb%0b%} (e.g.
{\small\verb%"0b101"%}).

\FAILURE
Fails unless the string is a valid representation of one of these forms.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # num_of_string "0b11000000";;
  val it : num = 192
\end{verbatim}
}

\SEEALSO
dest_numeral, mk_numeral.

\ENDDOC
\DOC{NUM{\_}PRE{\_}CONV}

\TYPE {\small\verb%NUM_PRE_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the cutoff predecessor of a natural number numeral is.

\DESCRIBE
If {\small\verb%n%} is a numeral (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_PRE_CONV `PRE n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- PRE n = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the cutoff predecessor of the
natural number denoted by {\small\verb%n%} (that is, the result of subtracting 1 from it, or
zero if it is already zero).

\FAILURE
{\small\verb%NUM_PRE_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`PRE n`%}, where {\small\verb%n%} is a
numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_PRE_CONV `PRE 0`;;
  val it : thm = |- PRE 0 = 0

  # NUM_PRE_CONV `PRE 12345`;;
  val it : thm = |- PRE 12345 = 12344
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}REDUCE{\_}CONV}

\TYPE {\small\verb%NUM_REDUCE_CONV : term -> thm%}\egroup

\SYNOPSIS
Evaluate subexpressions built up from natural number numerals, by proof.

\DESCRIBE
When applied to a term, {\small\verb%NUM_REDUCE_CONV%} performs a recursive bottom-up
evaluation by proof of subterms built from numerals using the unary operators
`{\small\verb%SUC%}', `{\small\verb%PRE%}' and `{\small\verb%FACT%}' and the binary arithmetic (`{\small\verb%+%}', `{\small\verb%-%}', `{\small\verb%*%}',
`{\small\verb%EXP%}', `{\small\verb%DIV%}', `{\small\verb%MOD%}') and relational (`{\small\verb%<%}', `{\small\verb%<=%}', `{\small\verb%>%}', `{\small\verb%>=%}', `{\small\verb%=%}')
operators, as well as propagating constants through logical operations, e.g. {\small\verb%T
/\ x <=> x%}, returning a theorem that the original and reduced terms are equal.

\FAILURE
Never fails, but may have no effect.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_REDUCE_CONV `(432 - 234) + 198`;;
  val it : thm = |- 432 - 234 + 198 = 396

  # NUM_REDUCE_CONV
      `if 100 < 200 then 2 EXP (8 DIV 2) else 3 EXP ((26 EXP 0) * 3)`;;
  val it : thm =
   |- (if 100 < 200 then 2 EXP (8 DIV 2) else 3 EXP (26 EXP 0 * 3)) = 16

  # NUM_REDUCE_CONV `(!x. f(x + 2 + 2) < f(x + 0)) ==> f(12 * x) = f(12 * 12)`;;
  val it : thm =
    |- (!x. f (x + 2 + 2) < f (x + 0)) ==> f (12 * x) = f (12 * 12) <=>
       (!x. f (x + 4) < f (x + 0)) ==> f (12 * x) = f 144
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_TAC, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV,
NUM_SUC_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{NUM{\_}REDUCE{\_}TAC}

\TYPE {\small\verb%NUM_REDUCE_TAC : tactic%}\egroup

\SYNOPSIS
Evaluate subexpressions of goal built up from natural number numerals.

\DESCRIBE
When applied to a goal, {\small\verb%NUM_REDUCE_TAC%} performs a recursive bottom-up
evaluation by proof of subterms of the conclusion built from numerals using the
unary operators `{\small\verb%SUC%}', `{\small\verb%PRE%}' and `{\small\verb%FACT%}' and the binary arithmetic (`{\small\verb%+%}',
`{\small\verb%-%}', `{\small\verb%*%}', `{\small\verb%EXP%}', `{\small\verb%DIV%}', `{\small\verb%MOD%}') and relational (`{\small\verb%<%}', `{\small\verb%<=%}', `{\small\verb%>%}',
`{\small\verb%>=%}', `{\small\verb%=%}') operators, as well as propagating constants through logical
operations, e.g. {\small\verb%T /\ x <=> x%}, returning a new subgoal where all these
subexpressions are reduced.

\FAILURE
Never fails, but may have no effect.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `1 EXP 3 + 12 EXP 3 = 1729 /\ 9 EXP 3 + 10 EXP 3 = 1729`;;
  val it : goalstack = 1 subgoal (1 total)

  `1 EXP 3 + 12 EXP 3 = 1729 /\ 9 EXP 3 + 10 EXP 3 = 1729`

  # e NUM_REDUCE_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV,
NUM_SUC_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{NUM{\_}RED{\_}CONV}

\TYPE {\small\verb%NUM_RED_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs one arithmetic or relational operation on natural number numerals by
proof.

\DESCRIBE
When applied to a term that is either a unary operator application
{\small\verb%`SUC n`%}, {\small\verb%`PRE n`%} or {\small\verb%`FACT n`%} for a numeral {\small\verb%n%}, or a relational operator
application {\small\verb%`m < n`%},  {\small\verb%`m <= n`%},  {\small\verb%`m > n`%}, {\small\verb%`m >= n`%} or {\small\verb%`m = n`%}, or a
binary arithmetic operation {\small\verb%`m + n`%},  {\small\verb%`m - n`%}, {\small\verb%`m * n`%},  {\small\verb%`m EXP n`%},
{\small\verb%`m DIV n`%} or {\small\verb%`m MOD n`%} applied to numerals {\small\verb%m%} and {\small\verb%n%}, the conversion
{\small\verb%NUM_RED_CONV%} will `reduce' it and return a theorem asserting its equality to
the reduced form.

\FAILURE
{\small\verb%NUM_RED_CONV tm%} fails if {\small\verb%tm%} is not of one of the forms specified.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_RED_CONV `2 + 2`;;
  val it : thm = |- 2 + 2 = 4

  # NUM_RED_CONV `1089 < 2231`;;
  val it : thm = |- 1089 < 2231 <=> T

  # NUM_RED_CONV `FACT 11`;;
  val it : thm = |- FACT 11 = 39916800
\end{verbatim}
}
Note that the immediate operands must be numerals. For deeper reduction of
combinations of numerals, use {\small\verb%NUM_REDUCE_CONV%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_RED_CONV `(432 - 234) + 198`;;
  Exception: Failure "REWRITES_CONV".

  # NUM_REDUCE_CONV `(432 - 234) + 198`;;
  val it : thm = |- 432 - 234 + 198 = 396
\end{verbatim}
}

\USES
Access to this `one-step' reduction is not usually especially useful, but if
you want to add a conversion {\small\verb%conv%} for some other operator on numbers, you can
conveniently incorporate it into {\small\verb%NUM_REDUCE_CONV%} with
{\par\samepage\setseps\small
\begin{verbatim}
  # let NUM_REDUCE_CONV' = DEPTH_CONV(REAL_RAT_RED_CONV ORELSEC conv);;
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_REL_CONV, NUM_SUB_CONV, NUM_SUC_CONV,
REAL_RAT_RED_CONV.

\ENDDOC
\DOC{NUM{\_}REL{\_}CONV}

\TYPE {\small\verb%NUM_REL_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs relational operation on natural number numerals by proof.

\DESCRIBE
When applied to a term that is a relational operator
application {\small\verb%`m < n`%},  {\small\verb%`m <= n`%},  {\small\verb%`m > n`%}, {\small\verb%`m >= n`%} or {\small\verb%`m = n`%} applied
to numerals {\small\verb%m%} and {\small\verb%n%}, the conversion {\small\verb%NUM_REL_CONV%} will `reduce' it and
return a theorem asserting its equality to {\small\verb%`T`%} or {\small\verb%`F`%} as appropriate.

\FAILURE
{\small\verb%NUM_REL_CONV tm%} fails if {\small\verb%tm%} is not of one of the forms specified.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_REL_CONV `1089 < 2231`;;
  val it : thm = |- 1089 < 2231 <=> T

  # NUM_REL_CONV `1089 >= 2231`;;
  val it : thm = |- 1089 >= 2231 <=> F
\end{verbatim}
}
Note that the immediate operands must be numerals. For deeper reduction of
combinations of numerals, use {\small\verb%NUM_REDUCE_CONV%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_REL_CONV `2 + 2 = 4`;;
  Exception: Failure "REWRITES_CONV".

  # NUM_REDUCE_CONV `2 + 2 = 4`;;
  val it : thm = |- 2 + 2 = 4 <=> T
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_SUB_CONV, NUM_SUC_CONV,
REAL_RAT_RED_CONV.

\ENDDOC
\DOC{NUM{\_}RING}

\TYPE {\small\verb%NUM_RING : term -> thm%}\egroup

\SYNOPSIS
Ring decision procedure instantiated to natural numbers.

\DESCRIBE
The rule {\small\verb%NUM_RING%} should be applied to a formula that, after suitable
normalization, can be considered a universally quantified Boolean combination
of equations and inequations between terms of type {\small\verb%:num%}. If that formula
holds in all integral domains, {\small\verb%NUM_RING%} will prove it. Any ``alien'' atomic
formulas that are not natural number equations will not contribute to the proof
but will not in themselves cause an error. The function is a particular
instantiation of {\small\verb%RING%}, which is a more generic procedure for ring and
semiring structures.

\FAILURE
Fails if the formula is unprovable by the methods employed. This does not
necessarily mean that it is not valid for {\small\verb%:num%}, but rather that it is not
valid on all integral domains (see below).

\EXAMPLE
The following formula is proved because it holds in all integral domains:
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_RING `(x + y) EXP 2 = x EXP 2 ==> y = 0 \/ y + 2 * x = 0`;;
  1 basis elements and 0 critical pairs
  Translating certificate to HOL inferences
  val it : thm = |- (x + y) EXP 2 = x EXP 2 ==> y = 0 \/ y + 2 * x = 0
\end{verbatim}
}
\noindent but the following isn't, even though over {\small\verb%:num%} it is equivalent:
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_RING `(x + y) EXP 2 = x EXP 2 ==> y = 0 \/ x = 0`;;
  2 basis elements and 1 critical pairs
  3 basis elements and 2 critical pairs
  3 basis elements and 1 critical pairs
  4 basis elements and 1 critical pairs
  4 basis elements and 0 critical pairs
  Exception: Failure "find".
\end{verbatim}
}

\COMMENTS
Note that since we are working over {\small\verb%:num%}, which is not really a ring, cutoff
subtraction is not true ring subtraction and the ability of {\small\verb%NUM_RING%} to
handle it is limited. Instantiations of {\small\verb%RING%} to actual rings, such as
{\small\verb%REAL_RING%}, have no such problems.

\SEEALSO
ARITH_RULE, ARITH_TAC, ideal_cofactors, NUM_NORMALIZE_CONV, REAL_RING, RING.

\ENDDOC
\DOC{NUM{\_}SIMPLIFY{\_}CONV}

\TYPE {\small\verb%NUM_SIMPLIFY_CONV : conv%}\egroup

\SYNOPSIS
Eliminates predecessor, cutoff subtraction, even and odd, division and modulus.

\DESCRIBE
When applied to a term, {\small\verb%NUM_SIMPLIFY_CONV%} tries to get rid of instances of
the natural number operators {\small\verb%PRE%}, {\small\verb%DIV%}, {\small\verb%MOD%} and {\small\verb%-%} (which is cutoff
subtraction), as well as the {\small\verb%EVEN%} and {\small\verb%ODD%} predicates, by rephrasing
properties in terms of multiplication and addition, adding new variables if
necessary. Some attempt is made to introduce quantifiers so that they are
effectively universally quantified. However, the input formula should be in NNF
for this aspect to be completely reliable.

\FAILURE
Should never fail, but in obscure situations may leave some instance of the
troublesome operators (for example, if they are mapped over a list instead of
simply applied).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_SIMPLIFY_CONV `~(n = 0) ==> PRE(n) + 1 = n`;;
  val it : thm =
    |- ~(n = 0) ==> PRE n + 1 = n <=>
       (!m. ~(n = SUC m) /\ (~(m = 0) \/ ~(n = 0)) \/ n = 0 \/ m + 1 = n)
\end{verbatim}
}

\USES
Not really intended for most users, but a prelude inside several automated
routines such as {\small\verb%ARITH_RULE%}. It is because of this preprocessing step that
such rules can handle these troublesome operators to some extent, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # ARITH_RULE `~(n = 0) ==> n DIV 3 < n`;;
  val it : thm = |- ~(n = 0) ==> n DIV 3 < n
\end{verbatim}
}

\SEEALSO
ARITH_RULE, ARITH_TAC, NUM_RING.

\ENDDOC
\DOC{NUM{\_}SUB{\_}CONV}

\TYPE {\small\verb%NUM_SUB_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the cutoff difference of two natural number numerals is.

\DESCRIBE
If {\small\verb%n%} and {\small\verb%m%} are numerals (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_SUB_CONV `n - m`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- n - m = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the result of subtracting the
natural number denoted by {\small\verb%m%} from the one denoted by {\small\verb%n%}, returning zero for
all cases where {\small\verb%m%} is greater than {\small\verb%n%} (cutoff subtraction over the natural
numbers).

\FAILURE
{\small\verb%NUM_SUB_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`n - m`%}, where {\small\verb%n%} and
{\small\verb%m%} are numerals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_SUB_CONV `4321 - 1234`;;
  val it : thm = |- 4321 - 1234 = 3087

  # NUM_SUB_CONV `77 - 88`;;
  val it : thm = |- 77 - 88 = 0
\end{verbatim}
}

\COMMENTS
Note that subtraction over type {\small\verb%:num%} is defined as this cutoff subtraction.
If you want a number system with negative numbers, use {\small\verb%:int%} or {\small\verb%:real%}.

\SEEALSO
NUM_ADD_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUC_CONV.

\ENDDOC
\DOC{NUM{\_}SUC{\_}CONV}

\TYPE {\small\verb%NUM_SUC_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves what the successor of a natural number numeral is.

\DESCRIBE
If {\small\verb%n%} is a numeral (e.g. {\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},...), then
{\small\verb%NUM_SUC_CONV `SUC n`%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- SUC n = s
\end{verbatim}
}
\noindent where {\small\verb%s%} is the numeral that denotes the successor of the natural
number denoted by {\small\verb%n%} (that is, the result of adding 1 to it).

\FAILURE
{\small\verb%NUM_SUC_CONV tm%} fails if {\small\verb%tm%} is not of the form  {\small\verb%`SUC n`%}, where {\small\verb%n%} is a
numeral.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_SUC_CONV `SUC 0`;;
  val it : thm = |- SUC 0 = 1

  # NUM_SUC_CONV `SUC 12345`;;
  val it : thm = |- SUC 12345 = 12346
\end{verbatim}
}

\SEEALSO
NUM_ADD_CONV, num_CONV, NUM_DIV_CONV, NUM_EQ_CONV, NUM_EVEN_CONV, NUM_EXP_CONV,
NUM_FACT_CONV, NUM_GE_CONV, NUM_GT_CONV, NUM_LE_CONV, NUM_LT_CONV,
NUM_MAX_CONV, NUM_MIN_CONV, NUM_MOD_CONV, NUM_MULT_CONV, NUM_ODD_CONV,
NUM_PRE_CONV, NUM_REDUCE_CONV, NUM_RED_CONV, NUM_REL_CONV, NUM_SUB_CONV.

\ENDDOC
\DOC{NUM{\_}TO{\_}INT{\_}CONV}

\TYPE {\small\verb%NUM_TO_INT_CONV : conv%}\egroup

\SYNOPSIS
Maps an assertion over natural numbers to equivalent over reals.

\DESCRIBE
Given a term, with arbitrary quantifier alternations over the natural numbers,
{\small\verb%NUM_TO_INT_CONV%} proves its equivalence to a term involving integer operations
and quantifiers. Some preprocessing removes certain natural-specific operations
such as {\small\verb%PRE%} and cutoff subtraction, quantifiers are systematically
relativized to the set of positive integers.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_TO_INT_CONV `n - m <= n`;;
  val it : thm =
    |- n - m <= n <=>
       (!i. ~(&0 <= i) \/
            (~(&m = &n + i) \/ &0 <= &n) /\ (~(&n = &m + i) \/ i <= &n))
\end{verbatim}
}

\USES
Mostly intended as a preprocessing step to allow rules for the integers to
deduce facts about natural numbers too.

\SEEALSO
ARITH_RULE, INT_ARITH, INT_OF_REAL_THM, NUM_SIMPLIFY_CONV.

\ENDDOC
\DOC{o}

\TYPE {\small\verb%o : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b%}\egroup

\SYNOPSIS
Composes two functions: {\small\verb%(f o g) x%} = {\small\verb%f (g x)%}.

\FAILURE
Never fails.

\SEEALSO
C, F_F, I, K, W.

\ENDDOC
\DOC{occurs{\_}in}

\TYPE {\small\verb%occurs_in : hol_type -> hol_type -> bool%}\egroup

\SYNOPSIS
Tests if one type occurs in another.

\DESCRIBE
The call {\small\verb%occurs_in ty1 ty2%} returns {\small\verb%true%} if {\small\verb%ty1%} occurs as a subtype of
{\small\verb%ty2%}, including the case where {\small\verb%ty1%} and {\small\verb%ty2%} are the same. If returns
{\small\verb%false%} otherwise. The type {\small\verb%ty1%} does not have to be a type variable.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # occurs_in `:A` `:(A)list->bool`;;
  val it : bool = true
  # occurs_in `:num->num` `:num->num->bool`;;
  val it : bool = false
  # occurs_in `:num->bool` `:num->num->bool`;;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
free_in, tyvars, vfree_in.

\ENDDOC
\DOC{omit}

\TYPE {\small\verb%omit : term -> term%}\egroup

\SYNOPSIS
Omit anything satisfying the given {\small\verb%search%} query.

\DESCRIBE
The function {\small\verb%omit%} is intended for use solely with the {\small\verb%search%} function.

\FAILURE
Never fails.

\SEEALSO
search.

\ENDDOC
\DOC{ONCE{\_}ASM{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem once including built-in rewrites and the theorem's
assumptions.

\DESCRIBE
{\small\verb%ONCE_ASM_REWRITE_RULE%} applies all possible rewrites in one step
over the subterms in the conclusion of the theorem, but stops after
rewriting at most once at each subterm. This strategy is specified as
for {\small\verb%ONCE_DEPTH_CONV%}. For more details see {\small\verb%ASM_REWRITE_RULE%}, which
does search recursively (to any depth) for matching subterms. The
general strategy for rewriting theorems is described under
{\small\verb%GEN_REWRITE_RULE%}.

\FAILURE
Never fails.

\USES
This tactic is used when rewriting with the hypotheses of a theorem
(as well as a given list of theorems and {\small\verb%basic_rewrites%}), when more
than one pass is not required or would result in divergence.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_DEPTH_CONV, ONCE_REWRITE_RULE,
PURE_ASM_REWRITE_RULE, PURE_ONCE_ASM_REWRITE_RULE, PURE_REWRITE_RULE,
REWRITE_RULE.

\ENDDOC
\DOC{ONCE{\_}ASM{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%ONCE_ASM_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal once including built-in rewrites and the goal's assumptions.

\DESCRIBE
{\small\verb%ONCE_ASM_REWRITE_TAC%} behaves in the same way as {\small\verb%ASM_REWRITE_TAC%},
but makes one pass only through the term of the goal. The order in
which the given theorems are applied is an implementation matter and
the user should not depend on any ordering. See {\small\verb%GEN_REWRITE_TAC%} for
more information on rewriting a goal in HOL.

\FAILURE
{\small\verb%ONCE_ASM_REWRITE_TAC%} does not fail and, unlike {\small\verb%ASM_REWRITE_TAC%},
does not diverge. The resulting tactic may not be valid, if the
rewrites performed add new assumptions to the theorem eventually
proved.

\EXAMPLE
The use of {\small\verb%ONCE_ASM_REWRITE_TAC%} to control the amount of rewriting
performed is illustrated on this goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `a = b /\ b = c ==> (P a b <=> P c a)`;;
  Warning: inventing type variables
  Warning: Free variables in goal: P, a, b, c
  val it : goalstack = 1 subgoal (1 total)

  `a = b /\ b = c ==> (P a b <=> P c a)`

  # e STRIP_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`a = b`]
   1 [`b = c`]

  `P a b <=> P c a`
\end{verbatim}
}
The application of {\small\verb%ONCE_ASM_REWRITE_TAC%} rewrites each applicable subterm just
once:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ONCE_ASM_REWRITE_TAC[]);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`a = b`]
   1 [`b = c`]

  `P b c <=> P c b`
\end{verbatim}
}

\USES
{\small\verb%ONCE_ASM_REWRITE_TAC%} can be applied once or iterated as required to
give the effect of {\small\verb%ASM_REWRITE_TAC%}, either to avoid divergence or to
save inference steps.

\SEEALSO
basic_rewrites, ASM_REWRITE_TAC, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC,
ONCE_REWRITE_TAC, PURE_ASM_REWRITE_TAC, PURE_ONCE_ASM_REWRITE_TAC,
PURE_ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC, SUBST_ALL_TAC,
SUBST1_TAC.

\ENDDOC
\DOC{ONCE{\_}ASM{\_}SIMP{\_}TAC}

\TYPE {\small\verb%ONCE_ASM_SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Simplify toplevel applicable terms in goal using assumptions and context.

\DESCRIBE
A call to {\small\verb%ONCE_ASM_SIMP_TAC[theorems]%} will apply conditional contextual
rewriting with {\small\verb%theorems%} and the current assumptions of the goal to the goal's
conclusion. The {\small\verb%ONCE%} prefix means that the toplevel simplification is only
applied once to the toplevel terms, though any conditional subgoals generated
are then simplified repeatedly. For more details on this kind of rewriting, see
{\small\verb%SIMP_CONV%}. If the extra generality of contextual conditional rewriting is not
needed, {\small\verb%ONCE_ASM_REWRITE_TAC%} is usually more efficient.

\FAILURE
Never fails, but may loop indefinitely.

\SEEALSO
ASM_SIMP_TAC, ONCE_ASM_REWRITE_TAC, SIMP_CONV, SIMP_TAC, REWRITE_TAC.
\ENDDOC
\DOC{ONCE{\_}DEPTH{\_}CONV}

\TYPE {\small\verb%ONCE_DEPTH_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion once to the first suitable sub-term(s) encountered in
top-down order.

\DESCRIBE
{\small\verb%ONCE_DEPTH_CONV c tm%} applies the conversion {\small\verb%c%} once to the first subterm or
subterms encountered in a top-down `parallel' search of the term {\small\verb%tm%} for which
{\small\verb%c%} succeeds.  If the conversion {\small\verb%c%} fails on all subterms of {\small\verb%tm%}, the theorem
returned is {\small\verb%|- tm = tm%}.

\FAILURE
Never fails.

\EXAMPLE
The following example shows how {\small\verb%ONCE_DEPTH_CONV%} applies a conversion to only
the first suitable subterm(s) found in a top-down search:
{\par\samepage\setseps\small
\begin{verbatim}
  # ONCE_DEPTH_CONV BETA_CONV `(\x. (\y. y + x) 1) 2`;;
  val it : thm = |- (\x. (\y. y + x) 1) 2 = (\y. y + 2) 1
\end{verbatim}
}
\noindent Here, there are two beta-redexes in the input term. One of these
occurs within the other, so {\small\verb%BETA_CONV%} is applied only to the outermost one.

Note that the supplied conversion is applied by {\small\verb%ONCE_DEPTH_CONV%} to all
independent subterms at which it succeeds.  That is, the conversion is applied
to every suitable subterm not contained in some other subterm for which the
conversions also succeeds, as illustrated by the following example:
{\par\samepage\setseps\small
\begin{verbatim}
  # ONCE_DEPTH_CONV num_CONV `(\x. (\y. y + x) 1) 2`;;
  val it : thm = |- (\x. (\y. y + x) 1) 2 = (\x. (\y. y + x) (SUC 0)) (SUC 1)
\end{verbatim}
}
\noindent Here {\small\verb%num_CONV%} is applied to both {\small\verb%1%} and {\small\verb%2%}, since neither term
occurs within a larger subterm for which the conversion {\small\verb%num_CONV%} succeeds.

\USES
{\small\verb%ONCE_DEPTH_CONV%} is frequently used when there is only one subterm to which
the desired conversion applies. This can be much faster than using other
functions that attempt to apply a conversion to all subterms of a term (e.g.
{\small\verb%DEPTH_CONV%}).  If, for example, the current goal in a goal-directed proof
contains only one beta-redex, and one wishes to apply {\small\verb%BETA_CONV%} to it, then
the tactic
{\par\samepage\setseps\small
\begin{verbatim}
   CONV_TAC (ONCE_DEPTH_CONV BETA_CONV)
\end{verbatim}
}
\noindent may, depending on where the beta-redex occurs, be much faster than
{\par\samepage\setseps\small
\begin{verbatim}
   CONV_TAC (TOP_DEPTH_CONV BETA_CONV)
\end{verbatim}
}
{\small\verb%ONCE_DEPTH_CONV c%} may also be used when the supplied conversion {\small\verb%c%} never
fails, in which case using a conversion such as {\small\verb%DEPTH_CONV c%}, which
applies {\small\verb%c%} repeatedly would never terminate.

\SEEALSO
DEPTH_BINOP_CONV, DEPTH_CONV, PROP_ATOM_CONV, REDEPTH_CONV, TOP_DEPTH_CONV,
TOP_SWEEP_CONV.

\ENDDOC
\DOC{ONCE{\_}DEPTH{\_}SQCONV}

\TYPE {\small\verb%ONCE_DEPTH_SQCONV : strategy%}\egroup

\SYNOPSIS
Applies simplification to the first suitable sub-term(s) encountered in
top-down order.

\DESCRIBE
HOL Light's simplification functions (e.g. {\small\verb%SIMP_TAC%}) have their traversal
algorithm controlled by a ``strategy''. {\small\verb%ONCE_DEPTH_SQCONV%} is a strategy
corresponding to {\small\verb%ONCE_DEPTH_CONV%} for ordinary conversions: simplification is
applied to the first suitable subterm(s) encountered in top-down order.

\FAILURE
Not applicable.

\SEEALSO
DEPTH_SQCONV, ONCE_DEPTH_CONV, REDEPTH_SQCONV, TOP_DEPTH_SQCONV,
TOP_SWEEP_SQCONV.

\ENDDOC
\DOC{ONCE{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%ONCE_REWRITE_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Rewrites a term, including built-in tautologies in the list of rewrites.

\DESCRIBE
{\small\verb%ONCE_REWRITE_CONV%} searches for matching subterms and applies
rewrites once at each subterm, in the manner specified for
{\small\verb%ONCE_DEPTH_CONV%}. The rewrites which are used are obtained from the
given list of theorems and the set of tautologies stored in
{\small\verb%basic_rewrites%}. See {\small\verb%GEN_REWRITE_CONV%} for the general method of
using theorems to rewrite a term.

\FAILURE
{\small\verb%ONCE_REWRITE_CONV%} does not fail; it does not diverge.

\USES
{\small\verb%ONCE_REWRITE_CONV%} can be used to rewrite a term when recursive
rewriting is not desired.

\SEEALSO
GEN_REWRITE_CONV, PURE_ONCE_REWRITE_CONV, PURE_REWRITE_CONV, REWRITE_CONV.

\ENDDOC
\DOC{ONCE{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%ONCE_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem, including built-in tautologies in the list of rewrites.

\DESCRIBE
{\small\verb%ONCE_REWRITE_RULE%} searches for matching subterms and applies
rewrites once at each subterm, in the manner specified for
{\small\verb%ONCE_DEPTH_CONV%}. The rewrites which are used are obtained from the
given list of theorems and the set of tautologies stored in
{\small\verb%basic_rewrites%}. See {\small\verb%GEN_REWRITE_RULE%} for the general method of
using theorems to rewrite an object theorem.

\FAILURE
{\small\verb%ONCE_REWRITE_RULE%} does not fail; it does not diverge.

\USES
{\small\verb%ONCE_REWRITE_RULE%} can be used to rewrite a theorem when recursive
rewriting is not desired.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_ASM_REWRITE_RULE,
PURE_ONCE_REWRITE_RULE, PURE_REWRITE_RULE, REWRITE_RULE.

\ENDDOC
\DOC{ONCE{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%ONCE_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal only once with {\small\verb%basic_rewrites%} and the supplied list
of theorems.

\DESCRIBE
A set of equational rewrites is generated from the theorems supplied
by the user and the set of basic tautologies, and these are used to
rewrite the goal at all subterms at which a match is found in one pass
over the term part of the goal. The result is returned without
recursively applying the rewrite theorems to it. The order in which
the given theorems are applied is an implementation matter and the user
should not depend on any ordering. More details about rewriting can be
found under {\small\verb%GEN_REWRITE_TAC%}.

\FAILURE
{\small\verb%ONCE_REWRITE_TAC%} does not fail and does not diverge. It results in
an invalid tactic if any of the applied rewrites introduces new
assumptions to the theorem eventually proved.

\EXAMPLE
Given a theorem list:
{\par\samepage\setseps\small
\begin{verbatim}
  # let thl = map (num_CONV o mk_small_numeral) (1--3);;
  val thl : thm list = [|- 1 = SUC 0; |- 2 = SUC 1; |- 3 = SUC 2]
\end{verbatim}
}
\noindent and the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `0 < 3`;;
  val it : goalstack = 1 subgoal (1 total)

  `0 < 3`
\end{verbatim}
}
\noindent the tactic {\small\verb%ONCE_REWRITE_TAC thl%} performs a single rewrite
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ONCE_REWRITE_TAC thl);;
  val it : goalstack = 1 subgoal (1 total)

  `0 < SUC 2`
\end{verbatim}
}
\noindent in contrast to {\small\verb%REWRITE_TAC thl%} which would rewrite the goal
repeatedly into this form:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC thl);;
  val it : goalstack = 1 subgoal (1 total)

  `0 < SUC (SUC (SUC 0))`
\end{verbatim}
}

\USES
{\small\verb%ONCE_REWRITE_TAC%} can be used iteratively to rewrite when recursive
rewriting would diverge.  It can also be used to save inference steps.

\SEEALSO
ASM_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, PURE_ASM_REWRITE_TAC,
PURE_ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC, SUBST_ALL_TAC,
SUBST1_TAC.

\ENDDOC
\DOC{ONCE{\_}SIMPLIFY{\_}CONV}

\TYPE {\small\verb%ONCE_SIMPLIFY_CONV : simpset -> thm list -> conv%}\egroup

\SYNOPSIS
General top-level simplification with arbitrary simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset'. Given a simpset {\small\verb%ss%} and an
additional list of theorems {\small\verb%thl%} to be used as (conditional or unconditional)
rewrite rules, {\small\verb%SIMPLIFY_CONV ss thl%} gives a simplification conversion with a
top-down single simplification traversal strategy ({\small\verb%ONCE_DEPTH_SQCONV%}) and a
nesting limit of 1 for the recursive solution of subconditions by further
simplification.

\FAILURE
Never fails.

\USES
Usually some other interface to the simplifier is more convenient, but you may
want to use this to employ a customized simpset.

\SEEALSO
GEN_SIMPLIFY_CONV, ONCE_DEPTH_SQCONV, SIMPLIFY_CONV, SIMP_CONV, SIMP_RULE,
SIMP_TAC.

\ENDDOC
\DOC{ONCE{\_}SIMP{\_}CONV}

\TYPE {\small\verb%ONCE_SIMP_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Simplify a term once by conditional contextual rewriting.

\DESCRIBE
A call {\small\verb%ONCE_SIMP_CONV thl tm%} will return {\small\verb%|- tm = tm'%} where {\small\verb%tm'%} results
from applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules, as well as
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more
details on this kind of conditional rewriting, see {\small\verb%SIMP_TAC%}. The {\small\verb%ONCE%}
prefix indicates that the first applicable terms in a toplevel term will be
simplified once only, though conditional subgoals generated will be simplified
repeatedly.

\FAILURE
Never fails, but may return a reflexive theorem {\small\verb%|- tm = tm%} if no
simplifications can be made.

\SEEALSO
ASM_SIMP_TAC, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{ONCE{\_}SIMP{\_}RULE}

\TYPE {\small\verb%ONCE_SIMP_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Simplify conclusion of a theorem once by conditional contextual rewriting.

\DESCRIBE
A call {\small\verb%ONCE_SIMP_RULE thl (|- tm)%} will return {\small\verb%|- tm'%} where {\small\verb%tm'%} results
from applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules, as well as
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more
details on this kind of conditional rewriting, see {\small\verb%SIMP_CONV%}. The {\small\verb%ONCE%}
prefix indicates that the first applicable terms in a toplevel term will be
simplified once only, though conditional subgoals generated will be simplified
repeatedly.

\FAILURE
Never fails, but may return the initial theorem unchanged.

\SEEALSO
ASM_SIMP_TAC, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{ONCE{\_}SIMP{\_}TAC}

\TYPE {\small\verb%ONCE_SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Simplify conclusion of goal once by conditional contextual rewriting.

\DESCRIBE
When applied to a goal {\small\verb%A ?- g%}, the tactic {\small\verb%ONCE_SIMP_TAC thl%} returns a new
goal {\small\verb%A ?- g'%} where {\small\verb%g'%} results from applying the theorems in {\small\verb%thl%} as
(conditional) rewrite rules, as well as built-in simplifications (see
{\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more details on this kind of
conditional rewriting, see {\small\verb%SIMP_CONV%}. The {\small\verb%ONCE%} prefix indicates that
the first applicable terms in a toplevel term will be simplified once only.
Moreover, in contrast to the other simplification tactics, any unsolved
subgoals arising from conditions on rewrites will be split off as new goals,
allowing simplification to proceed more interactively.

\FAILURE
Never fails, though may not change the goal if no simplifications are
applicable.

\SEEALSO
ONCE_SIMP_CONV, ONCE_SIMP_RULE, SIMP_CONV, SIMP_TAC.

\ENDDOC
\DOC{ORDERED{\_}IMP{\_}REWR{\_}CONV}

\TYPE {\small\verb%ORDERED_IMP_REWR_CONV : (term -> term -> bool) -> thm -> term -> thm%}\egroup

\SYNOPSIS
Basic conditional rewriting conversion restricted by term order.

\DESCRIBE
Given an ordering relation {\small\verb%ord%}, an equational theorem {\small\verb%A |- !x1...xn. p ==> s
= t%} that expresses a conditional rewrite rule, the conversion
{\small\verb%ORDERED_IMP_REWR_CONV%} gives a conversion that applied to any term {\small\verb%s'%} will
attempt to match the left-hand side of the equation {\small\verb%s = t%} to {\small\verb%s'%}, and return
the corresponding theorem {\small\verb%A |- p' ==> s' = t'%}, but only if {\small\verb%ord `s'` `t'`%},
i.e. if the left-hand side is ``greater'' in the ordering than the right-hand
side, after instantiation. If the ordering condition is violated, it will fail,
even if the match is fine.

\FAILURE
Fails if the theorem is not of the right form or the two terms cannot be
matched, for example because the variables that need to be instantiated are
free in the hypotheses {\small\verb%A%}, or if the ordering requirement fails.

\EXAMPLE

\USES
Applying conditional rewrite rules that are permutative and would loop without
some ordering restriction. Applied automatically to some permutative rewrite
rules in the simplifier, e.g. in {\small\verb%SIMP_CONV%}.

\SEEALSO
IMP_REWR_CONV, ORDERED_REWR_CONV, REWR_CONV, SIMP_CONV, term_order.

\ENDDOC
\DOC{ORDERED{\_}REWR{\_}CONV}

\TYPE {\small\verb%ORDERED_REWR_CONV : (term -> term -> bool) -> thm -> term -> thm%}\egroup

\SYNOPSIS
Basic rewriting conversion restricted by term order.

\DESCRIBE
Given an ordering relation {\small\verb%ord%}, an equational theorem {\small\verb%A |- !x1...xn. s = t%}
that expresses a rewrite rule, the conversion {\small\verb%ORDERED_REWR_CONV%} gives a
conversion that applied to any term {\small\verb%s'%} will attempt to match the left-hand
side of the equation {\small\verb%s = t%} to {\small\verb%s'%}, and return the corresponding theorem {\small\verb%A
|- s' = t'%}, but only if {\small\verb%ord `s'` `t'`%}, i.e. if the left-hand side is
``greater'' in the ordering than the right-hand side, after instantiation. If
the ordering condition is violated, it will fail, even if the match is fine.

\FAILURE
Fails if the theorem is not of the right form or the two terms cannot be
matched, for example because the variables that need to be instantiated are
free in the hypotheses {\small\verb%A%}, or if the ordering requirement fails.

\EXAMPLE
We apply the permutative rewrite:
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD_SYM;;
  val it : thm = |- !m n. m + n = n + m
\end{verbatim}
}
\noindent with the default term ordering {\small\verb%term_order%} designed for this kind of
application. Note that it applies in one direction:
{\par\samepage\setseps\small
\begin{verbatim}
  # ORDERED_REWR_CONV term_order ADD_SYM `1 + 2`;;
  val it : thm = |- 1 + 2 = 2 + 1
\end{verbatim}
}
\noindent but not the other:
{\par\samepage\setseps\small
\begin{verbatim}
  # ORDERED_REWR_CONV term_order ADD_SYM `2 + 1`;;
  Exception: Failure "ORDERED_REWR_CONV: wrong orientation".
\end{verbatim}
}

\USES
Applying conditional rewrite rules that are permutative and would loop without
some restriction. Thanks to the fact that higher-level rewriting operations
like {\small\verb%REWRITE_CONV%} and {\small\verb%REWRITE_TAC%} have ordering built in for permutative
rewrite rules, rewriting with theorem like {\small\verb%ADD_AC%} will effectively normalize
terms.

\SEEALSO
IMP_REWR_CONV, ORDERED_IMP_REWR_CONV, REWR_CONV, SIMP_CONV, term_order.

\ENDDOC
\DOC{ORELSE}

\TYPE {\small\verb%(ORELSE) : tactic -> tactic -> tactic%}\egroup

\SYNOPSIS
Applies first tactic, and iff it fails, applies the second instead.

\DESCRIBE
If {\small\verb%t1%} and {\small\verb%t2%} are tactics, {\small\verb%t1 ORELSE t2%} is a tactic which applies {\small\verb%t1%} to
a goal, and iff it fails, applies {\small\verb%t2%} to the goal instead.

\FAILURE
The application of {\small\verb%ORELSE%} to a pair of tactics never fails.
The resulting tactic fails if both {\small\verb%t1%} and {\small\verb%t2%} fail when applied to the
relevant goal.

\EXAMPLE
The tactic {\small\verb%STRIP_TAC%} breaks down the logical structure of a goal in various
ways, e.g. stripping off universal quantifiers and putting the antecedent of
implicational conclusions into the assumptions. However it does not break down
equivalences into two implications, as {\small\verb%EQ_TAC%} does. So you might start
breaking down a goal corresponding to the inbuilt theorem {\small\verb%MOD_EQ_0%}
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m n. ~(n = 0) ==> ((m MOD n = 0) <=> (?q. m = q * n))`;;
  ...
\end{verbatim}
}
\noindent as follows
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT(STRIP_TAC ORELSE EQ_TAC));;
  val it : goalstack = 2 subgoals (2 total)

   0 [`~(n = 0)`]
   1 [`m = q * n`]

  `m MOD n = 0`

   0 [`~(n = 0)`]
   1 [`m MOD n = 0`]

  `?q. m = q * n`
\end{verbatim}
}

\SEEALSO
EVERY, FIRST, THEN.

\ENDDOC
\DOC{ORELSEC}

\TYPE {\small\verb%(ORELSEC) : conv -> conv -> conv%}\egroup

\SYNOPSIS
Applies the first of two conversions that succeeds.

\DESCRIBE
{\small\verb%(c1 ORELSEC c2) `t`%} returns the result of applying the conversion {\small\verb%c1%} to
the term {\small\verb%`t`%} if this succeeds.  Otherwise {\small\verb%(c1 ORELSEC c2) `t`%} returns the
result of applying the conversion {\small\verb%c2%} to the term {\small\verb%`t`%}.

\FAILURE
{\small\verb%(c1 ORELSEC c2) `t`%} fails both {\small\verb%c1%} and {\small\verb%c2%}  fail when applied to {\small\verb%`t`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # (NUM_ADD_CONV ORELSEC NUM_MULT_CONV) `2 + 2`;;
  val it : thm = |- 2 + 2 = 4

  # (NUM_ADD_CONV ORELSEC NUM_MULT_CONV) `1 * 1`;;
  val it : thm = |- 1 * 1 = 1
\end{verbatim}
}

\SEEALSO
FIRST_CONV, THENC.

\ENDDOC
\DOC{orelsec{\_}}

\TYPE {\small\verb%orelsec_ : conv -> conv -> conv%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%ORELSEC%}.

\SEEALSO
ORELSEC.

\ENDDOC
\DOC{orelse{\_}}

\TYPE {\small\verb%orelse_ : tactic -> tactic -> tactic%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%ORELSE%}.

\SEEALSO
ORELSE.

\ENDDOC
\DOC{ORELSE{\_}TCL}

\TYPE {\small\verb%(ORELSE_TCL) : thm_tactical -> thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Applies a theorem-tactical, and if it fails, tries a second.

\DESCRIBE
When applied to two theorem-tacticals, {\small\verb%ttl1%} and {\small\verb%ttl2%}, a theorem-tactic
{\small\verb%ttac%}, and a theorem {\small\verb%th%}, if {\small\verb%ttl1 ttac th%} succeeds, that gives the
result. If it fails, the result is {\small\verb%ttl2 ttac th%}, which may itself fail.

\FAILURE
{\small\verb%ORELSE_TCL%} fails if both the theorem-tacticals fail when applied to the
given theorem-tactic and theorem.

\SEEALSO
EVERY_TCL, FIRST_TCL, THEN_TCL.

\ENDDOC
\DOC{orelse{\_}tcl{\_}}

\TYPE {\small\verb%orelse_tcl_ : thm_tactical -> thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%ORELSE_TCL%}.

\SEEALSO
ORELSE_TCL.

\ENDDOC
\DOC{overload{\_}interface}

\TYPE {\small\verb%overload_interface : string * term -> unit%}\egroup

\SYNOPSIS
Overload a symbol so it may denote a particular underlying constant.

\DESCRIBE
HOL Light allows the same identifier to denote several different underlying
constants. A call to {\small\verb%overload_interface("ident",`cname`)%}, where {\small\verb%cname%} is
either a constant to be denoted or a variable with the same name and type (if
the constant is not yet defined) will include {\small\verb%cname%} as one of the possible
overload resolutions of the symbol {\small\verb%ident%}. Moreover, when the resolution is
not possible from type information, {\small\verb%cname%} will now be the default. However,
before any calls to {\small\verb%overload_interface%}, the constant must have been declared
overloadable with {\small\verb%make_overloadable%}, and the term {\small\verb%`cname`%} must have a type
that is an instance of the most general ``type skeleton'' specified there.

\FAILURE
Fails if the identifier has not been declared overloadable, if the term is not
a constant or variable, or it its type is not an instance of the declared type
skeleton.

\EXAMPLE
The symbol `{\small\verb%+%}' has an overload skeleton of type {\small\verb%`:A->A->A`%}. Here we
overload it on type {\small\verb%:bool%} to denote logical `or'. (This is just for
illustration; it's strongly recommended that you don't do this, since you will
typically need to add more type annotations in terms to compensate for the
ambiguity.)
{\par\samepage\setseps\small
\begin{verbatim}
  # overload_interface("+",`(\/)`);;
  val it : unit = ()
\end{verbatim}
}
\noindent Now we can use the symbol `{\small\verb%+%}' with multiple meanings in the same
terms; the underlying constants are still the original ones, though:
{\par\samepage\setseps\small
\begin{verbatim}
  # `(x = 1) + (1 + 1 = 2)`;;
  val it : term = `(x = 1) + (1 + 1 = 2)`
\end{verbatim}
}
You can also overload polymorphic symbols, e.g. overload `{\small\verb%+%}' so that it maps
to list append:
{\par\samepage\setseps\small
\begin{verbatim}
  # overload_interface("+",`APPEND`);;
  Warning: inventing type variables
  val it : unit = ()

  # APPEND;;
  val it : thm = |- (!l. [] + l = l) /\ (!h t l. CONS h t + l = CONS h (t + l))
\end{verbatim}
}

\SEEALSO
make_overloadable, override_interface, prioritize_overload, reduce_interface,
remove_interface, the_implicit_types, the_interface, the_overload_skeletons.

\ENDDOC
\DOC{override{\_}interface}

\TYPE {\small\verb%override_interface : string * term -> unit%}\egroup

\SYNOPSIS
Map identifier to specific underlying constant.

\DESCRIBE
A call to {\small\verb%override_interface("name",`cname`)%} makes the parser map
instances of identifier {\small\verb%name%} to whatever constant is called {\small\verb%cname%}. Note
that the term {\small\verb%`cname`%} in the call may either be that constant or a variable
of the appropriate type. This contrasts with {\small\verb%overload_interface%}, which can
make the same identifier map to several underlying constants, depending on
type. A call to {\small\verb%override_interface%} removes all other overloadings of the
identifier, if any.

\FAILURE
Fails unless the term is a constant or variable.

\EXAMPLE
You might want to make the exponentiation operation {\small\verb%EXP%} on natural numbers
parse and print as `{\small\verb%^%}'. You can do this with
{\par\samepage\setseps\small
\begin{verbatim}
  # override_interface("^",`(EXP)`);;
  val it : unit = ()
\end{verbatim}
}
Note that the special parse status (infix in this case) is based on the
interface identifier, not the underlying constant, so that does not make `{\small\verb%^%}'
parse as infix:
{\par\samepage\setseps\small
\begin{verbatim}
  # EXP;;
  val it : thm = |- (!m. ^ m 0 = 1) /\ (!m n. ^ m (SUC n) = m * ^ m n)
\end{verbatim}
}
\noindent but you can do that with a separate {\small\verb%parse_as_infix%} call. It is also
possible to override polymorphic constants, and all instances will be handled.
For example, HOL Light's built-in list operations don't look much like OCaml:
{\par\samepage\setseps\small
\begin{verbatim}
  # APPEND;;
  val it : thm =
    |- (!l. APPEND [] l = l) /\
       (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
\end{verbatim}
}
\noindent but after a few interface modifications:
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_as_infix("::",(25,"right"));;
  # parse_as_infix("@",(16,"right"));;
  # override_interface("::",`CONS`);;
  # override_interface("@",`APPEND`);;
\end{verbatim}
}
\noindent it looks closer (you can remove the spaces round {\small\verb%::%} using
{\small\verb%unspaced_binops%}):
{\par\samepage\setseps\small
\begin{verbatim}
  # APPEND;;
  val it : thm = |- (!l. [] @ l = l) /\ (!h t l. h :: t @ l = h :: (t @ l))
\end{verbatim}
}

\SEEALSO
overload_interface, parse_as_infix, reduce_interface, remove_interface,
the_implicit_types, the_interface, the_overload_skeletons.

\ENDDOC
\DOC{p}

\TYPE {\small\verb%p : unit -> goalstack%}\egroup

\SYNOPSIS
Prints the top level of the subgoal package goal stack.

\DESCRIBE
The function {\small\verb%p%} is part of the subgoal package, and prints the current
goalstate.

\FAILURE
Never fails.

\USES
Examining the proof state during an interactive proof session.

\COMMENTS
Strictly speaking this function is side-effect-free. It simply {\em returns}
the current goalstate. However, automatic printing will normally then print it,
so that is the net effect.

\SEEALSO
b, e, er, g, r.

\ENDDOC
\DOC{parses{\_}as{\_}binder}

\TYPE {\small\verb%parses_as_binder : string -> bool%}\egroup

\SYNOPSIS
Tests if a string has binder status in the parser.

\DESCRIBE
Certain identifiers {\small\verb%c%} have binder status, meaning that {\small\verb%`c x. y`%} is parsed
as a shorthand for {\small\verb%`(c) (\x. y)'%}. The call {\small\verb%parses_as_binder "c"%} tests if
{\small\verb%c%} is one of the identifiers with binder status.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # parses_as_binder "!";;
  val it : bool = true
  # parses_as_binder "==>";;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
binders, parses_as_binder, unparse_as_binder.

\ENDDOC
\DOC{parse{\_}as{\_}binder}

\TYPE {\small\verb%parse_as_binder : string -> unit%}\egroup

\SYNOPSIS
Makes the quotation parser treat a name as a binder.

\DESCRIBE
The call {\small\verb%parse_as_binder "c"%} will make the quotation parser treat {\small\verb%c%} as a
binder, that is, allow the syntactic sugaring {\small\verb%`c x. y`%} as a shorthand for
{\small\verb%`c (\x. y)`%}. As with normal binders, e.g. the universal quantifier, the
special syntactic status may be suppressed by enclosing {\small\verb%c%} in parentheses:
{\small\verb%(c)%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_as_binder "infinitely_many";;
  val it : unit = ()
  # `infinitely_many p:num. prime(p)`;;
  `infinitely_many p. prime(p)`;;
\end{verbatim}
}

\SEEALSO
binders, parses_as_binder, unparse_as_binder.

\ENDDOC
\DOC{parse{\_}as{\_}infix}

\TYPE {\small\verb%parse_as_infix : string * (int * string) -> unit%}\egroup

\SYNOPSIS
Adds identifier to list of infixes, with given precedence and associativity.

\DESCRIBE
Certain identifiers are treated as infix operators with a given precedence and
associativity (left or right). The call {\small\verb%parse_as_infix("op",(p,a))%} adds {\small\verb%op%}
to the infix operators with precedence {\small\verb%p%} and associativity {\small\verb%a%} (it should be
one of the two strings {\small\verb%"left"%} or {\small\verb%"right"%}). Note that the infix status is
based purely on the name, which can be alphanumeric or symbolic, and does not
depend on whether the name denotes a constant.

\FAILURE
Never fails; if the given string was already an infix, its precedence and
associativity are changed to the new values.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # strip_comb `n choose k`;;
  Warning: inventing type variables
  val it : term * term list = (`n`, [`choose`; `k`])

  # parse_as_infix("choose",(22,"right"));;
  val it : unit = ()
  # strip_comb `n choose k`;;
  Warning: inventing type variables
  val it : term * term list = (`(choose)`, [`n`; `k`])
\end{verbatim}
}

\USES
Adding user-defined binary operators.

\SEEALSO
get_infix_status, infixes, unparse_as_infix.

\ENDDOC
\DOC{parse{\_}as{\_}prefix}

\TYPE {\small\verb%parse_as_prefix : string -> unit%}\egroup

\SYNOPSIS
Gives an identifier prefix status.

\DESCRIBE
Certain identifiers {\small\verb%c%} have prefix status, meaning that combinations of the
form {\small\verb%c f x%} will be parsed as {\small\verb%c (f x)%} rather than the usual {\small\verb%(c f) x%}. The
call {\small\verb%parse_as_prefix "c"%} adds {\small\verb%c%} to the list of such identifiers.

\FAILURE
Never fails, even if the string already has prefix status.

\SEEALSO
is_prefix, prefixes, unparse_as_prefix.

\ENDDOC
\DOC{parse{\_}inductive{\_}type{\_}specification}

\TYPE {\small\verb%parse_inductive_type_specification : string -> (hol_type * (string * hol_type list) list) list%}\egroup

\SYNOPSIS
Parses the specification for an inductive type into a structured format.

\DESCRIBE
The underlying function {\small\verb%define_type_raw%} used inside {\small\verb%define_type%} expects the
inductive type specification in a more structured format. The function
{\small\verb%parse_inductive_type_specification%} parses the usual string form as handed to
{\small\verb%define_type%} and yields this structured form. In fact, {\small\verb%define_type%} is just
the composition of {\small\verb%define_type_raw%} and {\small\verb%parse_inductive_type_specification%}.

\FAILURE
Fails if there is a parsing error in the inductive type specification.

\SEEALSO
define_type, define_type_raw.

\ENDDOC
\DOC{parse{\_}preterm}

\TYPE {\small\verb%parse_preterm : lexcode list -> preterm * lexcode list%}\egroup

\SYNOPSIS
Parses a preterm.

\DESCRIBE
The call {\small\verb%parse_preterm t%}, where {\small\verb%t%} is a list of lexical tokens (as produced
by {\small\verb%lex%}), parses the tokens and returns a preterm as well as the unparsed
tokens.

\FAILURE
Fails if there is a syntax error in the token list.

\USES
This is mostly an internal function; pretypes and preterms are used as an
intermediate representation for typechecking and overload resolution and are
not normally of concern to users.

\SEEALSO
lex, parse_pretype, parse_term, parse_type.

\ENDDOC
\DOC{parse{\_}pretype}

\TYPE {\small\verb%parse_pretype : lexcode list -> pretype * lexcode list%}\egroup

\SYNOPSIS
Parses a pretype.

\DESCRIBE
The call {\small\verb%parse_pretype t%}, where {\small\verb%t%} is a list of lexical tokens (as produced
by {\small\verb%lex%}), parses the tokens and returns a pretype as well as the unparsed
tokens.

\FAILURE
Fails if there is a syntax error in the token list.

\USES
This is mostly an internal function; pretypes and preterms are used as an
intermediate representation for typechecking and overload resolution and are
not normally of concern to users.

\SEEALSO
lex, parse_preterm, parse_term, parse_type.

\ENDDOC
\DOC{parse{\_}term}

\TYPE {\small\verb%parse_term : string -> term%}\egroup

\SYNOPSIS
Parses a string into a HOL term.

\DESCRIBE
The call {\small\verb%parse_term "s"%} parses the string {\small\verb%s%} into a HOL term. This is the
function that is invoked automatically when a term is written in quotations
{\small\verb%`s`%}.

\FAILURE
Fails in the event of a syntax error or unparsed input.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_term "p /\\ q ==> r";;
  val it : term = `p /\ q ==> r`
\end{verbatim}
}

\COMMENTS
Note that backslash characters should be doubled up when entering OCaml
strings, as in the example above, since they are the string escape character.
This is handled automatically by the quotation parser, so one doesn't need to
do it (indeed shouldn't do it) when entering quotations between backquotes.

\SEEALSO
lex, parse_type.

\ENDDOC
\DOC{parse{\_}type}

\TYPE {\small\verb%parse_type : string -> hol_type%}\egroup

\SYNOPSIS
Parses a string into a HOL type.

\DESCRIBE
The call {\small\verb%parse_type "s"%} parses the string {\small\verb%s%} into a HOL type. This is the
function that is invoked automatically when a type is written in quotations
with an initial colon {\small\verb%`:s`%}.

\FAILURE
Fails in the event of a syntax error or unparsed input.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # parse_type "num->bool";;
  val it : hol_type = `:num->bool`
\end{verbatim}
}

\SEEALSO
lex, parse_term.

\ENDDOC
\DOC{partition}

\TYPE {\small\verb%partition : ('a -> bool) -> 'a list -> 'a list * 'a list%}\egroup

\SYNOPSIS
Separates a list into two lists using a predicate.

\DESCRIBE
{\small\verb%partition p l%} returns a pair of lists. The first list contains the elements
which satisfy {\small\verb%p%}. The second list contains all the other elements.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # partition (fun x -> x mod 2 = 0) (1--10);;
  val it : int list * int list = ([2; 4; 6; 8; 10], [1; 3; 5; 7; 9])
\end{verbatim}
}

\SEEALSO
chop_list, remove, filter.

\ENDDOC
\DOC{PART{\_}MATCH}

\TYPE {\small\verb%PART_MATCH : (term -> term) -> thm -> term -> thm%}\egroup

\SYNOPSIS
Instantiates a theorem by matching part of it to a term.

\DESCRIBE
When applied to a `selector' function of type {\small\verb%term -> term%}, a theorem and a
term:
{\par\samepage\setseps\small
\begin{verbatim}
   PART_MATCH fn (A |- !x1...xn. t) tm
\end{verbatim}
}
\noindent the function {\small\verb%PART_MATCH%} applies {\small\verb%fn%} to {\small\verb%t'%} (the result of
specializing universally quantified variables in the conclusion of the
theorem), and attempts to match the resulting term to the argument term
{\small\verb%tm%}.  If it succeeds, the appropriately instantiated version of the
theorem is returned. Limited higher-order matching is supported, and some
attempt is made to maintain bound variable names in higher-order matching.

\FAILURE
Fails if the selector function {\small\verb%fn%} fails when applied to the instantiated
theorem, or if the match fails with the term it has provided.

\EXAMPLE
Suppose that we have the following theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   th = |- !x. x ==> x
\end{verbatim}
}
\noindent then the following:
{\par\samepage\setseps\small
\begin{verbatim}
   PART_MATCH (fst o dest_imp) th `T`
\end{verbatim}
}
\noindent results in the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- T ==> T
\end{verbatim}
}
\noindent because the selector function picks the antecedent of the
implication (the inbuilt specialization gets rid of the universal
quantifier), and matches it to {\small\verb%T%}. For a higher-order case rather similar to
what goes on inside HOL's {\small\verb%INDUCT_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # num_INDUCTION;;
  val it : thm = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)

  # PART_MATCH rand it `!n. n <= n * n`;;
  val it : thm =
    |- 0 <= 0 * 0 /\ (!n. n <= n * n ==> SUC n <= SUC n * SUC n)
       ==> (!n. n <= n * n)
\end{verbatim}
}
To show a more interesting case with higher-order matching, where the pattern
is not quite a higher-order pattern in the usual sense, consider the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = MESON[num_CASES; NOT_SUC]
     `(!n. P(SUC n)) <=> !n. ~(n = 0) ==> P n`
  ...
  val th : thm = |- (!n. P (SUC n)) <=> (!n. ~(n = 0) ==> P n)
\end{verbatim}
}
\noindent and instantiate it as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # PART_MATCH lhs th `!n. 1 <= SUC n`;;
  val it : thm = |- (!n. 1 <= SUC n) <=> (!n. ~(n = 0) ==> 1 <= n)
\end{verbatim}
}

\SEEALSO
GEN_PART_MATCH, INST_TYPE, MATCH_MP, REWR_CONV, term_match.

\ENDDOC
\DOC{PATH{\_}CONV}

\TYPE {\small\verb%PATH_CONV : string -> conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the subterm indicated by a path string.

\DESCRIBE
The call {\small\verb%PATH_CONV p cnv%} gives a new conversion that applies {\small\verb%cnv%} to the
subterm of a term identified by the path string {\small\verb%p%}. This path string is
interpreted as a sequence of direction indications:

\begin{itemize}

\item {\small\verb%"b"%}: take the body of an abstraction

\item {\small\verb%"l"%}: take the left (rator) path in an application

\item {\small\verb%"r"%}: take the right (rand) path in an application

\end{itemize}

\FAILURE
The basic call to the path string and conversion never fails, but when applied
to the term it may, if the path is not meaningful or if the conversion itself
fails on the indicated subterm.

\USES
More concise indication of sub-conversion application than by composing
{\small\verb%RATOR_CONV%}, {\small\verb%RAND_CONV%} and {\small\verb%ABS_CONV%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # PATH_CONV "rlr" NUM_ADD_CONV `(1 + 2) + (3 + 4) + (5 + 6)`;;
  val it : thm = |- (1 + 2) + (3 + 4) + 5 + 6 = (1 + 2) + 7 + 5 + 6
\end{verbatim}
}

\SEEALSO
find_path, follow_path.

\ENDDOC
\DOC{PAT{\_}CONV}

\TYPE {\small\verb%PAT_CONV : term -> conv -> conv%}\egroup

\SYNOPSIS
Apply a conversion at subterms identified by a ``pattern'' lambda-abstraction.

\DESCRIBE
The call {\small\verb%PAT_CONV `\x1 ... xn. t[x1,...,xn]` cnv%} gives a new conversion that
applies {\small\verb%cnv%} to subterms of the target term corresponding to the free
instances of any {\small\verb%xi%} in the pattern {\small\verb%t[x1,...,xn]%}. The fact that the pattern
is a function has no logical significance; it is just used as a convenient
format for the pattern.

\FAILURE
Never fails until applied to a term, but then it may fail if the core
conversion does on the chosen subterms.

\EXAMPLE
Here we choose to evaluate just two subterms:
{\par\samepage\setseps\small
\begin{verbatim}
  # PAT_CONV `\x. x + a + x` NUM_ADD_CONV `(1 + 2) + (3 + 4) + (5 + 6)`;;
  val it : thm = |- (1 + 2) + (3 + 4) + 5 + 6 = 3 + (3 + 4) + 11
\end{verbatim}
}
\noindent while here we swap two particular quantifiers in a long chain:
{\par\samepage\setseps\small
\begin{verbatim}
  # PAT_CONV `\x. !x1 x2 x3 x4 x5. x` (REWR_CONV SWAP_FORALL_THM)
      `!a b c d e f g h. something`;;
  Warning: inventing type variables
  Warning: inventing type variables
  val it : thm =
    |- (!a b c d e f g h. something) <=> (!a b c d e g f h. something)
\end{verbatim}
}

\SEEALSO
ABS_CONV, BINDER_CONV, BINOP_CONV, PATH_CONV, RAND_CONV, RATOR_CONV.

\ENDDOC
\DOC{PINST}

\TYPE {\small\verb%PINST : (hol_type * hol_type) list -> (term * term) list -> thm -> thm%}\egroup

\SYNOPSIS
Instantiate types and terms in a theorem.

\DESCRIBE
The call {\small\verb%PINST [ty1,tv1; ...; tyn,tvn] [tm1,v1; ...; tmk,vk] th%} instantiates
both types and terms in the theorem {\small\verb%th%} using the two instantiation
lists. The {\small\verb%tyi%} should be types, the {\small\verb%tvi%} type variables, the {\small\verb%tmi%} terms and
the {\small\verb%vi%} term variables. Note carefully that the {\small\verb%vi%} refer to variables in the
theorem {\em before} type instantiation, but the {\small\verb%tmi%} should be replacements
for the type-instantiated ones. More explicitly, the behaviour is as follows.
First, the type variables in {\small\verb%th%} are instantiated according to the list
{\small\verb%[ty1,tv1; ...; tyn,tvn]%}, exactly as for {\small\verb%INST_TYPE%}. Moreover the same type
instantiation is applied to the variables in the second list, to give
{\small\verb%[tm1,v1'; ...; tmk,vk']%}. This is then used to instantiate the already
type-instantiated theorem.

\FAILURE
Fails if the instantiation lists are ill-formed, as with {\small\verb%INST%} and
{\small\verb%INST_TYPE%}, for example if some {\small\verb%tvi%} is not a type variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = MESON[] `(x:A = y) <=> (y = x)`;;
  ...
  val th : thm = |- x = y <=> y = x

  # PINST [`:num`,`:A`] [`2 + 2`,`x:A`; `4`,`y:A`] th;;
  val it : thm = |- 2 + 2 = 4 <=> 4 = 2 + 2
\end{verbatim}
}

\SEEALSO
INST, INST_TYPE.

\ENDDOC
\DOC{POP{\_}ASSUM}

\TYPE {\small\verb%POP_ASSUM : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Applies tactic generated from the first element of a goal's assumption list.

\DESCRIBE
When applied to a theorem-tactic and a goal, {\small\verb%POP_ASSUM%} applies
the theorem-tactic to the first element of the assumption list,
and applies the resulting tactic to the goal without the first
assumption in its assumption list:
{\par\samepage\setseps\small
\begin{verbatim}
    POP_ASSUM f ({A1;...;An} ?- t) = f (... |- A1) ({A2;...;An} ?- t)
\end{verbatim}
}

\FAILURE
Fails if the assumption list of the goal is empty, or the theorem-tactic
fails when applied to the popped assumption, or if the resulting tactic
fails when applied to the goal (with depleted assumption list).

\COMMENTS
It is possible simply to use the theorem {\small\verb%ASSUME `A1`%} as required rather than
use {\small\verb%POP_ASSUM%}; this will also maintain {\small\verb%A1%} in the assumption list,
which is generally useful. In addition, this approach can equally well be
applied to assumptions other than the first.

There are admittedly times when {\small\verb%POP_ASSUM%} is convenient, but it is unwise to
use it if there is more than one assumption in the assumption list, since this
introduces a dependency on the ordering and makes proofs somewhat brittle with
respect to changes.

Another point to consider is that if the relevant assumption has been obtained
by {\small\verb%DISCH_TAC%}, it is often cleaner to use {\small\verb%DISCH_THEN%} with a theorem-tactic.
For example, instead of:
{\par\samepage\setseps\small
\begin{verbatim}
   DISCH_TAC THEN POP_ASSUM (fun th -> SUBST1_TAC (SYM th))
\end{verbatim}
}
\noindent one might use
{\par\samepage\setseps\small
\begin{verbatim}
   DISCH_THEN (SUBST1_TAC o SYM)
\end{verbatim}
}

\EXAMPLE
Starting with the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!f x. 0 = x ==> f(x * f(x)) = f(x)`;;
\end{verbatim}
}
\noindent and breaking it down:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`0 = x`]

  `f (x * f x) = f x`
\end{verbatim}
}
\noindent we might use the equation to substitute backwards:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(POP_ASSUM(SUBST1_TAC o SYM) THEN REWRITE_TAC[MULT_CLAUSES]);;
\end{verbatim}
}
\noindent but another alternative would have been:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[MULT_CLAUSES; SYM(ASSUME `0 = x`)]);;
\end{verbatim}
}
\noindent and we could even have avoided putting the equation in the
assumptions at all by from the beginning doing:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
      REWRITE_TAC[MULT_CLAUSES]);;
\end{verbatim}
}

\USES
Making more delicate use of an assumption than rewriting or resolution
using it.

\SEEALSO
ASSUME, ASSUM_LIST, EVERY_ASSUM, POP_ASSUM_LIST, REWRITE_TAC.

\ENDDOC
\DOC{POP{\_}ASSUM{\_}LIST}

\TYPE {\small\verb%POP_ASSUM_LIST : (thm list -> tactic) -> tactic%}\egroup

\SYNOPSIS
Generates a tactic from the assumptions, discards the assumptions and
applies the tactic.

\DESCRIBE
When applied to a function and a goal, {\small\verb%POP_ASSUM_LIST%} applies
the function to a list of theorems corresponding to the
assumptions of the goal, then applies the resulting tactic to the goal
with an empty assumption list.
{\par\samepage\setseps\small
\begin{verbatim}
    POP_ASSUM_LIST f ({A1;...;An} ?- t) = f [.. |- A1; ... ; .. |- An] (?- t)
\end{verbatim}
}

\FAILURE
Fails if the function fails when applied to the list of assumptions, or if the
resulting tactic fails when applied to the goal with no assumptions.

\COMMENTS
There is nothing magical about {\small\verb%POP_ASSUM_LIST%}: the same effect can be
achieved by using {\small\verb%ASSUME a%} explicitly wherever the assumption {\small\verb%a%} is
used. If {\small\verb%POP_ASSUM_LIST%} is used, it is unwise to select elements by
number from the {\small\verb%ASSUME%}d-assumption list, since this introduces a dependency
on ordering.

\EXAMPLE
We can collect all the assumptions of a goal into a conjunction and make them a
new antecedent by:
{\par\samepage\setseps\small
\begin{verbatim}
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ)
\end{verbatim}
}

\USES
Making more delicate use of the assumption list than simply rewriting etc.

\SEEALSO
ASSUM_LIST, EVERY_ASSUM, POP_ASSUM, REWRITE_TAC.

\ENDDOC
\DOC{possibly}

\TYPE {\small\verb%possibly : ('a -> 'b * 'a) -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Attempts to parse, returning empty list of items in case of failure.

\DESCRIBE
If {\small\verb%p%} is a parser, then {\small\verb%possibly p%} is another parser that attempts to parse
with {\small\verb%p%} and if successful returns the result as a singleton list, but will
return the empty list instead if the core parser {\small\verb%p%} raises {\small\verb%Noparse%}.

\FAILURE
Never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
rightbin, some.

\ENDDOC
\DOC{pow10}

\TYPE {\small\verb%pow10 : int -> num%}\egroup

\SYNOPSIS
Returns power of 10 as unlimited-size integer.

\DESCRIBE
When applied to an integer {\small\verb%n%} (type {\small\verb%int%}), {\small\verb%pow10%} returns $10^n$ as an
unlimited-precision integer (type {\small\verb%num%}). The argument may be negative.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # pow10(-1);;
  val it : num = 1/10
  # pow10(16);;
  val it : num = 10000000000000000
\end{verbatim}
}

\SEEALSO
pow2.

\ENDDOC
\DOC{pow2}

\TYPE {\small\verb%pow2 : int -> num%}\egroup

\SYNOPSIS
Returns power of 2 as unlimited-size integer.

\DESCRIBE
When applied to an integer {\small\verb%n%} (type {\small\verb%int%}), {\small\verb%pow2%} returns $2^n$ as an
unlimited-precision integer (type {\small\verb%num%}). The argument may be negative.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # pow2(-2);;
  val it : num = 1/4
  # pow2(64);;
  val it : num = 18446744073709551616
\end{verbatim}
}

\SEEALSO
pow10.

\ENDDOC
\DOC{pp{\_}print{\_}colored{\_}qterm}

\TYPE {\small\verb%pp_print_colored_qterm : formatter -> term -> unit%}\egroup

\SYNOPSIS
Prints a term with surrounding quotes and colors to formatter.

\DESCRIBE
The call {\small\verb%pp_print_colored_qterm fmt tm%} prints the colored representation of the
term {\small\verb%tm%} to the formatter {\small\verb%fmt%}, in the form {\small\verb%`tm`%}.
To print without colors, use {\small\verb%pp_print_qterm%}.

For its color configuration, see {\small\verb%pp_print_colored_term%}.

\FAILURE
Should never fail unless the formatter does.

\SEEALSO
pp_print_colored_term, pp_print_term, pp_print_qterm, print_qterm, print_term, set_color_printer.

\ENDDOC
\DOC{pp{\_}print{\_}colored{\_}qtype}

\TYPE {\small\verb%pp_print_colored_qtype : formatter -> hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type with initial colon, surrounding quotes and colors to formatter.

\DESCRIBE
The call {\small\verb%pp_print_colored_qtype fmt ty%} prints the colored representation of the
type {\small\verb%ty%} to the formatter {\small\verb%fmt%}, in the form {\small\verb%`:ty`%}.
To print without colors, use {\small\verb%pp_print_type%}.

For its color configuration, see {\small\verb%pp_print_colored_type%}.

\FAILURE
Should never fail unless the formatter does.

\SEEALSO
pp_print_colored_type, pp_print_type, print_qtype, print_type, set_color_printer.

\ENDDOC
\DOC{pp{\_}print{\_}colored{\_}term}

\TYPE {\small\verb%pp_print_colored_term : formatter -> term -> unit%}\egroup

\SYNOPSIS
Prints a term (without quotes) with colors to formatter.

\DESCRIBE
The call {\small\verb%pp_print_colored_term fmt tm%} prints the colored representation of the
term {\small\verb%tm%} to the formatter {\small\verb%fmt%}. The string is just {\small\verb%tm%} not {\small\verb%`tm`%}.
To print without colors, use {\small\verb%pp_print_term%}.

Colors can be changed by setting OCaml reference variables of optional strings
describing the ANSI color code.
If set to {\small\verb%None%}, the default color of the terminal is used.

- {\small\verb%printer_color_const%}: a text color for constants.

- {\small\verb%printer_color_resword%}: a text color for reserved words (see {\small\verb%is_reserved_word%}).

- {\small\verb%printer_color_binder%}: a text color for binders (see {\small\verb%parses_as_binder%}).

- {\small\verb%printer_color_infix%}: a text color for infix operators (see {\small\verb%get_infix_status%}).

- {\small\verb%printer_color_prefix%}: a text color for prefix operators (see {\small\verb%is_prefix%}).

\FAILURE
Should never fail unless the formatter does.

\SEEALSO
get_infix_status, is_prefix, is_reserved_word, parses_as_binder,
pp_print_colored_qterm, pp_print_term, pp_print_qterm, print_qterm, print_term, set_color_printer

\ENDDOC
\DOC{pp{\_}print{\_}colored{\_}thm}

\TYPE {\small\verb%pp_print_colored_thm : formatter -> thm -> unit%}\egroup

\SYNOPSIS
Prints a theorem to formatter.

\DESCRIBE
The call {\small\verb%pp_print_colored_thm fmt th%} prints the colored representation of the
theorem {\small\verb%th%} to the formatter {\small\verb%fmt%}.
To print without colors, use {\small\verb%pp_print_thm%}.

For its color configuration, see {\small\verb%pp_print_colored_type%} and {\small\verb%pp_print_colored_term%}.

\FAILURE
Should never fail unless the formatter does.

\SEEALSO
pp_print_colored_term, pp_print_colored_type, pp_print_thm, print_thm, set_color_printer.

\ENDDOC
\DOC{pp{\_}print{\_}colored{\_}type}

\TYPE {\small\verb%pp_print_colored_type : formatter -> hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type (without colon or quotes) with colors to formatter.

\DESCRIBE
The call {\small\verb%pp_print_colored_type fmt ty%} prints the colored representation of the
type {\small\verb%ty%} to the formatter {\small\verb%fmt%}. The string is just {\small\verb%ty%} not {\small\verb%`:ty`%}.
To print without colors, use {\small\verb%pp_print_type%}.

Colors can be changed by setting OCaml reference variables of optional strings
describing the ANSI color code.
If set to {\small\verb%None%}, the default color of the terminal is used.

- {\small\verb%printer_color_typevar%}: a text color for type variables.

- {\small\verb%printer_color_itypevar%}: a text color for invented type variables.

- {\small\verb%printer_color_type%}: a text color for generic type expressions.

\FAILURE
Should never fail unless the formatter does.

\SEEALSO
pp_print_colored_qtype, pp_print_type, pp_print_qtype, print_qtype, print_type, set_color_printer.

\ENDDOC
\DOC{pp{\_}print{\_}fpf}

\TYPE {\small\verb%pp_print_fpf : Format.formatter -> ('a, 'b) func -> unit%}\egroup

\SYNOPSIS
Print a finite partial function to a formatter.

\DESCRIBE
This prints a finite partial function but only as a trivial string `{\small\verb%<func>%}',
to the given formatter. Installed automatically at the top level and probably
not useful for most users.

\FAILURE
Never fails.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_fpf%}.

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, print_fpf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{pp{\_}print{\_}num}

\TYPE {\small\verb%pp_print_num : Format.formatter -> num -> unit%}\egroup

\SYNOPSIS
Print an arbitrary-precision number to the given formatter.

\DESCRIBE
This function prints an arbitrary-precision (type {\small\verb%num%}) number to the
formatter given as first argument. It is automatically invoked on anything of
type {\small\verb%num%} at the toplevel anyway, but it may sometimes be useful to issue it
under user control.

\FAILURE
Never fails.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_num%}.

\SEEALSO
print_num.

\ENDDOC
\DOC{pp{\_}print{\_}qterm}

\TYPE {\small\verb%pp_print_qterm : formatter -> term -> unit%}\egroup

\SYNOPSIS
Prints a term with surrounding quotes to formatter.

\DESCRIBE
The call {\small\verb%pp_print_term fmt tm%} prints the usual textual representation of the
term {\small\verb%tm%} to the formatter {\small\verb%fmt%}, in the form {\small\verb%`tm`%}.

To print a term with colors, use {\small\verb%pp_print_colored_qterm%}.

\FAILURE
Should never fail unless the formatter does.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_qterm%}.

\SEEALSO
pp_print_colored_term, pp_print_colored_qterm, pp_print_term, print_qterm, print_term.

\ENDDOC
\DOC{pp{\_}print{\_}qtype}

\TYPE {\small\verb%pp_print_qtype : formatter -> hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type with initial colon and surrounding quotes to formatter.

\DESCRIBE
The call {\small\verb%pp_print_type fmt ty%} prints the usual textual representation of the
type {\small\verb%ty%} to the formatter {\small\verb%fmt%}, in the form {\small\verb%`:ty`%}.

To print a type with colors, use {\small\verb%pp_print_colored_qtype%}.

\FAILURE
Should never fail unless the formatter does.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_qtype%}.

\SEEALSO
pp_print_colored_type, pp_print_colored_qtype, pp_print_type, print_qtype, print_type.

\ENDDOC
\DOC{pp{\_}print{\_}term}

\TYPE {\small\verb%pp_print_term : formatter -> term -> unit%}\egroup

\SYNOPSIS
Prints a term (without quotes) to formatter.

\DESCRIBE
The call {\small\verb%pp_print_term fmt tm%} prints the usual textual representation of the
term {\small\verb%tm%} to the formatter {\small\verb%fmt%}. The string is just {\small\verb%tm%} not {\small\verb%`tm`%}.

To print a term with colors, use {\small\verb%pp_print_colored_term%}.

\FAILURE
Should never fail unless the formatter does.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_term%}.

\SEEALSO
pp_print_colored_term, pp_print_colored_qterm, pp_print_qterm, print_qterm, print_term,

\ENDDOC
\DOC{pp{\_}print{\_}thm}

\TYPE {\small\verb%pp_print_thm : formatter -> thm -> unit%}\egroup

\SYNOPSIS
Prints a theorem to formatter.

\DESCRIBE
The call {\small\verb%pp_print_thm fmt th%} prints the usual textual representation of the
theorem {\small\verb%th%} to the formatter {\small\verb%fmt%}.

\FAILURE
Should never fail unless the formatter does.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_thm%}.

\SEEALSO
pp_print_colored_thm, print_thm.

\ENDDOC
\DOC{pp{\_}print{\_}type}

\TYPE {\small\verb%pp_print_type : formatter -> hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type (without colon or quotes) to formatter.

\DESCRIBE
The call {\small\verb%pp_print_type fmt ty%} prints the usual textual representation of the
type {\small\verb%ty%} to the formatter {\small\verb%fmt%}. The string is just {\small\verb%ty%} not {\small\verb%`:ty`%}.

To print a type with colors, use {\small\verb%pp_print_colored_type%}.

\FAILURE
Should never fail unless the formatter does.

\COMMENTS
The usual case where the formatter is the standard output is {\small\verb%print_type%}.

\SEEALSO
pp_print_colored_type, pp_print_colored_qtype, pp_print_qtype, print_qtype, print_type.

\ENDDOC
\DOC{prebroken{\_}binops}

\TYPE {\small\verb%prebroken_binops : string list ref%}\egroup

\SYNOPSIS
Determines which binary operators are line-broken to the left

\DESCRIBE
The reference variable {\small\verb%prebroken_binops%} is one of several settable parameters
controlling printing of terms by {\small\verb%pp_print_term%}, and hence the automatic
printing of terms and theorems at the toplevel. It holds a list of the names of
binary operators that, when a line break is needed, will be printed after the
line break rather than before it. By default it contains just implication.

\FAILURE
Not applicable.

\COMMENTS
Putting more operators such as conjunction in this list gives an output format
closer to the one advocated in Lamport's ``How to write a large formula''
paper.

\SEEALSO
pp_print_term, print_all_thm, print_unambiguous_comprehensions,
reverse_interface_mapping, typify_universal_set, unspaced_binops.

\ENDDOC
\DOC{prefixes}

\TYPE {\small\verb%prefixes : unit -> string list%}\egroup

\SYNOPSIS
Certain identifiers {\small\verb%c%} have prefix status, meaning that combinations of the
form {\small\verb%c f x%} will be parsed as {\small\verb%c (f x)%} rather than the usual {\small\verb%(c f) x%}. The
call {\small\verb%prefixes()%} returns the list of all such identifiers.

\FAILURE
Never fails.

\EXAMPLE
In the default HOL state:
{\par\samepage\setseps\small
\begin{verbatim}
  # prefixes();;
  val it : string list = ["~"; "--"; "mod"]
\end{verbatim}
}
This explains, for example, why `{\small\verb%~ ~ p%}' parses as `{\small\verb%~(~p)%}' rather than
parsing as `{\small\verb%(~ ~) p%}' and generating a typechecking error.

\SEEALSO
is_prefix, parse_as_prefix, unparse_as_prefix.

\ENDDOC
\DOC{PRENEX{\_}CONV}

\TYPE {\small\verb%PRENEX_CONV : conv%}\egroup

\SYNOPSIS
Puts a term already in NNF into prenex form.

\DESCRIBE
When applied to a term already in negation normal form (see {\small\verb%NNF_CONV%}, for
example), the conversion {\small\verb%PRENEX_CONV%} proves it equal to an equivalent in
prenex form, with all quantifiers at the top level and a propositional body.

\FAILURE
Never fails; even on non-Boolean terms it will just produce a reflexive
theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # PRENEX_CONV `(!x. ?y. P x y) \/ (?u. !v. ?w. Q u v w)`;;
  Warning: inventing type variables
  val it : thm =
    |- (!x. ?y. P x y) \/ (?u. !v. ?w. Q u v w) <=>
       (!x. ?y u. !v. ?w. P x y \/ Q u v w)
\end{verbatim}
}

\SEEALSO
CNF_CONV, DNF_CONV, NNFC_CONV, NNF_CONV, SKOLEM_CONV, WEAK_CNF_CONV,
WEAK_DNF_CONV.

\ENDDOC
\DOC{PRESIMP{\_}CONV}

\TYPE {\small\verb%PRESIMP_CONV : conv%}\egroup

\SYNOPSIS
Applies basic propositional simplifications and some miniscoping.

\DESCRIBE
The conversion {\small\verb%PRESIMP_CONV%} applies various routine simplifications to
Boolean terms involving constants, e.g. {\small\verb%p /\ T <=> p%}. It also tries to push
universal quantifiers through conjunctions and existential quantifiers through
disjunctions, e.g. {\small\verb%(?x. p[x] \/ q[x]) <=> (?x. p[x]) \/ (?x. q[x])%}
(``miniscoping'') but does not transform away other connectives like
implication that would allow it do do this more completely.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # PRESIMP_CONV `?x. x = 1 /\ y = 1 \/ F \/ T /\ y = 2`;;
  val it : thm =
    |- (?x. x = 1 /\ y = 1 \/ F \/ T /\ y = 2) <=>
       (?x. x = 1) /\ y = 1 \/ y = 2
\end{verbatim}
}

\USES
Useful as an initial simplification before more substantial normal form
conversions.

\SEEALSO
CNF_CONV, DNF_CONV, NNF_CONV, PRENEX_CONV, SKOLEM_CONV.

\ENDDOC
\DOC{preterm{\_}of{\_}term}

\TYPE {\small\verb%preterm_of_term : term -> preterm%}\egroup

\SYNOPSIS
Converts a term into a preterm.

\DESCRIBE
HOL Light uses ``pretypes'' and ``preterms'' as intermediate structures for
parsing and typechecking, which are later converted to types and terms. A call
{\small\verb%preterm_of_term `tm`%} converts in the other direction, from a normal HOL term
back to a preterm.

\FAILURE
Never fails.

\USES
User manipulation of preterms is not usually necessary, unless you seek to
radically change aspects of parsing and typechecking.

\SEEALSO
pretype_of_type, term_of_preterm.

\ENDDOC
\DOC{pretype{\_}of{\_}type}

\TYPE {\small\verb%pretype_of_type : hol_type -> pretype%}\egroup

\SYNOPSIS
Converts a type into a pretype.

\DESCRIBE
HOL Light uses ``pretypes'' and ``preterms'' as intermediate structures for
parsing and typechecking, which are later converted to types and terms. A call
{\small\verb%preterm_of_term `tm`%} converts in the other direction, from a normal HOL term
back to a preterm.

\FAILURE
Never fails.

\USES
User manipulation of pretypes is not usually necessary, unless you seek to
radically change aspects of parsing and typechecking.

\SEEALSO
preterm_of_term, type_of_pretype.

\ENDDOC
\DOC{print{\_}all{\_}thm}

\TYPE {\small\verb%print_all_thm : bool ref%}\egroup

\SYNOPSIS
Flag determining whether the assumptions of theorems are printed explicitly.

\DESCRIBE
The reference variable {\small\verb%print_all_thm%} is one of several
settable parameters controlling printing of terms by {\small\verb%pp_print_term%}, and hence
the automatic printing of terms and theorems at the toplevel.
When it is {\small\verb%true%}, as it is by default, all assumptions of theorems are
printed. When it is {\small\verb%false%}, they are abbreviated by dots.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ADD_ASSUM `1 + 1 = 2` (ASSUME `2 + 2 = 4`);;
  val th : thm = 2 + 2 = 4, 1 + 1 = 2 |- 2 + 2 = 4
  # print_all_thm := false;;
  val it : unit = ()
  # th;;
  val it : thm = ... |- 2 + 2 = 4
\end{verbatim}
}

\SEEALSO
pp_print_term, prebroken_binops, print_goal_hyp_max_boxes,
print_unambiguous_comprehensions, reverse_interface_mapping,
typify_universal_set, unspaced_binops.

\ENDDOC
\DOC{print{\_}fpf}

\TYPE {\small\verb%print_fpf : ('a, 'b) func -> unit%}\egroup

\SYNOPSIS
Print a finite partial function.

\DESCRIBE
This prints a finite partial function but only as a trivial string `{\small\verb%<func>%}'.
Installed automatically at the top level and probably not useful for most
users.

\FAILURE
Never fails.

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, pp_print_fpf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{print{\_}goal}

\TYPE {\small\verb%print_goal : goal -> unit%}\egroup

\SYNOPSIS
Print a goal.

\DESCRIBE
{\small\verb%print_goal g%} prints the goal {\small\verb%g%} to standard output, with no following
newline.

\FAILURE
Never fails.

\COMMENTS
This is invoked automatically when something of type {\small\verb%goal%} is produced at
the top level, so manual invocation is not normally needed.

\SEEALSO
print_goalstack, print_term, PRINT_GOAL_TAC.

\ENDDOC
\DOC{print{\_}goalstack}

\TYPE {\small\verb%print_goalstack : goalstack -> unit%}\egroup

\SYNOPSIS
Print a goalstack.

\DESCRIBE
{\small\verb%print_goalstack gs%} prints the goalstack {\small\verb%gs%} to standard output, with no
following newline.

\FAILURE
Never fails.

\COMMENTS
This is invoked automatically when something of type {\small\verb%goalstack%} is produced at
the top level, so manual invocation is not normally needed.

\SEEALSO
print_goal, print_term, PRINT_GOAL_TAC.

\ENDDOC
\DOC{print{\_}goal{\_}hyp{\_}max{\_}boxes}

\TYPE {\small\verb%print_goal_hyp_max_boxes : int option ref%}\egroup

\SYNOPSIS
Flag determining the maximum number of boxes used to pretty-print each hypothesis
of a goal.

\DESCRIBE
The reference variable {\small\verb%print_goal_hyp_max_boxes%} is a parameter controlling
the maximum number of boxes used to pretty-print each hypothesis of a goal.
This reference variable is used by {\small\verb%pp_print_goal%}.
A box is a logical unit for pretty-printing an object and it is used by OCaml's
{\small\verb%Format%} module.
When it is set to {\small\verb%Some k%}, {\small\verb%k%} is used as the maximum number of boxes and
terms in a hypothesis that need more than {\small\verb%k%} boxes are abbreviated by a
dot ({\small\verb%.%}).
When it is set to {\small\verb%None%}, the maximum number of boxes configured in OCaml's
default formatter is used.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
   # g `1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10
        ==> 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 20`;;
   val it : goalstack = 1 subgoal (1 total)

   `1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10
   ==> 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 20`

   # e(STRIP_TAC);;
   val it : goalstack = 1 subgoal (1 total)

   0 [`1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10`]

   `2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 20`

   # print_goal_hyp_max_boxes := Some 5;;
   val it : unit = ()
   # p();;
   val it : goalstack = 1 subgoal (1 total)

   0 [`. = 10`]

   `2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 20`

   # print_goal_hyp_max_boxes := None;;
   val it : unit = ()
   # p();;
   val it : goalstack = 1 subgoal (1 total)

   0 [`1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 10`]

   `2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 = 20`
\end{verbatim}
}

\SEEALSO
pp_print_goal, print_all_thm.

\ENDDOC
\DOC{PRINT{\_}GOAL{\_}TAC}

\TYPE {\small\verb%PRINT_GOAL_TAC : tactic%}\egroup

\SYNOPSIS
Prints the goal to standard output.

\DESCRIBE
Given any goal {\small\verb%A ?- p%}, the tactic {\small\verb%PRINT_GOAL_TAC%} prints the goal
to standard output.

\FAILURE
Never fails.

\SEEALSO
print_goal, print_goalstack, print_term, PRINT_TERM_CONV, REMARK_TAC

\ENDDOC
\DOC{print{\_}num}

\TYPE {\small\verb%print_num : num -> unit%}\egroup

\SYNOPSIS
Print an arbitrary-precision number to the terminal.

\DESCRIBE
This function prints an arbitrary-precision (type {\small\verb%num%}) number to the
terminal. It is automatically invoked on anything of type {\small\verb%num%} at the toplevel
anyway, but it may sometimes be useful to issue it under user control.

\FAILURE
Never fails.

\SEEALSO
pp_print_num.

\ENDDOC
\DOC{print{\_}qterm}

\TYPE {\small\verb%print_qterm : term -> unit%}\egroup

\SYNOPSIS
Prints a HOL term with surrounding quotes to standard output.

\DESCRIBE
The call {\small\verb%print_term tm%} prints the usual textual representation of the
term {\small\verb%tm%} to the standard output, that is {\small\verb%`:tm`%}.

\FAILURE
Never fails.

\COMMENTS
This is the function that is invoked automatically in the toplevel when
printing terms.

\SEEALSO
pp_print_qterm, pp_print_term, print_term.

\ENDDOC
\DOC{print{\_}qtype}

\TYPE {\small\verb%print_qtype : hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type with colon and surrounding quotes to standard output.

\DESCRIBE
The call {\small\verb%print_type ty%} prints the usual textual representation of the
type {\small\verb%ty%} to the standard output, that is {\small\verb%`:ty`%}.

\FAILURE
Never fails.

\COMMENTS
This is the function that is invoked automatically in the toplevel when
printing types.

\SEEALSO
pp_print_qtype, pp_print_type, print_type.

\ENDDOC
\DOC{print{\_}term}

\TYPE {\small\verb%print_term : term -> unit%}\egroup

\SYNOPSIS
Prints a HOL term (without quotes) to the standard output.

\DESCRIBE
The call {\small\verb%print_term tm%} prints the usual textual representation of the
term {\small\verb%tm%} to the standard output. The string is just {\small\verb%tm%} not {\small\verb%`tm`%}.

\FAILURE
Never fails.

\USES
Producing debugging output in complex rules. Note that terms are already
printed at the toplevel anyway, so it is not needed to examine results
interactively.

\SEEALSO
pp_print_qterm, pp_print_term, print_qterm.

\ENDDOC
\DOC{PRINT{\_}TERM{\_}CONV}

\TYPE {\small\verb%PRINT_TERM_CONV : conv%}\egroup

\SYNOPSIS
Prints the term to standard output.

\DESCRIBE
The conversion {\small\verb%PRINT_TERM_CONV%} prints the current term to standard output.

\FAILURE
Never fails.

\SEEALSO
print_term, PRINT_GOAL_TAC, REMARK_TAC

\ENDDOC
\DOC{print{\_}thm}

\TYPE {\small\verb%print_thm : thm -> unit%}\egroup

\SYNOPSIS
Prints a HOL theorem to the standard output.

\DESCRIBE
The call {\small\verb%print_thm th%} prints the usual textual representation of the
theorem {\small\verb%th%} to the standard output.

\COMMENTS
This is invoked automatically at the toplevel when theorems are printed.

\SEEALSO
print_type, print_term.

\ENDDOC
\DOC{print{\_}to{\_}string}

\TYPE {\small\verb%print_to_string : (formatter -> 'a -> 'b) -> 'a -> string%}\egroup

\SYNOPSIS
Modifies a formatting printing function to return its output as a string.

\DESCRIBE
If {\small\verb%p%} is a printing function whose first argument is a formatter (a standard
OCaml datatype indicating an output for printing functions), {\small\verb%print_to_string
P%} gives a function that invokes it and collects and returns its output as a
string.

\FAILURE
Fails only if the core printing function fails.

\EXAMPLE
The standard function {\small\verb%string_of_term%} is defined as:
{\par\samepage\setseps\small
\begin{verbatim}
  # let string_of_term = print_to_string pp_print_term;;
\end{verbatim}
}

\USES
Converting a general printing function to a `convert to string' function, as in
the example above.

\SEEALSO
pp_print_term, pp_print_thm, pp_print_type.

\ENDDOC
\DOC{print{\_}type}

\TYPE {\small\verb%print_type : hol_type -> unit%}\egroup

\SYNOPSIS
Prints a type (without colon or quotes) to standard output.

\DESCRIBE
The call {\small\verb%print_type ty%} prints the usual textual representation of the
type {\small\verb%ty%} to the standard output. The string is just {\small\verb%ty%} not {\small\verb%`:ty`%}.

\FAILURE
Never fails.

\USES
Producing debugging output in complex rules. Note that terms are already
printed at the toplevel anyway, so it is not needed to examine results
interactively.

\SEEALSO
pp_print_qtype, pp_print_type, print_qtype.

\ENDDOC
\DOC{print{\_}types{\_}of{\_}subterms}

\TYPE {\small\verb%print_types_of_subterms : int ref%}\egroup

\SYNOPSIS
Flag controlling the level of printing types of subterms.

\DESCRIBE
The reference variable {\small\verb%print_types_of_subterms%} is one of several
settable parameters controlling printing of terms by {\small\verb%pp_print_term%}, and hence
the automatic printing of terms and theorems at the toplevel.

When it is {\small\verb%0%}, {\small\verb%pp_print_term%} does not print the types of subterms.
When it is {\small\verb%1%}, as it is by default, {\small\verb%pp_print_term%} only prints types of subterms containing invented type variables.
When it is {\small\verb%2%}, {\small\verb%pp_print_term%} prints the types of all constants and variables in the term.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # loadt "Library/words.ml";;
  ...

  # `word_join (word 10:int64) (word 20:int64)`;;
  Warning: inventing type variables
  val it : term =
    `(word_join:(64)word->(64)word->(?194629)word) (word 10) (word 20)`
  # `word_join (word 10:int64) (word 20:int64):int128`;;
  val it : term = `word_join (word 10) (word 20)`

  # print_types_of_subterms := 0;;
  val it : unit = ()
  # `word_join (word 10:int64) (word 20:int64)`;;
  Warning: inventing type variables
  val it : term = `word_join (word 10) (word 20)`
  # `word_join (word 10:int64) (word 20:int64):int128`;;
  val it : term = `word_join (word 10) (word 20)`

  # print_types_of_subterms := 2;;
  val it : unit = ()
  # `word_join (word 10:int64) (word 20:int64)`;;
  Warning: inventing type variables
  val it : term =
    `(word_join:(64)word->(64)word->(?194609)word) ((word:num->(64)word) 10)
    ((word:num->(64)word) 20)`
  # `word_join (word 10:int64) (word 20:int64):int128`;;
  val it : term =
    `(word_join:(64)word->(64)word->(128)word) ((word:num->(64)word) 10)
    ((word:num->(64)word) 20)`
\end{verbatim}
}

\SEEALSO
pp_print_term, type_invention_error, type_invention_warning

\ENDDOC
\DOC{print{\_}unambiguous{\_}comprehensions}

\TYPE {\small\verb%print_unambiguous_comprehensions : bool ref%}\egroup

\SYNOPSIS
Determines whether bound variables in set abstractions are made explicit.

\DESCRIBE
The reference variable {\small\verb%print_unambiguous_comprehensions%} is one of several
settable parameters controlling printing of terms by {\small\verb%pp_print_term%}, and hence
the automatic printing of terms and theorems at the toplevel. When it is
{\small\verb%true%}, all set comprehensions are printed with an explicit indication of the
bound variables in the middle: {\small\verb%`{t | vs | p}`%}. When it is {\small\verb%false%}, as it is
by default, this printing of the set of bound variables is only done when the
term would otherwise fail to match the default parsing behaviour on input, and
otherwise just printed as {\small\verb%`{t | p}`%}. The parsing behaviour for such a term is
to take the bound variables to be those free in both {\small\verb%t%} and {\small\verb%p%}, unless there
is just one variable free in {\small\verb%t%} (in which case that variable is the only bound
one) or there are none free in {\small\verb%p%} (in which case all free variables of {\small\verb%t%} are
taken).

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # print_unambiguous_comprehensions := false;;
  val it : unit = ()
  # `{x + y | x | EVEN(x)}`;;
  val it : term = `{x + y | EVEN x}`

  # print_unambiguous_comprehensions := true;;
  val it : unit = ()
  # `{x + y | x | EVEN(x)}`;;
  val it : term = `{x + y | x | EVEN x}`
\end{verbatim}
}

\SEEALSO
pp_print_term, prebroken_binops, print_all_thm, reverse_interface_mapping,
typify_universal_set, unspaced_binops.

\ENDDOC
\DOC{prioritize{\_}int}

\TYPE {\small\verb%prioritize_int : unit -> unit%}\egroup

\SYNOPSIS
Give integer type {\small\verb%int%} priority in operator overloading.

\DESCRIBE
Symbols for several arithmetical (`{\small\verb%+%}', `{\small\verb%-%}', ...) and relational (`{\small\verb%<%}',
`{\small\verb%>=%}', ...) operators are overloaded so that they may denote the operators
for several different number systems, particularly {\small\verb%num%} (natural numbers),
{\small\verb%int%} (integers) and {\small\verb%real%} (real numbers). The choice is normally made based
on some known types, or the presence of operators that are not overloaded for
the number systems. (For example, numerals like {\small\verb%42%} are always assumed to be
of type {\small\verb%num%}, while the division operator `{\small\verb%/%}' is only defined for {\small\verb%real%}.)
In the absence of any such indication, a default choice will be made. The
effect of {\small\verb%prioritize_int()%} is to make {\small\verb%int%}, the integer type, the
default.

\FAILURE
Never fails.

\EXAMPLE
With integer priority, most things are interpreted as type {\small\verb%int%}
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_int();;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:int`
\end{verbatim}
}
\noindent except that numerals are always of type {\small\verb%num%}, and so:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `x + 1`;;
  val it : hol_type = `:num`
\end{verbatim}
}
\noindent and any explicit type information is used before using the defaults:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `(x:real) + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}

\COMMENTS
It is perhaps better practice to insert types explicitly to avoid dependence on
such defaults, otherwise proofs can become context-dependent. However it is
often very convenient.

\SEEALSO
make_overloadable, overload_interface, prioritize_num, prioritize_overload,
prioritize_real, the_overload_skeletons.

\ENDDOC
\DOC{prioritize{\_}num}

\TYPE {\small\verb%prioritize_num : unit -> unit%}\egroup

\SYNOPSIS
Give natural number type {\small\verb%num%} priority in operator overloading.

\DESCRIBE
Symbols for several arithmetical (`{\small\verb%+%}', `{\small\verb%-%}', ...) and relational (`{\small\verb%<%}',
`{\small\verb%>=%}', ...) operators are overloaded so that they may denote the operators
for several different number systems, particularly {\small\verb%num%} (natural numbers),
{\small\verb%int%} (integers) and {\small\verb%real%} (real numbers). The choice is normally made based
on some known types, or the presence of operators that are not overloaded for
the number systems. (For example, numerals like {\small\verb%42%} are always assumed to be
of type {\small\verb%num%}, while the division operator `{\small\verb%/%}' is only defined for {\small\verb%real%}.)
In the absence of any such indication, a default choice will be made. The
effect of {\small\verb%prioritize_num()%} is to make {\small\verb%num%}, the natural number type, the
default.

\FAILURE
Never fails.

\EXAMPLE
With real priority, most things are interpreted as type {\small\verb%real%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_real();;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}
\noindent except that numerals are always of type {\small\verb%num%}, and so:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `x + 1`;;
  val it : hol_type = `:num`
\end{verbatim}
}
\noindent By making {\small\verb%num%} the priority, everything is interpreted as {\small\verb%num%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_num();;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:num`
\end{verbatim}
}
\noindent unless there is some explicit type information to the contrary:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `(x:real) + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}

\COMMENTS
It is perhaps better practice to insert types explicitly to avoid dependence on
such defaults, otherwise proofs can become context-dependent. However it is
often very convenient.

\SEEALSO
make_overloadable, overload_interface, prioritize_int, prioritize_overload,
prioritize_real, the_overload_skeletons.

\ENDDOC
\DOC{prioritize{\_}overload}

\TYPE {\small\verb%prioritize_overload : hol_type -> unit%}\egroup

\SYNOPSIS
Give overloaded constants involving a given type priority in operator
overloading.

\DESCRIBE
In general, overloaded operators in the concrete syntax, such as `{\small\verb%+%}', are
ambiguous, referring to one of several underlying constants. The choice is
normally made based on some known types, or the presence of operators that are
not overloaded for the number systems. (For example, numerals like {\small\verb%42%} are
always assumed to be of type {\small\verb%num%}, while the division operator `{\small\verb%/%}' is only
defined for {\small\verb%real%}.) In the absence of any such indication, a default choice
will be made. The effect of {\small\verb%prioritize_overload `:ty`%} is to run through the
overloaded symbols making the first instance of each where the generic type
variables in the type skeleton are replaced by type {\small\verb%`:ty`%} the first priority
when no other indication is made.

\FAILURE
Never fails.

\EXAMPLE
With real priority, most things are interpreted as type {\small\verb%real%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_overload `:real`;;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}
\noindent By making {\small\verb%int%} the priority, everything is interpreted as {\small\verb%int%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_overload `:int`;;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:int`
\end{verbatim}
}
\noindent unless there is some explicit type information to the contrary:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `(x:real) + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}

\COMMENTS
It is perhaps better practice to insert types explicitly to avoid dependence on
such defaults, otherwise proofs can become context-dependent. However it is
often very convenient.

\SEEALSO
make_overloadable, overload_interface, prioritize_int, prioritize_num,
prioritize_real, the_implicit_types, the_overload_skeletons.

\ENDDOC
\DOC{prioritize{\_}real}

\TYPE {\small\verb%prioritize_real : unit -> unit%}\egroup

\SYNOPSIS
Give real number type {\small\verb%real%} priority in operator overloading.

\DESCRIBE
Symbols for several arithmetical (`{\small\verb%+%}', `{\small\verb%-%}', ...) and relational (`{\small\verb%<%}',
`{\small\verb%>=%}', ...) operators are overloaded so that they may denote the operators
for several different number systems, particularly {\small\verb%num%} (natural numbers),
{\small\verb%int%} (integers) and {\small\verb%real%} (real numbers). The choice is normally made based
on some known types, or the presence of operators that are not overloaded for
the number systems. (For example, numerals like {\small\verb%42%} are always assumed to be
of type {\small\verb%num%}, while the division operator `{\small\verb%/%}' is only defined for {\small\verb%real%}.)
In the absence of any such indication, a default choice will be made. The
effect of {\small\verb%prioritize_real()%} is to make {\small\verb%real%}, the real number type, the
default.

\FAILURE
Never fails.

\EXAMPLE
With real priority, most things are interpreted as type {\small\verb%real%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prioritize_real();;
  val it : unit = ()

  # type_of `x + y`;;
  val it : hol_type = `:real`
\end{verbatim}
}
\noindent except that numerals are always of type {\small\verb%num%}, and so:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `x + 1`;;
  val it : hol_type = `:num`
\end{verbatim}
}
\noindent and any explicit type information is used before using the defaults:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `(x:int) + y`;;
  val it : hol_type = `:int`
\end{verbatim}
}

\COMMENTS
It is perhaps better practice to insert types explicitly to avoid dependence on
such defaults, otherwise proofs can become context-dependent. However it is
often very convenient.

\SEEALSO
make_overloadable, overload_interface, prioritize_int, prioritize_num,
prioritize_overload, the_overload_skeletons.

\ENDDOC
\DOC{PROP{\_}ATOM{\_}CONV}

\TYPE {\small\verb%PROP_ATOM_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the `atomic subformulas' of a formula.

\DESCRIBE
When applied to a Boolean term, {\small\verb%PROP_ATOM_CONV conv%} descends recursively
through any number of the core propositional connectives `{\small\verb%~%}', `{\small\verb%/\%}', `{\small\verb%\/%}',
`{\small\verb%==>%}' and `{\small\verb%<=>%}', as well as the quantifiers `{\small\verb%!x. p[x]%}', `{\small\verb%?x. p[x]%}' and
`{\small\verb%?!x. p[x]%}'. When it reaches a subterm that can no longer be decomposed into
any of those items (e.g. the starting term if it is not of Boolean type), the
conversion {\small\verb%conv%} is tried, with a reflexive theorem returned in case of
failure. That is, the conversion is applied to the ``atomic subformulas'' in
the usual sense of first-order logic.

\FAILURE
Never fails.

\EXAMPLE
Here we swap all equations in a formula, but not any logical equivalences that
are part of its logical structure:
{\par\samepage\setseps\small
\begin{verbatim}
 # PROP_ATOM_CONV(ONCE_DEPTH_CONV SYM_CONV)
    `(!x. x = y ==> x = z) <=> (y = z <=> 1 + z = z + 1)`;;
  val it : thm =
    |- ((!x. x = y ==> x = z) <=> y = z <=> 1 + z = z + 1) <=>
       (!x. y = x ==> z = x) <=>
       z = y <=>
       z + 1 = 1 + z
\end{verbatim}
}
\noindent By contrast, just {\small\verb%ONCE_DEPTH_CONV SYM_CONV%} would just swap the
top-level logical equivalence.

\USES
Carefully constraining the application of conversions.

\SEEALSO
DEPTH_BINOP_CONV, ONCE_DEPTH_CONV.

\ENDDOC
\DOC{prove}

\TYPE {\small\verb%prove : term * tactic -> thm%}\egroup

\SYNOPSIS
Attempts to prove a boolean term using the supplied tactic.

\DESCRIBE
When applied to a term-tactic pair {\small\verb%(tm,tac)%}, the function {\small\verb%prove%} attempts to
prove the goal {\small\verb%?- tm%}, that is, the term {\small\verb%tm%} with no assumptions, using the
tactic {\small\verb%tac%}. If {\small\verb%prove%} succeeds, it returns the corresponding theorem
{\small\verb%A |- tm%}, where the assumption list {\small\verb%A%} may not be empty if the tactic is
invalid; {\small\verb%prove%} has no inbuilt validity-checking.

\FAILURE
Fails if the term is not of type {\small\verb%bool%} (and so cannot possibly be
the conclusion of a theorem), or if the tactic cannot solve the goal.
In the latter case {\small\verb%prove%} will list the unsolved goals to help the user.

\SEEALSO
TAC_PROOF, VALID.

\ENDDOC
\DOC{prove{\_}cases{\_}thm}

\TYPE {\small\verb%prove_cases_thm : thm -> thm%}\egroup

\SYNOPSIS
Proves a structural cases theorem for an automatically-defined concrete type.

\DESCRIBE
{\small\verb%prove_cases_thm%} takes as its argument a structural induction theorem, in the
form returned by {\small\verb%prove_induction_thm%} for an automatically-defined concrete
type.  When applied to such a theorem, {\small\verb%prove_cases_thm%} automatically proves
and returns a theorem which states that every value the concrete type in
question is denoted by the value returned by some constructor of the type.

\FAILURE
Fails if the argument is not a theorem of the form returned by
{\small\verb%prove_induction_thm%}

\EXAMPLE
The following type definition for labelled binary trees:
{\par\samepage\setseps\small
\begin{verbatim}
  # let ith,rth = define_type "tree = LEAF num | NODE tree tree";;
  val ith : thm =
    |- !P. (!a. P (LEAF a)) /\ (!a0 a1. P a0 /\ P a1 ==> P (NODE a0 a1))
           ==> (!x. P x)
  val rth : thm =
    |- !f0 f1.
           ?fn. (!a. fn (LEAF a) = f0 a) /\
                (!a0 a1. fn (NODE a0 a1) = f1 a0 a1 (fn a0) (fn a1))
\end{verbatim}
}
\noindent returns an induction theorem {\small\verb%ith%} that can then be fed to
{\small\verb%prove_cases_thm%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_cases_thm ith;;
  val it : thm = |- !x. (?a. x = LEAF a) \/ (?a0 a1. x = NODE a0 a1)
\end{verbatim}
}

\COMMENTS
An easier interface is {\small\verb%cases "tree"%}. This function is mainly intended to
generate the cases theorems for that function.

\SEEALSO
cases, define_type, INDUCT_THEN, new_recursive_definition,
prove_constructors_distinct, prove_constructors_one_one, prove_induction_thm.

\ENDDOC
\DOC{prove{\_}constructors{\_}distinct}

\TYPE {\small\verb%prove_constructors_distinct : thm -> thm%}\egroup

\SYNOPSIS
Proves that the constructors of an automatically-defined concrete type yield
distinct values.

\DESCRIBE
{\small\verb%prove_constructors_distinct%} takes as its argument a primitive recursion
theorem, in the form returned by {\small\verb%define_type%} for an automatically-defined
concrete type.  When applied to such a theorem, {\small\verb%prove_constructors_distinct%}
automatically proves and returns a theorem which states that distinct
constructors of the concrete type in question yield distinct values of this
type.

\FAILURE
Fails if the argument is not a theorem of the form returned by {\small\verb%define_type%},
or if the concrete type in question has only one constructor.

\EXAMPLE
The following type definition for labelled binary trees:
{\par\samepage\setseps\small
\begin{verbatim}
  # let ith,rth = define_type "tree = LEAF num | NODE tree tree";;
  val ith : thm =
    |- !P. (!a. P (LEAF a)) /\ (!a0 a1. P a0 /\ P a1 ==> P (NODE a0 a1))
           ==> (!x. P x)
  val rth : thm =
    |- !f0 f1.
           ?fn. (!a. fn (LEAF a) = f0 a) /\
                (!a0 a1. fn (NODE a0 a1) = f1 a0 a1 (fn a0) (fn a1))
\end{verbatim}
}
\noindent returns a recursion theorem {\small\verb%rth%} that can then be fed to
{\small\verb%prove_constructors_distinct%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_constructors_distinct rth;;
  val it : thm = |- !a a0' a1'. ~(LEAF a = NODE a0' a1')
\end{verbatim}
}
This states that leaf nodes are different from internal nodes.  When the
concrete type in question has more than two constructors, the resulting theorem
is just conjunction of inequalities of this kind.

\COMMENTS
An easier interface is {\small\verb%distinctness "tree"%}; this function is mainly intended
to generate that theorem internally.

\SEEALSO
define_type, distinctness, INDUCT_TAC, new_recursive_definition,
prove_cases_thm, prove_constructors_one_one, prove_induction_thm,
prove_rec_fn_exists.

\ENDDOC
\DOC{prove{\_}constructors{\_}injective}

\TYPE {\small\verb%prove_constructors_injective : thm -> thm%}\egroup

\SYNOPSIS
Proves that the constructors of an automatically-defined concrete type are
injective.

\DESCRIBE
{\small\verb%prove_constructors_one_one%} takes as its argument a primitive recursion
theorem, in the form returned by {\small\verb%define_type%} for an automatically-defined
concrete type.  When applied to such a theorem, {\small\verb%prove_constructors_one_one%}
automatically proves and returns a theorem which states that the constructors
of the concrete type in question are injective (one-to-one).  The resulting
theorem covers only those constructors that take arguments (i.e. that are not
just constant values).

\FAILURE
Fails if the argument is not a theorem of the form returned by {\small\verb%define_type%},
or if all the constructors of the concrete type in question are simply
constants of that type.

\EXAMPLE
The following type definition for labelled binary trees:
{\par\samepage\setseps\small
\begin{verbatim}
  # let ith,rth = define_type "tree = LEAF num | NODE tree tree";;
  val ith : thm =
    |- !P. (!a. P (LEAF a)) /\ (!a0 a1. P a0 /\ P a1 ==> P (NODE a0 a1))
           ==> (!x. P x)
  val rth : thm =
    |- !f0 f1.
           ?fn. (!a. fn (LEAF a) = f0 a) /\
                (!a0 a1. fn (NODE a0 a1) = f1 a0 a1 (fn a0) (fn a1))
\end{verbatim}
}
\noindent returns a recursion theorem {\small\verb%rth%} that can then be fed to
{\small\verb%prove_constructors_injective%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_constructors_injective rth;;
  val it : thm =
    |- (!a a'. LEAF a = LEAF a' <=> a = a') /\
       (!a0 a1 a0' a1'. NODE a0 a1 = NODE a0' a1' <=> a0 = a0' /\ a1 = a1')
\end{verbatim}
}
\noindent This states that the constructors {\small\verb%LEAF%} and {\small\verb%NODE%} are both
injective.

\COMMENTS
An easier interface is {\small\verb%injectivity "tree"%}; the present function is mainly
intended to generate that theorem internally.

\SEEALSO
define_type, INDUCT_THEN, injectivity, new_recursive_definition,
prove_cases_thm, prove_constructors_distinct, prove_induction_thm,
prove_rec_fn_exists.

\ENDDOC
\DOC{prove{\_}general{\_}recursive{\_}function{\_}exists}

\TYPE {\small\verb%prove_general_recursive_function_exists : term -> thm%}\egroup

\SYNOPSIS
Proves existence of general recursive function.

\DESCRIBE
The function {\small\verb%prove_general_recursive_function_exists%} should be applied
to an existentially quantified term {\small\verb%`?f. def_1[f] /\ ... /\ def_n[f]`%}, where
each clause {\small\verb%def_i%} is a universally quantified equation with an application of
{\small\verb%f%} to arguments on the left-hand side. The idea is that these clauses define
the action of {\small\verb%f%} on arguments of various kinds, for example on an empty list
and nonempty list:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (f [] = a) /\ (!h t. CONS h t = k[f,h,t])
\end{verbatim}
}
\noindent or on even numbers and odd numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (!n. f(2 * n) = a[f,n]) /\ (!n. f(2 * n + 1) = b[f,n])
\end{verbatim}
}
The returned value is a theorem whose conclusion matches the input term, with
zero, one or two assumptions, depending on what conditions had been proven
automatically. Roughly, one assumption states that the clauses are not mutually
contradictory, as in
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (!n. f(n + 1) = 1) /\ (!n. f(n + 2) = 2)
\end{verbatim}
}
\noindent and the other states that there is some wellfounded order making any
recursion admissible.

\FAILURE
Fails only if the definition is malformed. However it is possible that for an
inadmissible definition the assumptions of the theorem may not hold.

\EXAMPLE
In the definition of the Fibonacci numbers, the function successfully
eliminates all the hypotheses and just proves the claimed existence assertion:
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_general_recursive_function_exists
     `?fib. fib 0 = 1 /\ fib 1 = 1 /\
            !n. fib(n + 2) = fib(n) + fib(n + 1)`;;
  val it : thm =
    |- ?fib. fib 0 = 1 /\ fib 1 = 1 /\ (!n. fib (n + 2) = fib n + fib (n + 1))
\end{verbatim}
}
\noindent whereas in the following case, the function cannot automatically
discover the appropriate ordering to make the recursion admissible, so an
assumption is included:
{\par\samepage\setseps\small
\begin{verbatim}
  # let eth = prove_general_recursive_function_exists
     `?upto. !m n. upto m n =
                    if n < m then []
                    else if m = n then [n]
                    else  CONS m (upto (m + 1) n)`;;
  val eth : thm =
    ?(<<). WF (<<) /\ (!m n. (T /\ ~(n < m)) /\ ~(m = n) ==> m + 1,n << m,n)
    |- ?upto. !m n.
                  upto m n =
                  (if n < m
                   then []
                   else if m = n then [n] else CONS m (upto (m + 1) n))
\end{verbatim}
}
\noindent You can prove the condition by supplying an appropriate ordering, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # let wfth = prove(hd(hyp eth),
                       EXISTS_TAC `MEASURE (\(m:num,n:num). n - m)` THEN
                       REWRITE_TAC[WF_MEASURE; MEASURE] THEN ARITH_TAC);;
  val wfth : thm =
    |- ?(<<). WF (<<) /\ (!m n. (T /\ ~(n < m)) /\ ~(m = n) ==> m + 1,n << m,n)
\end{verbatim}
}
\noindent and so get the pure existence theorem with {\small\verb%PROVE_HYP wfth eth%}.

\USES
To prove existence of a recursive function defined by clauses without actually
defining it. In order to define it, use {\small\verb%define%}. To further forestall attempts
to prove conditions automatically, consider
{\small\verb%pure_prove_recursive_function_exists%} or even
{\small\verb%instantiate_casewise_recursion%}.

\SEEALSO
define, instantiate_casewise_recursion,
pure_prove_recursive_function_exists.

\ENDDOC
\DOC{PROVE{\_}HYP}

\TYPE {\small\verb%PROVE_HYP : thm -> thm -> thm%}\egroup

\SYNOPSIS
Eliminates a provable assumption from a theorem.

\DESCRIBE
When applied to two theorems, {\small\verb%PROVE_HYP%} gives a new theorem with the
conclusion of the second and the union of the assumption list minus the
conclusion of the first theorem.
{\par\samepage\setseps\small
\begin{verbatim}
     A1 |- t1     A2 |- t2
   -------------------------  PROVE_HYP
     A1 u (A2 - {t1}) |- t2
\end{verbatim}
}
If {\small\verb%t1%} does not occurr in {\small\verb%A2%} then the function simply returns the second
theorem {\small\verb%A2 |- t2%} unchanged without including the assumptions {\small\verb%A1%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th1 = CONJUNCT2(ASSUME `p /\ q /\ r`)
    and th2 = CONJUNCT2(ASSUME `q /\ r`);;
  val th1 : thm = p /\ q /\ r |- q /\ r
  val th2 : thm = q /\ r |- r

  # PROVE_HYP th1 th2;;
  val it : thm = p /\ q /\ r |- r
\end{verbatim}
}

\COMMENTS
This is sometimes known as the Cut rule. Although it is not necessary for the
conclusion of the first theorem to be the same as an assumption of the second,
{\small\verb%PROVE_HYP%} is otherwise of doubtful value.

\SEEALSO
DEDUCT_ANTISYM_RULE, DISCH, MP, UNDISCH.

\ENDDOC
\DOC{prove{\_}inductive{\_}relations{\_}exist}

\TYPE {\small\verb%prove_inductive_relations_exist : term -> thm%}\egroup

\SYNOPSIS
Prove existence of inductively defined relations without defining them.

\DESCRIBE
The function {\small\verb%prove_inductive_relations_exist%} should be given a specification
for an inductively defined relation {\small\verb%R%}, or more generally a family
{\small\verb%R1,...,Rn%} of mutually inductive relations; the required format is explained
further in the entry for {\small\verb%new_inductive_definition%}. It returns an existential
theorem {\small\verb%A |- ?R1 ... Rn. rules /\ induction /\ cases%}, where {\small\verb%rules%},
{\small\verb%induction%} and {\small\verb%cases%} are the rule, induction and cases theorems, explained
further in the entry for {\small\verb%new_inductive_definition%}. In contrast with
{\small\verb%new_inductive_definition%}, no actual definitions are made. The assumption list
{\small\verb%A%} is normally empty, but will include any monotonicity hypotheses that were
not proven automatically.

\FAILURE
Fails if the form of the rules is wrong.

\EXAMPLE
The traditional example of even and odd numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_inductive_relations_exist
     `even(0) /\ odd(1) /\
      (!n. even(n) ==> odd(n + 1)) /\
      (!n. odd(n) ==> even(n + 1))`;;
  val it : thm =
    |- ?even odd.
           (even 0 /\
            odd 1 /\
            (!n. even n ==> odd (n + 1)) /\
            (!n. odd n ==> even (n + 1))) /\
           (!odd' even'.
                even' 0 /\
                odd' 1 /\
                (!n. even' n ==> odd' (n + 1)) /\
                (!n. odd' n ==> even' (n + 1))
                ==> (!a0. odd a0 ==> odd' a0) /\ (!a1. even a1 ==> even' a1)) /\
           (!a0. odd a0 <=> a0 = 1 \/ (?n. a0 = n + 1 /\ even n)) /\
           (!a1. even a1 <=> a1 = 0 \/ (?n. a1 = n + 1 /\ odd n))
\end{verbatim}
}
\noindent Here is a example where we get a nonempty list of hypotheses because
HOL cannot prove monotonicity (and indeed, it doesn't hold).
{\par\samepage\setseps\small
\begin{verbatim}
  # prove_inductive_relations_exist `!x. ~P(x) ==> P(x+1)`;;
  val it : thm =
    !P P'.
        (!a. P a ==> P' a)
        ==> (!a. (?x. a = x + 1 /\ ~P x) ==> (?x. a = x + 1 /\ ~P' x))
    |- ?P. (!x. ~P x ==> P (x + 1)) /\
           (!P'. (!x. ~P' x ==> P' (x + 1)) ==> (!a. P a ==> P' a)) /\
           (!a. P a <=> (?x. a = x + 1 /\ ~P x))
\end{verbatim}
}

\USES
Using existence of inductive relations as an auxiliary device inside a proof.

\SEEALSO
derive_strong_induction, new_inductive_definition, prove_monotonicity_hyps.

\ENDDOC
\DOC{prove{\_}monotonicity{\_}hyps}

\TYPE {\small\verb%prove_monotonicity_hyps : thm -> thm%}\egroup

\SYNOPSIS
Attempt to prove monotonicity hypotheses of theorem automatically.

\DESCRIBE
Given a theorem {\small\verb%A |- t%}, the rule {\small\verb%prove_monotonicity_hyps%} attempts to prove
and remove all hypotheses that are not equations, by breaking them down and
repeatedly using {\small\verb%MONO_TAC%}. Any that are equations or are not automatically
provable will be left as they are.

\FAILURE
Never fails but may have no effect.

\COMMENTS
Normally, this kind of reasoning is automated by the inductive definitions
package, so explicit use of this tactic is rare.

\SEEALSO
MONO_TAC, monotonicity_theorems, new_inductive_definition,
prove_inductive_relations_exist.

\ENDDOC
\DOC{prove{\_}recursive{\_}functions{\_}exist}

\TYPE {\small\verb%prove_recursive_functions_exist : thm -> term -> thm%}\egroup

\SYNOPSIS
Prove existence of recursive function over inductive type.

\DESCRIBE
This function has essentially the same interface and functionality as
{\small\verb%new_recursive_definition%}, but it merely proves the existence of the function
rather than defining it.

The first argument to {\small\verb%prove_recursive_functions_exist%} is the primitive
recursion theorem for the concrete type in question; this is normally the
second theorem obtained from {\small\verb%define_type%}. The second argument is a term
giving the desired primitive recursive function definition. The value returned
by {\small\verb%prove_recursive_functions_exist%} is a theorem stating the existence of a
function satisfying the `definition' clauses. This theorem is derived by formal
proof from an instance of the general primitive recursion theorem given as the
second argument.

Let {\small\verb%C1%}, ..., {\small\verb%Cn%} be the constructors of this type, and let `{\small\verb%(Ci vs)%}'
represent a (curried) application of the {\small\verb%i%}th constructor to a sequence of
variables.  Then a curried primitive recursive function {\small\verb%fn%} over {\small\verb%ty%} can be
specified by a conjunction of (optionally universally-quantified) clauses of
the form:
{\par\samepage\setseps\small
\begin{verbatim}
   fn v1 ... (C1 vs1) ... vm  =  body1   /\
   fn v1 ... (C2 vs2) ... vm  =  body2   /\
                             .
                             .
   fn v1 ... (Cn vsn) ... vm  =  bodyn
\end{verbatim}
}
\noindent where the variables {\small\verb%v1%}, ..., {\small\verb%vm%}, {\small\verb%vs%} are distinct in each
clause, and where in the {\small\verb%i%}th clause {\small\verb%fn%} appears (free) in {\small\verb%bodyi%} only
as part of an application of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   `fn t1 ... v ... tm`
\end{verbatim}
}
\noindent in which the variable {\small\verb%v%} of type {\small\verb%ty%} also occurs among the
variables {\small\verb%vsi%}.

If {\small\verb%<definition>%} is a conjunction of clauses, as described above, then
evaluating:
{\par\samepage\setseps\small
\begin{verbatim}
   prove_recursive_functions_exist th `<definition>`;;
\end{verbatim}
}
\noindent automatically proves the existence of a function {\small\verb%fn%} that satisfies
the defining equations supplied, and returns a theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  |- ?fn. <definition>
\end{verbatim}
}
{\small\verb%prove_recursive_functions_exist%} also allows the supplied definition to omit
clauses for any number of constructors.  If a defining equation for the {\small\verb%i%}th
constructor is omitted, then the value of {\small\verb%fn%} at that constructor:
{\par\samepage\setseps\small
\begin{verbatim}
   fn v1 ... (Ci vsi) ... vn
\end{verbatim}
}
\noindent is left unspecified ({\small\verb%fn%}, however, is still a total function).

\FAILURE
Fails if the clauses cannot be matched up with the recursion theorem. You may
find that {\small\verb%prove_general_recursive_function_exists%} still works in such cases.

\EXAMPLE
Here we show that there exists a product function:
{\par\samepage\setseps\small
\begin{verbatim}
  prove_recursive_functions_exist num_RECURSION
   `(prod f 0 = 1) /\ (!n. prod f (SUC n) = f(SUC n) * prod f n)`;;
  val it : thm =
    |- ?prod. prod f 0 = 1 /\ (!n. prod f (SUC n) = f (SUC n) * prod f n)
\end{verbatim}
}

\COMMENTS
Often {\small\verb%prove_general_recursive_function_exists%} is an easier route to the same
goal. Its interface is simpler (no need to specify the recursion theorem) and
it is more powerful. However, for suitably constrained definitions
{\small\verb%prove_recursive_functions_exist%} works well and is much more efficient.

\USES
It is more usual to want to actually make definitions of recursive functions.
However, if a recursive function is needed in the middle of a proof, and seems
to ad-hoc for general use, you may just use {\small\verb%prove_recursive_functions_exist%},
perhaps adding the ``definition'' as an assumption of the goal with
{\small\verb%CHOOSE_TAC%}.

\SEEALSO
new_inductive_definition, new_recursive_definition,
prove_general_recursive_function_exists.

\ENDDOC
\DOC{PURE{\_}ASM{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%PURE_ASM_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem including the theorem's assumptions as rewrites.

\DESCRIBE
The list of theorems supplied by the user and the assumptions of the
object theorem are used to generate a set of rewrites, without adding
implicitly the basic tautologies stored under {\small\verb%basic_rewrites%}.
The rule searches for matching subterms in a top-down recursive
fashion, stopping only when no more rewrites apply. For a general
description of rewriting strategies see {\small\verb%GEN_REWRITE_RULE%}.

\FAILURE
Rewriting with {\small\verb%PURE_ASM_REWRITE_RULE%} does not result in failure. It
may diverge, in which case {\small\verb%PURE_ONCE_ASM_REWRITE_RULE%} may be used.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_REWRITE_RULE,
PURE_REWRITE_RULE, PURE_ONCE_ASM_REWRITE_RULE.

\ENDDOC
\DOC{PURE{\_}ASM{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%PURE_ASM_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal including the goal's assumptions as rewrites.

\DESCRIBE
{\small\verb%PURE_ASM_REWRITE_TAC%} generates a set of rewrites from the supplied
theorems and the assumptions of the goal, and applies these in a
top-down recursive manner until no match is found. See
{\small\verb%GEN_REWRITE_TAC%} for more information on the group of rewriting
tactics.

\FAILURE
{\small\verb%PURE_ASM_REWRITE_TAC%} does not fail, but it can diverge in certain
situations. For limited depth rewriting, see
{\small\verb%PURE_ONCE_ASM_REWRITE_TAC%}. It can also result in an invalid tactic.

\USES
To advance or solve a goal when the current assumptions are expected
to be useful in reducing the goal.

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, ONCE_REWRITE_TAC,
PURE_ONCE_ASM_REWRITE_TAC, PURE_ONCE_REWRITE_TAC, PURE_REWRITE_TAC,
REWRITE_TAC, SUBST_ALL_TAC, SUBST1_TAC.

\ENDDOC
\DOC{PURE{\_}ASM{\_}SIMP{\_}TAC}

\TYPE {\small\verb%PURE_ASM_SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Perform simplification of goal by conditional contextual rewriting using
assumptions.

\DESCRIBE
A call to {\small\verb%PURE_ASM_SIMP_TAC[theorems]%} will apply conditional contextual
rewriting with {\small\verb%theorems%} and the current assumptions of the goal to the goal's
conclusion, but not the default simplifications (see {\small\verb%basic_rewrites%} and
{\small\verb%basic_convs%}). For more details on this kind of rewriting, see {\small\verb%SIMP_CONV%}. If
the extra generality of contextual conditional rewriting is not needed,
{\small\verb%REWRITE_TAC%} is usually more efficient.

\FAILURE
Never fails, but may loop indefinitely.

\SEEALSO
ASM_REWRITE_TAC, ASM_SIMP_TAC, SIMP_CONV, SIMP_TAC, REWRITE_TAC.
\ENDDOC
\DOC{PURE{\_}ONCE{\_}ASM{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%PURE_ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem once, including the theorem's assumptions as rewrites.

\DESCRIBE
{\small\verb%PURE_ONCE_ASM_REWRITE_RULE%} excludes the basic tautologies in
{\small\verb%basic_rewrites%} from the theorems used for rewriting. It searches for
matching subterms once only, without recursing over already rewritten
subterms. For a general introduction to rewriting tools see
{\small\verb%GEN_REWRITE_RULE%}.

\FAILURE
{\small\verb%PURE_ONCE_ASM_REWRITE_RULE%} does not fail and does not diverge.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_ASM_REWRITE_RULE,
ONCE_REWRITE_RULE, PURE_ASM_REWRITE_RULE, PURE_REWRITE_RULE,
REWRITE_RULE.

\ENDDOC
\DOC{PURE{\_}ONCE{\_}ASM{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%PURE_ONCE_ASM_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal once, including the goal's assumptions as rewrites.

\DESCRIBE
A set of rewrites generated from the assumptions of the goal and the
supplied theorems is used to rewrite the term part of the goal, making
only one pass over the goal. The basic tautologies are not included as
rewrite theorems. The order in which the given theorems are applied is
an implementation matter and the user should not depend on any
ordering. See {\small\verb%GEN_REWRITE_TAC%} for more information on rewriting
tactics in general.

\FAILURE
{\small\verb%PURE_ONCE_ASM_REWRITE_TAC%} does not fail and does not diverge.

\USES
Manipulation of the goal by rewriting with its assumptions, in
instances where rewriting with tautologies and recursive rewriting is
undesirable.

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, ONCE_REWRITE_TAC,
PURE_ASM_REWRITE_TAC, PURE_ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC,
SUBST_ALL_TAC, SUBST1_TAC.

\ENDDOC
\DOC{PURE{\_}ONCE{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%PURE_ONCE_REWRITE_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Rewrites a term once with only the given list of rewrites.

\DESCRIBE
{\small\verb%PURE_ONCE_REWRITE_CONV%} generates rewrites from the list of theorems
supplied by the user, without including the tautologies given in
{\small\verb%basic_rewrites%}. The applicable rewrites are employed once, without
entailing in a recursive search for matches over the term.
See {\small\verb%GEN_REWRITE_CONV%} for more details about rewriting strategies in
HOL.

\FAILURE
This rule does not fail, and it does not diverge.

\SEEALSO
GEN_REWRITE_CONV, ONCE_DEPTH_CONV,
ONCE_REWRITE_CONV, PURE_REWRITE_CONV, REWRITE_CONV.

\ENDDOC
\DOC{PURE{\_}ONCE{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%PURE_ONCE_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem once with only the given list of rewrites.

\DESCRIBE
{\small\verb%PURE_ONCE_REWRITE_RULE%} generates rewrites from the list of theorems
supplied by the user, without including the tautologies given in
{\small\verb%basic_rewrites%}. The applicable rewrites are employed once, without
entailing in a recursive search for matches over the theorem.
See {\small\verb%GEN_REWRITE_RULE%} for more details about rewriting strategies in
HOL.

\FAILURE
This rule does not fail, and it does not diverge.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_DEPTH_CONV,
ONCE_REWRITE_RULE, PURE_REWRITE_RULE, REWRITE_RULE.

\ENDDOC
\DOC{PURE{\_}ONCE{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%PURE_ONCE_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal using a supplied list of theorems, making one
rewriting pass over the goal.

\DESCRIBE
{\small\verb%PURE_ONCE_REWRITE_TAC%} generates a set of rewrites from the given
list of theorems, and applies them at every match found through
searching once over the term part of the goal, without recursing. It
does not include the basic tautologies as rewrite theorems. The order
in which the rewrites are applied is unspecified. For more information
on rewriting tactics see {\small\verb%GEN_REWRITE_TAC%}.

\FAILURE
{\small\verb%PURE_ONCE_REWRITE_TAC%} does not fail and does not diverge.

\USES
This tactic is useful when the built-in tautologies are not required
as rewrite equations and recursive rewriting is not desired.

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, ONCE_REWRITE_TAC,
PURE_ASM_REWRITE_TAC, PURE_ONCE_ASM_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC,
SUBST_ALL_TAC, SUBST1_TAC.

\ENDDOC
\DOC{pure{\_}prove{\_}recursive{\_}function{\_}exists}

\TYPE {\small\verb%pure_prove_recursive_function_exists : term -> thm%}\egroup

\SYNOPSIS
Proves existence of general recursive function but leaves unproven assumptions.

\DESCRIBE
The function {\small\verb%pure_prove_recursive_function_exists%} should be applied
to an existentially quantified term {\small\verb%`?f. def_1[f] /\ ... /\ def_n[f]`%}, where
each clause {\small\verb%def_i%} is a universally quantified equation with an application of
{\small\verb%f%} to arguments on the left-hand side. The idea is that these clauses define
the action of {\small\verb%f%} on arguments of various kinds, for example on an empty list
and nonempty list:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (f [] = a) /\ (!h t. CONS h t = k[f,h,t])
\end{verbatim}
}
\noindent or on even numbers and odd numbers:
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (!n. f(2 * n) = a[f,n]) /\ (!n. f(2 * n + 1) = b[f,n])
\end{verbatim}
}
The returned value is a theorem whose conclusion matches the input term, with
in general one or two assumptions stating what properties must hold so that the
existence of such a function to be deduced. Roughly, one assumption states that
the clauses are not mutually contradictory, as in
{\par\samepage\setseps\small
\begin{verbatim}
  ?f. (!n. f(n + 1) = 1) /\ (!n. f(n + 2) = 2)
\end{verbatim}
}
\noindent and the other states that there is some wellfounded order making any
recursion admissible. This rule attempts to eliminate any hypotheses of the
first kind, but does not attempt to guess a wellfounded ordering as
{\small\verb%prove_general_recursive_function_exists%} does.

\FAILURE
Fails only if the definition is malformed. However it is possible that for an
inadmissible definition the assumptions of the theorem may not hold.

\EXAMPLE
In the definition of the Fibonacci numbers, the function successfully
eliminates the mutual consistency hypotheses:
{\par\samepage\setseps\small
\begin{verbatim}
  # pure_prove_recursive_function_exists
     `?fib. fib 0 = 1 /\ fib 1 = 1 /\
            !n. fib(n + 2) = fib(n) + fib(n + 1)`;;
  val it : thm =
    ?(<<). WF (<<) /\ (!n. T ==> n << n + 2) /\ (!n. T ==> n + 1 << n + 2)
    |- ?fib. fib 0 = 1 /\ fib 1 = 1 /\ (!n. fib (n + 2) = fib n + fib (n + 1))
\end{verbatim}
}
\noindent but leaves a wellfounded ordering to be given. (By contrast,
{\small\verb%prove_general_recursive_function_exists%} will automatically eliminate it.)

\USES
Normally, use {\small\verb%prove_general_recursive_function_exists%} for this operation. Use
the present function only when the attempt by
{\small\verb%prove_general_recursive_function_exists%} to discharge the proof obligations is
not successful and merely wastes time.

\SEEALSO
define, instantiate_casewise_recursion,
prove_general_recursive_function_exists.

\ENDDOC
\DOC{PURE{\_}REWRITE{\_}CONV}

\TYPE {\small\verb%PURE_REWRITE_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Rewrites a term with only the given list of rewrites.

\DESCRIBE
This conversion provides a method for rewriting a term with the theorems given,
and excluding simplification with tautologies in {\small\verb%basic_rewrites%}. Matching
subterms are found recursively, until no more matches are found.
For more details on rewriting see
{\small\verb%GEN_REWRITE_CONV%}.

\USES
{\small\verb%PURE_REWRITE_CONV%} is useful when the simplifications that arise by
rewriting a theorem with {\small\verb%basic_rewrites%} are not wanted.

\FAILURE
Does not fail. May result in divergence, in which case
{\small\verb%PURE_ONCE_REWRITE_CONV%} can be used.

\SEEALSO
GEN_REWRITE_CONV, ONCE_REWRITE_CONV, PURE_ONCE_REWRITE_CONV, REWRITE_CONV.

\ENDDOC
\DOC{PURE{\_}REWRITE{\_}RULE}

\TYPE {\small\verb%PURE_REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem with only the given list of rewrites.

\DESCRIBE
This rule provides a method for rewriting a theorem with the theorems given,
and excluding simplification with tautologies in {\small\verb%basic_rewrites%}. Matching
subterms are found recursively starting from the term in the conclusion part of
the theorem, until no more matches are found. For more details on rewriting see
{\small\verb%GEN_REWRITE_RULE%}.

\USES
{\small\verb%PURE_REWRITE_RULE%} is useful when the simplifications that arise by
rewriting a theorem with {\small\verb%basic_rewrites%} are not wanted.

\FAILURE
Does not fail. May result in divergence, in which case
{\small\verb%PURE_ONCE_REWRITE_RULE%} can be used.

\SEEALSO
ASM_REWRITE_RULE, GEN_REWRITE_RULE, ONCE_REWRITE_RULE,
PURE_ASM_REWRITE_RULE, PURE_ONCE_ASM_REWRITE_RULE,
PURE_ONCE_REWRITE_RULE, REWRITE_RULE.

\ENDDOC
\DOC{PURE{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%PURE_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal with only the given list of rewrites.

\DESCRIBE
{\small\verb%PURE_REWRITE_TAC%} behaves in the same way as {\small\verb%REWRITE_TAC%}, but
without the effects of the built-in tautologies.  The order in which
the given theorems are applied is an implementation matter and the user
should not depend on any ordering. For more information on rewriting
strategies see {\small\verb%GEN_REWRITE_TAC%}.

\FAILURE
{\small\verb%PURE_REWRITE_TAC%} does not fail, but it can diverge in certain
situations; in such cases {\small\verb%PURE_ONCE_REWRITE_TAC%} may be used.

\USES
This tactic is useful when the built-in tautologies are not required as
rewrite equations. It is sometimes useful in making more time-efficient
replacements according to equations for which it is clear that no extra
reduction via tautology will be needed. (The difference in efficiency
is only apparent, however, in quite large examples.)

{\small\verb%PURE_REWRITE_TAC%} advances goals but solves them less frequently than
{\small\verb%REWRITE_TAC%}; to be precise, {\small\verb%PURE_REWRITE_TAC%} only solves goals
which are rewritten to {\small\verb%`T`%} (i.e. {\small\verb%TRUTH%}) without recourse to any
other tautologies.

\EXAMPLE
It might be necessary, say for subsequent application of an induction
hypothesis, to resist reducing a term {\small\verb%`b = T`%} to {\small\verb%`b`%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `b <=> T`;;
  Warning: Free variables in goal: b
  val it : goalstack = 1 subgoal (1 total)

  `b <=> T`

  # e(PURE_REWRITE_TAC[]);;
  val it : goalstack = 1 subgoal (1 total)

  `b <=> T`

  # e(REWRITE_TAC[]);;
  val it : goalstack = 1 subgoal (1 total)

  `b`
\end{verbatim}
}

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_TAC, ONCE_ASM_REWRITE_TAC, ONCE_REWRITE_TAC,
PURE_ASM_REWRITE_TAC, PURE_ONCE_ASM_REWRITE_TAC, PURE_ONCE_REWRITE_TAC,
REWRITE_TAC, SUBST_ALL_TAC, SUBST1_TAC.

\ENDDOC
\DOC{PURE{\_}SIMP{\_}CONV}

\TYPE {\small\verb%PURE_SIMP_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Simplify a term repeatedly by conditional contextual rewriting, not using
default simplifications.

\DESCRIBE
A call {\small\verb%SIMP_CONV thl tm%} will return {\small\verb%|- tm = tm'%} where {\small\verb%tm'%} results from
applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules. This is similar
to {\small\verb%SIMP_CONV%}, and the documentation for that contains more details. The
{\small\verb%PURE%} prefix means that the usual built-in simplifications (see
{\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}) are not applied.

\FAILURE
Never fails, but may return a reflexive theorem {\small\verb%|- tm = tm%} if no
simplifications can be made.

\SEEALSO
PURE_REWRITE_CONV, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{PURE{\_}SIMP{\_}RULE}

\TYPE {\small\verb%PURE_SIMP_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Simplify conclusion of a theorem repeatedly by conditional contextual
rewriting, not using default simplifications.

\DESCRIBE
A call {\small\verb%SIMP_CONV thl (|- tm)%} will return {\small\verb%|- tm'%} where {\small\verb%tm'%} results from
applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules. Howver, the
{\small\verb%PURE%} prefix indicates that it will not automatically include the usual
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more
details on this kind of conditional rewriting, see {\small\verb%SIMP_CONV%}.

\FAILURE
Never fails, but may return the input theorem unchanged if no simplifications
were applicable.

\SEEALSO
ONCE_SIMP_RULE, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{PURE{\_}SIMP{\_}TAC}

\TYPE {\small\verb%PURE_SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Simplify a goal repeatedly by conditional contextual rewriting without default
simplifications.

\DESCRIBE
When applied to a goal {\small\verb%A ?- g%}, the tactic {\small\verb%PURE_SIMP_TAC thl%} returns a new
goal {\small\verb%A ?- g'%} where {\small\verb%g'%} results from applying the theorems in {\small\verb%thl%} as
(conditional) rewrite rules. The {\small\verb%PURE%} prefix means that it does not apply the
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more
details, see {\small\verb%SIMP_CONV%}.

\FAILURE
Never fails, though may not change the goal if no simplifications are
applicable.

\COMMENTS
To add the assumptions of the goal to the rewrites, use {\small\verb%PURE_ASM_SIMP_TAC%} (or
just {\small\verb%ASM PURE_SIMP_TAC%}).

\SEEALSO
ASM, ASM_SIMP_TAC, mk_rewrites, ONCE_SIMP_CONV, REWRITE_TAC, SIMP_CONV,
SIMP_RULE.

\ENDDOC
\DOC{qmap}

\TYPE {\small\verb%qmap : ('a -> 'a) -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Maps a function of type {\small\verb%'a -> 'a%} over a list, optimizing the unchanged case.

\DESCRIBE
The call {\small\verb%qmap f [x1;...;xn]%} returns the list {\small\verb%[f(x1);...;f(xn)]%}. In this
respect it behaves like {\small\verb%map%}. However with {\small\verb%qmap%}, the function {\small\verb%f%} must have
the same domain and codomain type, and in cases where the function returns the
argument unchanged (actually pointer-equal, tested by `{\small\verb%==%}'), the
implementation often avoids rebuilding an equal copy of the list, so can be
much more efficient.

\FAILURE
Fails if one of the embedded evaluations of {\small\verb%f%} fails, but not otherwise.

\EXAMPLE
Let us map the identity function over a million numbers:
{\par\samepage\setseps\small
\begin{verbatim}
# let million = 1--1000000;;
val million : int list =
  [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21;
   ...]
\end{verbatim}
}
First we use ordinary {\small\verb%map%}; the computation takes some time because the list
is traversed and reconstructed, giving a fresh copy:
{\par\samepage\setseps\small
\begin{verbatim}
  # time (map I) million == million;;
  CPU time (user): 2.95
  val it : bool = false
\end{verbatim}
}
But {\small\verb%qmap%} is markedly faster, uses no extra heap memory, and the result is
pointer-equal to the input:
{\par\samepage\setseps\small
\begin{verbatim}
  # time (qmap I) million == million;;
  CPU time (user): 0.13
  val it : bool = true
\end{verbatim}
}

\USES
Many logical operations, such as substitution, may in common cases return their
arguments unchanged. In this case it is very useful to optimize the traversal
in this way. Several internal logical manipulations like {\small\verb%vsubst%} use this
technique.

\SEEALSO
map.

\ENDDOC
\DOC{quotexpander}

\TYPE {\small\verb%quotexpander : string -> string%}\egroup

\SYNOPSIS
Quotation expander.

\DESCRIBE
This function determines how anything in {\small\verb%`backquotes`%} is expanded on input.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # quotexpander "1 + 1";;
  val it : string = "parse_term \"1 + 1\""
  # quotexpander ":num";;
  val it : string = "parse_type \"num\""
\end{verbatim}
}

\COMMENTS
Not intended for general use, but automatically invoked when anything is typed
in backquotes {\small\verb%`like this`%}. May be of some interest for users wishing to
change the behavior of the quotation parser.

\ENDDOC
\DOC{r}

\TYPE {\small\verb%r : int -> goalstack%}\egroup

\SYNOPSIS
Reorders the subgoals on top of the subgoal package goal stack.

\DESCRIBE
The function {\small\verb%r%} is part of the subgoal package. It `rotates' the current list
of goals by the given number, which may be positive or negative. For a
description of the subgoal package, see {\small\verb%set_goal%}.

\FAILURE
If there are no goals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3]) /\ (HD (TL[1;2;3]) = 2)`;;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3] /\ HD (TL [1; 2; 3]) = 2`

  # e (REPEAT CONJ_TAC);;
  val it : goalstack = 3 subgoals (3 total)

  `HD (TL [1; 2; 3]) = 2`

  `TL [1; 2; 3] = [2; 3]`

  `HD [1; 2; 3] = 1`

  # r 1;;
  val it : goalstack = 1 subgoal (3 total)

  `TL [1; 2; 3] = [2; 3]`

  # r 1;;
  val it : goalstack = 1 subgoal (3 total)

  `HD (TL [1; 2; 3]) = 2`
\end{verbatim}
}

\USES
Proving subgoals in a different order from that generated by the subgoal
package.

\SEEALSO
b, e, er, g, p, set_goal, top_thm.

\ENDDOC
\DOC{ran}

\TYPE {\small\verb%ran : ('a, 'b) func -> 'b list%}\egroup

This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The {\small\verb%ran%} operation returns the range of such a function, i.e. the set of
result values for the points on which it is defined.

\FAILURE
Attempts to {\small\verb%setify%} the resulting list, so may fail if the range type does not
admit comparisons.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ran (1 |=> "1");;
  val it : string list = ["1"]
  # ran(itlist I [2|->4; 3|->6] undefined);;
  val it : int list = [4; 6]
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine, undefined.

\ENDDOC
\DOC{rand}

\TYPE {\small\verb%rand : term -> term%}\egroup

\SYNOPSIS
Returns the operand from a combination (function application).

\DESCRIBE
{\small\verb%rand `t1 t2`%} returns {\small\verb%`t2`%}.

\FAILURE
Fails with {\small\verb%rand%} if term is not a combination.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rand `SUC 0`;;
  val it : term = `0`
  # rand `x + y`;;
  val it : term = `y`
\end{verbatim}
}

\SEEALSO
rator, lhand, dest_comb.

\ENDDOC
\DOC{RAND{\_}CONV}

\TYPE {\small\verb%RAND_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the operand of an application.

\DESCRIBE
If {\small\verb%c%} is a conversion that maps a term {\small\verb%`t2`%} to the theorem {\small\verb%|- t2 = t2'%},
then the conversion {\small\verb%RAND_CONV c%} maps applications of the form {\small\verb%`t1 t2`%} to
theorems of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (t1 t2) = (t1 t2')
\end{verbatim}
}
\noindent That is, {\small\verb%RAND_CONV c `t1 t2`%} applies {\small\verb%c%} to the operand of the
application {\small\verb%`t1 t2`%}.

\FAILURE
{\small\verb%RAND_CONV c tm%} fails if {\small\verb%tm%} is not an application or if {\small\verb%tm%} has the form
{\small\verb%`t1 t2`%} but the conversion {\small\verb%c%} fails when applied to the term {\small\verb%t2%}. The
function returned by {\small\verb%RAND_CONV c%} may also fail if the ML function {\small\verb%c%} is not,
in fact, a conversion (i.e. a function that maps a term {\small\verb%t%} to a theorem
{\small\verb%|- t = t'%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # RAND_CONV num_CONV `SUC 2`;;
  val it : thm = |- SUC 2 = SUC (SUC 1)
\end{verbatim}
}

\SEEALSO
ABS_CONV, COMB_CONV, COMB_CONV2, LAND_CONV, RATOR_CONV, SUB_CONV.

\ENDDOC
\DOC{rator}

\TYPE {\small\verb%rator : term -> term%}\egroup

\SYNOPSIS
Returns the operator from a combination (function application).

\DESCRIBE
{\small\verb%rator(`t1 t2`)%} returns {\small\verb%`t1`%}.

\FAILURE
Fails with {\small\verb%rator%} if term is not a combination.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rator `f(x)`;;
  Warning: inventing type variables
  val it : term = `f`

  # rator `~p`;;
  val it : term = `(~)`

  # rator `x + y`;;
  val it : term = `(+) x`
\end{verbatim}
}

\SEEALSO
dest_comb, lhand, lhs, rand.

\ENDDOC
\DOC{RATOR{\_}CONV}

\TYPE {\small\verb%RATOR_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the operator of an application.

\DESCRIBE
If {\small\verb%c%} is a conversion that maps a term {\small\verb%`t1`%} to the theorem {\small\verb%|- t1 = t1'%},
then the conversion {\small\verb%RATOR_CONV c%} maps applications of the form {\small\verb%`t1 t2`%} to
theorems of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (t1 t2) = (t1' t2)
\end{verbatim}
}
\noindent That is, {\small\verb%RATOR_CONV c `t1 t2`%} applies {\small\verb%c%} to the operator of the
application {\small\verb%`t1 t2`%}.

\FAILURE
{\small\verb%RATOR_CONV c tm%} fails if {\small\verb%tm%} is not an application or if {\small\verb%tm%} has the form
{\small\verb%`t1 t2`%} but the conversion {\small\verb%c%} fails when applied to the term {\small\verb%t1%}. The
function returned by {\small\verb%RATOR_CONV c%} may also fail if the ML function
{\small\verb%c:term->thm%} is not, in fact, a conversion (i.e. a function that maps a term
{\small\verb%t%} to a theorem {\small\verb%|- t = t'%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # RATOR_CONV BETA_CONV `(\x y. x + y) 1 2`;;
  val it : thm = |- (\x y. x + y) 1 2 = (\y. 1 + y) 2
\end{verbatim}
}

\SEEALSO
ABS_CONV, COMB_CONV, COMB2_CONV, RAND_CONV, SUB_CONV.

\ENDDOC
\DOC{rat{\_}of{\_}term}

\TYPE {\small\verb%rat_of_term : term -> num%}\egroup

\SYNOPSIS
Converts a canonical rational literal of type {\small\verb%:real%} to an OCaml number.

\DESCRIBE
The call {\small\verb%rat_of_term t%} where term {\small\verb%t%} is a canonical rational literal of type
{\small\verb%:real%} returns the corresponding OCaml rational number (type {\small\verb%num%}). The
canonical literals are integer literals {\small\verb%&n%} for numeral {\small\verb%n%}, {\small\verb%-- &n%} for a
nonzero numeral {\small\verb%n%}, or ratios {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} where {\small\verb%p%} is nonzero,
{\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} share no common factor.

\FAILURE
Fails when applied to a term that is not a canonical rational literal.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rat_of_term `-- &22 / &7`;;
  val it : num = -22/7
\end{verbatim}
}

\SEEALSO
is_ratconst, mk_realintconst, REAL_RAT_REDUCE_CONV, term_of_rat.

\ENDDOC
\DOC{REAL{\_}ARITH}

\TYPE {\small\verb%REAL_ARITH : term -> thm%}\egroup

\SYNOPSIS
Attempt to prove term using basic algebra and linear arithmetic over the reals.

\DESCRIBE
{\small\verb%REAL_ARITH%} is the basic tool for proving elementary lemmas about real
equations and inequalities. Given a term, it first applies various
normalizations, eliminating constructs such as {\small\verb%max%}, {\small\verb%min%} and {\small\verb%abs%} by
introducing case splits, splitting over the arms of conditionals and putting
any equations and inequalities into a form {\small\verb%p(x) <><> 0%} where {\small\verb%<><>%} is an
equality or inequality function and {\small\verb%p(x)%} is in a normal form for polynomials
as produced by {\small\verb%REAL_POLY_CONV%}. The problem is split into the refutation of
various conjunctions of such subformulas. A refutation of each is attempted
using simple linear inequality reasoning (essentially Fourier-Motzkin
elimination). Note that no non-trivial nonlinear inequality reasoning is
performed (see below).

\FAILURE
Fails if the term is not provable using the algorithm sketched above.

\EXAMPLE
Here is some simple inequality reasoning, showing how constructs like {\small\verb%abs%},
{\small\verb%max%} and {\small\verb%min%} can be handled:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_ARITH
      `abs(x) < min e d / &2 /\ abs(y) < min e d / &2 ==> abs(x + y) < d + e`;;
  val it : thm =
    |- abs x < min e d / &2 /\ abs y < min e d / &2 ==> abs (x + y) < d + e
\end{verbatim}
}
The following example also involves inequality reasoning, but the initial
algebraic normalization is critical to make the pieces match up:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_ARITH `(&1 + x) * (&1 - x) * (&1 + x pow 2) < &1 ==> &0 < x pow 4`;;
  val it : thm = |- (&1 + x) * (&1 - x) * (&1 + x pow 2) < &1 ==> &0 < x pow 4
\end{verbatim}
}

\USES
Very convenient for providing elementary lemmas that would otherwise be painful
to prove manually.

\COMMENTS
For nonlinear equational reasoning, use {\small\verb%REAL_RING%} or {\small\verb%REAL_FIELD%}. For
nonlinear inequality reasoning, there are no powerful rules built into HOL
Light, but the additional derived rules defined in {\small\verb%Examples/sos.ml%} and
{\small\verb%Rqe/make.ml%} may be useful.

\SEEALSO
ARITH_TAC, INT_ARITH_TAC, REAL_ARITH_TAC, REAL_FIELD, REAL_RING.

\ENDDOC
\DOC{REAL{\_}ARITH{\_}TAC}

\TYPE {\small\verb%REAL_ARITH_TAC : tactic%}\egroup

\SYNOPSIS
Attempt to prove goal using basic algebra and linear arithmetic over the reals.

\DESCRIBE
The tactic {\small\verb%REAL_ARITH_TAC%} is the tactic form of {\small\verb%REAL_ARITH%}. Roughly
speaking, it will automatically prove any formulas over the reals that are
effectively universally quantified and can be proved valid by algebraic
normalization and linear equational and inequality reasoning. See {\small\verb%REAL_ARITH%}
for more information about the algorithm used and its scope.

\FAILURE
Fails if the goal is not in the subset solvable by these means, or is not
valid.

\EXAMPLE
Here is a goal that holds by virtue of pure algebraic normalization:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(x1 pow 2 + x2 pow 2 + x3 pow 2 + x4 pow 2) pow 2 =
       ((x1 + x2) pow 4 + (x1 + x3) pow 4 + (x1 + x4) pow 4 +
        (x2 + x3) pow 4 + (x2 + x4) pow 4 + (x3 + x4) pow 4 +
        (x1 - x2) pow 4 + (x1 - x3) pow 4 + (x1 - x4) pow 4 +
        (x2 - x3) pow 4 + (x2 - x4) pow 4 + (x3 - x4) pow 4) / &6`;;
\end{verbatim}
}
\noindent and here is one that holds by linear inequality reasoning:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `&26 < x / &2 ==> abs(x / &4 + &1) < abs(x / &3)`;;
\end{verbatim}
}
\noindent so either goal is solved simply by:
{\par\samepage\setseps\small
\begin{verbatim}
  # e REAL_ARITH_TAC;;
  val it : goalstack = No subgoals
\end{verbatim}
}

\COMMENTS
For nonlinear equational reasoning, use {\small\verb%CONV_TAC REAL_RING%} or {\small\verb%CONV_TAC
REAL_FIELD%}. For nonlinear inequality reasoning, there are no powerful rules
built into HOL Light, but the additional derived rules defined in
{\small\verb%Examples/sos.ml%} and {\small\verb%Rqe/make.ml%} may be useful.

\SEEALSO
ARITH_TAC, ASM_REAL_ARITH_TAC, INT_ARITH_TAC, REAL_ARITH, REAL_FIELD, REAL_RING.

\ENDDOC
\DOC{REAL{\_}FIELD}

\TYPE {\small\verb%REAL_FIELD : term -> thm%}\egroup

\SYNOPSIS
Prove basic `field' facts over the reals.

\DESCRIBE
Most of the built-in HOL arithmetic decision procedures have limited ability to
deal with inversion or division. {\small\verb%REAL_FIELD%} is an enhancement of {\small\verb%REAL_RING%}
that has the same underlying method but first performs various case-splits,
reducing a goal involving the inverse {\small\verb%inv(t)%} of a term {\small\verb%t%} to the cases where
{\small\verb%t = 0%} where {\small\verb%t * inv(t) = &1%}, repeatedly for all such {\small\verb%t%}. After
subsequently splitting the goal into normal form, {\small\verb%REAL_RING%} (for algebraic
reasoning) is applied; if this fails then {\small\verb%REAL_ARITH%} is also tried, since
this allows some {\small\verb%t = 0%} cases to be excluded by simple linear reasoning.

\FAILURE
Fails if the term is not provable using the methods described.

\EXAMPLE
Here we do some simple algebraic simplification, ruling out the degenerate
{\small\verb%x = &0%} case using the inequality in the antecedent.
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_FIELD `!x. &0 < x ==> &1 / x - &1 / (x + &1) = &1 / (x * (x + &1))`;;
  ...
  val it : thm = |- !x. &0 < x ==> &1 / x - &1 / (x + &1) = &1 / (x * (x + &1))
\end{verbatim}
}

\COMMENTS
Except for the discharge of conditions using linear reasoning, this rule is
essentially equational. For nonlinear inequality reasoning, there are no
powerful rules built into HOL Light, but the additional derived rules defined
in {\small\verb%Examples/sos.ml%} and {\small\verb%Rqe/make.ml%} may be useful.

\SEEALSO
ARITH_TAC, INT_ARITH_TAC, REAL_ARITH, REAL_ARITH_TAC, REAL_RING.

\ENDDOC
\DOC{real{\_}ideal{\_}cofactors}

\TYPE {\small\verb%real_ideal_cofactors : term list -> term -> term list%}\egroup

\SYNOPSIS
Produces cofactors proving that one real polynomial is in the ideal generated
by others.

\DESCRIBE
The call {\small\verb%real_ideal_cofactors [`p1`; ...; `pn`] `p`%}, where all the terms have
type {\small\verb%:real%} and can be considered as polynomials, will test whether {\small\verb%p%} is in
the ideal generated by the {\small\verb%p1,...,pn%}. If so, it will return a corresponding
list {\small\verb%[`q1`; ...; `qn`]%} of `cofactors' such that the following is an
algebraic identity (provable by {\small\verb%REAL_RING%} or a slight elaboration of
{\small\verb%REAL_POLY_CONV%}, for example):
{\par\samepage\setseps\small
\begin{verbatim}
  p = p1 * q1 + ... + pn * qn
\end{verbatim}
}
\noindent hence providing an explicit certificate for the ideal membership. If
ideal membership does not hold, {\small\verb%real_ideal_cofactors%} fails. The test is
performed using a Gr\"obner basis procedure.

\FAILURE
Fails if the terms are ill-typed, or if ideal membership fails.

\EXAMPLE
Here is a fairly simple example:
{\par\samepage\setseps\small
\begin{verbatim}
 # prioritize_real();;
 val it : unit = ()

 # real_ideal_cofactors
   [`y1 * y3 + x1 * x3`;
    `y3 * (y2 - y3) + (x2 - x3) * x3`]
   `x3 * y3 * (y1 * (x2 - x3) - x1 * (y2 - y3))`;;
 ...
val it : term list = [`&1 * y3 pow 2 + -- &1 * y2 * y3`; `&1 * y1 * y3`]
\end{verbatim}
}
\noindent and we can confirm the identity as follows (note that
{\small\verb%REAL_IDEAL_CONV%} already does this directly):
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING `(&1 * y3 pow 2 + -- &1 * y2 * y3) * (y1 * y3 + x1 * x3) +
               (&1 * y1 * y3) * (y3 * (y2 - y3) + (x2 - x3) * x3) =
               x3 * y3 * (y1 * (x2 - x3) - x1 * (y2 - y3))`;;
\end{verbatim}
}

\COMMENTS
When we say that terms can be `considered as polynomials', we mean that initial
normalization, essentially in the style of {\small\verb%REAL_POLY_CONV%}, will be applied,
but some complex constructs such as conditional expressions will be treated as
atomic.

\SEEALSO
ideal_cofactors, int_ideal_cofactors, REAL_IDEAL_CONV, REAL_RING, RING,
RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{REAL{\_}IDEAL{\_}CONV}

\TYPE {\small\verb%REAL_IDEAL_CONV : term list -> term -> thm%}\egroup

\SYNOPSIS
Produces identity proving ideal membership over the reals.

\DESCRIBE
The call {\small\verb%REAL_IDEAL_CONV [`p1`; ...; `pn`] `p`%}, where all the terms have
type {\small\verb%:real%} and can be considered as polynomials, will test whether {\small\verb%p%} is in
the ideal generated by the {\small\verb%p1,...,pn%}. If so, it will return a corresponding
theorem {\small\verb%|- p = q1 * p1 + ... + qn * pn%} showing how to express {\small\verb%p%} in terms of
the other polynomials via some `cofactors' {\small\verb%qi%}.

\FAILURE
Fails if the terms are ill-typed, or if ideal membership fails.

\EXAMPLE
In the case of a singleton list, this just corresponds to dividing one
multivariate polynomial by another, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_IDEAL_CONV [`x - &1`] `x pow 4 - &1`;;
  1 basis elements and 0 critical pairs
  val it : thm =
    |- x pow 4 - &1 = (&1 * x pow 3 + &1 * x pow 2 + &1 * x + &1) * (x - &1)
\end{verbatim}
}

\SEEALSO
ideal_cofactors, real_ideal_cofactors, REAL_RING, RING, RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}ABS{\_}CONV}

\TYPE {\small\verb%REAL_INT_ABS_CONV : conv%}\egroup

\SYNOPSIS
Conversion to produce absolute value of an integer literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_ABS_CONV `abs c`%}, where {\small\verb%c%} is an integer literal of type
{\small\verb%:real%}, returns the theorem {\small\verb%|- abs c = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c%}'s absolute value. The literal {\small\verb%c%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of integer literal of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_ABS_CONV `abs(-- &42)`;;
  val it : thm = |- abs (-- &42) = &42
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_ABS_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_ABS_CONV, REAL_RAT_ABS_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}ADD{\_}CONV}

\TYPE {\small\verb%REAL_INT_ADD_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two integer literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_ADD_CONV `c1 + c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:real%}, returns {\small\verb%|- c1 + c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 + c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the sum of two permitted integer
literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_ADD_CONV `-- &17 + &25`;;
  val it : thm = |- -- &17 + &25 = &8
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_ADD_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_ADD_CONV, REAL_RAT_ADD_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}EQ{\_}CONV}

\TYPE {\small\verb%REAL_INT_EQ_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:real%} is equal to
another.

\DESCRIBE
The call {\small\verb%REAL_INT_EQ_CONV `c1 < c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 = c2 <=> T%} or
{\small\verb%|- c1 = c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not an equality comparison on two permitted
integer literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_EQ_CONV `&1 = &2`;;
  val it : thm = |- &1 = &2 <=> F

  # REAL_INT_EQ_CONV `-- &1 = -- &1`;;
  val it : thm = |- -- &1 = -- &1 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_EQ_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_EQ_CONV, REAL_RAT_EQ_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}GE{\_}CONV}

\TYPE {\small\verb%REAL_INT_GE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:real%} is {\small\verb%>=%}
another.

\DESCRIBE
The call {\small\verb%REAL_INT_GE_CONV `c1 >= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 >= c2 <=> T%} or
{\small\verb%|- c1 >= c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_GE_CONV `&7 >= &6`;;
  val it : thm = |- &7 >= &6 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_GE_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_GE_CONV, REAL_RAT_GE_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}GT{\_}CONV}

\TYPE {\small\verb%REAL_INT_GT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:real%} is {\small\verb%<%}
another.

\DESCRIBE
The call {\small\verb%REAL_INT_GT_CONV `c1 > c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 > c2 <=> T%} or
{\small\verb%|- c1 > c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_GT_CONV `&1 > &2`;;
  val it : thm = |- &1 > &2 <=> F
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_GT_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_GT_CONV, REAL_RAT_GT_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}LE{\_}CONV}

\TYPE {\small\verb%REAL_INT_LE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:real%} is {\small\verb%<=%}
another.

\DESCRIBE
The call {\small\verb%REAL_INT_LE_CONV `c1 <= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 <= c2 <=> T%} or
{\small\verb%|- c1 <= c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_LE_CONV `&11 <= &77`;;
  val it : thm = |- &11 <= &77 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_LE_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_LE_CONV, REAL_RAT_LE_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}LT{\_}CONV}

\TYPE {\small\verb%REAL_INT_LT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one integer literal of type {\small\verb%:real%} is {\small\verb%<%}
another.

\DESCRIBE
The call {\small\verb%REAL_INT_LT_CONV `c1 < c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 < c2 <=> T%} or
{\small\verb%|- c1 < c2 <=> F%} is true. By an integer literal we mean either {\small\verb%&n%} or
{\small\verb%-- &n%} where {\small\verb%n%} is a numeral.

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted integer literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_LT_CONV `-- &18 < &64`;;
  val it : thm = |- -- &18 < &64 <=> T
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_LT_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_LT_CONV, REAL_RAT_LT_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}MUL{\_}CONV}

\TYPE {\small\verb%REAL_INT_MUL_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform multiplication on two integer literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_MUL_CONV `c1 * c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:real%}, returns {\small\verb%|- c1 * c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 * c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the product of two permitted integer
literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_MUL_CONV `&6 * -- &9`;;
  val it : thm = |- &6 * -- &9 = -- &54
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_MUL_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_MUL_CONV, REAL_RAT_MUL_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}NEG{\_}CONV}

\TYPE {\small\verb%REAL_INT_NEG_CONV : conv%}\egroup

\SYNOPSIS
Conversion to negate an integer literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_NEG_CONV `--c`%}, where {\small\verb%c%} is an integer literal of type
{\small\verb%:real%}, returns the theorem {\small\verb%|- --c = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c%}'s negation. The literal {\small\verb%c%} may be of the form
{\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will be of
the same form.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of integer literal of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_NEG_CONV `-- (-- &3 / &2)`;;
  val it : thm = |- --(-- &3 / &2) = &3 / &2
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_NEG_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_NEG_CONV, REAL_RAT_NEG_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}POW{\_}CONV}

\TYPE {\small\verb%REAL_INT_POW_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform exponentiation on a integer literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_POW_CONV `c pow n`%} where {\small\verb%c%} is an integer literal of type
{\small\verb%:real%} and {\small\verb%n%} is a numeral of type {\small\verb%:num%}, returns {\small\verb%|- c pow n = d%} where {\small\verb%d%}
is the canonical integer literal that is equal to {\small\verb%c%} raised to the {\small\verb%n%}th
power. The literal {\small\verb%c%} may be of the form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in
the latter case) and the result will be of the same form.

\FAILURE
Fails if applied to a term that is not a permitted integer literal of type
{\small\verb%:real%} raised to a numeral power.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_POW_CONV `(-- &2) pow 77`;;
  val it : thm = |- -- &2 pow 77 = -- &151115727451828646838272
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_POW_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_POW_CONV, REAL_INT_POW_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}RAT{\_}CONV}

\TYPE {\small\verb%REAL_INT_RAT_CONV : conv%}\egroup

\SYNOPSIS
Convert basic rational constant of real type to canonical form.

\DESCRIBE
When applied to a term that is a rational constant of type {\small\verb%:real%},
{\small\verb%REAL_INT_RAT_CONV%} converts it to an explicit ratio {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%};
{\small\verb%q%} is always there, even if it is {\small\verb%1%}.

\FAILURE
Never fails; simply has no effect if it is not applied to a suitable constant.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_RAT_CONV `&22 / &7`;;
  val it : thm = |- &22 / &7 = &22 / &7

  # REAL_INT_RAT_CONV `&42`;;
  val it : thm = |- &42 = &42 / &1

  # REAL_INT_RAT_CONV `#3.1415926`;;
  val it : thm = |- #3.1415926 = &31415926 / &10000000
\end{verbatim}
}

\USES
Mainly for internal use as a preprocessing step in rational-number
calculations.

\SEEALSO
REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}REDUCE{\_}CONV}

\TYPE {\small\verb%REAL_INT_REDUCE_CONV : conv%}\egroup

\SYNOPSIS
Evaluate subexpressions built up from integer literals of type {\small\verb%:real%}, by
proof.

\DESCRIBE
When applied to a term, {\small\verb%REAL_INT_REDUCE_CONV%} performs a recursive bottom-up
evaluation by proof of subterms built from integer literals of type {\small\verb%:real%}
using the unary operators `{\small\verb%--%}', `{\small\verb%inv%}' and `{\small\verb%abs%}', and the binary
arithmetic (`{\small\verb%+%}', `{\small\verb%-%}', `{\small\verb%*%}', `{\small\verb%/%}', `{\small\verb%pow%}') and relational (`{\small\verb%<%}', `{\small\verb%<=%}',
`{\small\verb%>%}', `{\small\verb%>=%}', `{\small\verb%=%}') operators, as well as propagating literals through
logical operations, e.g. {\small\verb%T /\ x <=> x%}, returning a theorem that the original
and reduced terms are equal. The permissible integer literals are of the form
{\small\verb%&n%} or {\small\verb%-- &n%} for numeral {\small\verb%n%}, nonzero in the negative case.

\FAILURE
Never fails, but may have no effect.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_REDUCE_CONV
     `if &5 pow 4 < &4 pow 5 then (&2 pow 3 - &1) pow 2 + &1 else &99`;;
  val it : thm =
    |- (if &5 pow 4 < &4 pow 5 then (&2 pow 3 - &1) pow 2 + &1 else &99) = &50
\end{verbatim}
}

\COMMENTS
The corresponding {\small\verb%INT_REDUCE_CONV%} works for the type of integers. The more
general function {\small\verb%REAL_RAT_REDUCE_CONV%} works similarly over {\small\verb%:real%} but for
arbitrary rational literals.

\SEEALSO
NUM_REDUCE_CONV, INT_REDUCE_CONV, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}RED{\_}CONV}

\TYPE {\small\verb%REAL_INT_RED_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs one arithmetic or relational operation on integer literals of type
{\small\verb%:real%}.

\DESCRIBE
When applied to any of the terms {\small\verb%`--c`%}, {\small\verb%`abs c`%}, {\small\verb%`c1 + c2`%}, {\small\verb%`c1 - c2`%},
{\small\verb%`c1 * c2`%}, {\small\verb%`c pow n`%}, {\small\verb%`c1 <= c2`%}, {\small\verb%`c1 < c2`%}, {\small\verb%`c1 >= c2`%}, {\small\verb%`c1 > c2`%},
{\small\verb%`c1 = c2`%}, where {\small\verb%c%}, {\small\verb%c1%} and {\small\verb%c2%} are integer literals of type {\small\verb%:real%} and
{\small\verb%n%} is a numeral of type {\small\verb%:num%}, {\small\verb%REAL_INT_RED_CONV%} returns a theorem
asserting the equivalence of the term to a canonical integer (for the
arithmetic operators) or a truth-value (for the relational operators). The
integer literals are terms of the form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the
latter case).

\FAILURE
Fails if applied to an inappropriate term.

\USES
More convenient for most purposes is {\small\verb%REAL_INT_REDUCE_CONV%}, which applies
these evaluation conversions recursively at depth, or still more generally
{\small\verb%REAL_RAT_REDUCE_CONV%} which applies to any rational numbers, not just
integers. Still, access to this `one-step' reduction can be handy if you want to
add a conversion {\small\verb%conv%} for some other operator on real number literals, which
you can conveniently incorporate it into {\small\verb%REAL_INT_REDUCE_CONV%} with
{\par\samepage\setseps\small
\begin{verbatim}
  # let REAL_INT_REDUCE_CONV' =
      DEPTH_CONV(REAL_INT_RED_CONV ORELSEC conv);;
\end{verbatim}
}

\SEEALSO
INT_RED_CONV, REAL_INT_REDUCE_CONV, REAL_RAT_RED_CONV.

\ENDDOC
\DOC{REAL{\_}INT{\_}SUB{\_}CONV}

\TYPE {\small\verb%REAL_INT_SUB_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform subtraction on two integer literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_INT_SUB_CONV `c1 - c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are integer literals
of type {\small\verb%:real%}, returns {\small\verb%|- c1 - c2 = d%} where {\small\verb%d%} is the canonical integer
literal that is equal to {\small\verb%c1 - c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may be of the
form {\small\verb%&n%} or {\small\verb%-- &n%} (with nonzero {\small\verb%n%} in the latter case) and the result will
be of the same form.

\FAILURE
Fails if applied to a term that is not the difference of two permitted integer
literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_INT_SUB_CONV `&33 - &77`;;
  val it : thm = |- &33 - &77 = -- &44
\end{verbatim}
}

\COMMENTS
The related function {\small\verb%REAL_RAT_SUB_CONV%} subsumes this functionality, also
applying to rational literals. Unless the restriction to integers is desired or
a tiny efficiency difference matters, it should be used in preference.

\SEEALSO
INT_SUB_CONV, REAL_RAT_SUB_CONV, REAL_INT_REDUCE_CONV.

\ENDDOC
\DOC{REAL{\_}LET{\_}IMP}

\TYPE {\small\verb%REAL_LET_IMP : thm -> thm%}\egroup

\SYNOPSIS
Perform transitivity chaining for mixed strict/non-strict real number
inequality.

\DESCRIBE
When applied to a theorem {\small\verb%A |- s <= t%} where {\small\verb%s%} and {\small\verb%t%} have type {\small\verb%real%}, the
rule {\small\verb%REAL_LE_IMP%} returns {\small\verb%A |- !x1...xn z. t < z ==> s < z%}, where {\small\verb%z%} is
some variable and the {\small\verb%x1,...,xn%} are free variables in {\small\verb%s%} and {\small\verb%t%}.

\FAILURE
Fails if applied to a theorem whose conclusion is not of the form {\small\verb%`s <= t`%}
for some real number terms {\small\verb%s%} and {\small\verb%t%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_LET_IMP (REAL_ARITH `abs(x + y) <= abs(x) + abs(y)`);;
  val it : thm = |- !x y z. abs x + abs y < z ==> abs (x + y) < z
\end{verbatim}
}

\USES
Can make transitivity chaining in goals easier, e.g. by
{\small\verb%FIRST_ASSUM(MATCH_MP_TAC o REAL_LE_IMP)%}.

\SEEALSO
LE_IMP, REAL_ARITH, REAL_LE_IMP.

\ENDDOC
\DOC{REAL{\_}LE{\_}IMP}

\TYPE {\small\verb%REAL_LE_IMP : thm -> thm%}\egroup

\SYNOPSIS
Perform transitivity chaining for non-strict real number inequality.

\DESCRIBE
When applied to a theorem {\small\verb%A |- s <= t%} where {\small\verb%s%} and {\small\verb%t%} have type {\small\verb%real%}, the
rule {\small\verb%REAL_LE_IMP%} returns {\small\verb%A |- !x1...xn z. t <= z ==> s <= z%}, where {\small\verb%z%} is
some variable and the {\small\verb%x1,...,xn%} are free variables in {\small\verb%s%} and {\small\verb%t%}.

\FAILURE
Fails if applied to a theorem whose conclusion is not of the form {\small\verb%`s <= t`%}
for some real number terms {\small\verb%s%} and {\small\verb%t%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_LE_IMP (REAL_ARITH `x:real <= abs(x)`);;
  val it : thm = |- !x z. abs x <= z ==> x <= z
\end{verbatim}
}

\USES
Can make transitivity chaining in goals easier, e.g. by
{\small\verb%FIRST_ASSUM(MATCH_MP_TAC o REAL_LE_IMP)%}.

\SEEALSO
LE_IMP, REAL_ARITH, REAL_LET_IMP.

\ENDDOC
\DOC{REAL{\_}LINEAR{\_}PROVER}

\TYPE {\small\verb%REAL_LINEAR_PROVER : (thm list * thm list * thm list -> positivstellensatz -> thm) -> thm list * thm list * thm list -> thm%}\egroup

\SYNOPSIS
Refute real equations and inequations by linear reasoning (not intended for
general use).

\DESCRIBE
The {\small\verb%REAL_LINEAR_PROVER%} function should be given two arguments. The first is a
proof translator that constructs a contradiction from a tuple of three theorem
lists using a Positivstellensatz refutation, which is essentially a
representation of how to add and multiply equalities or inequalities chosen
from the list to reach a trivially false equation or inequality such as
{\small\verb%&0 > &0%}. The second argument is a triple of theorem lists, respectively a
list of equations of the form {\small\verb%A_i |- p_i = &0%}, a list of non-strict
inequalities of the form {\small\verb%B_j |- q_i >= &0%}, and a list of strict inequalities
of the form {\small\verb%C_k |- r_k > &0%}, with both sides being real in each case. Any
theorems not of that form will not lead to an error, but will be ignored and
cannot contribute to the proof. The prover attempts to construct a
Positivstellensatz refutation by normalization as in {\small\verb%REAL_POLY_CONV%} then
linear inequality reasoning, and if successful will apply the translator
function to this refutation to obtain {\small\verb%D |- F%} where all assumptions {\small\verb%D%} occurs
among the {\small\verb%A_i%}, {\small\verb%B_j%} or {\small\verb%C_k%}. Otherwise, or if the translator itself fails,
the call fails.

\FAILURE
Fails if there is no refutation using linear reasoning or if an improper form
inhibits proof for other reasons, or if the translator fails.

\USES
This is not intended for general use. The core real inequality reasoner
{\small\verb%REAL_ARITH%} is implemented by:
{\par\samepage\setseps\small
\begin{verbatim}
  # let REAL_ARITH = GEN_REAL_ARITH REAL_LINEAR_PROVER;;
\end{verbatim}
}
In this way, all specifically linear functionality is isolated in
{\small\verb%REAL_LINEAR_PROVER%}, and the rest of the infrastructure of Positivstellensatz
proof translation and initial normalization (including elimination of {\small\verb%abs%},
{\small\verb%max%}, {\small\verb%min%}, conditional expressions etc.) is available for use with more
advanced nonlinear provers. Such a prover, based on semidefinite programming
and requiring support of an external SDP solver to find Positivstellensatz
refutations, can be found in {\small\verb%Examples/sos.ml%}.

\SEEALSO
GEN_REAL_ARITH, REAL_ARITH, REAL_POLY_CONV.

\ENDDOC
\DOC{REAL{\_}POLY{\_}ADD{\_}CONV}

\TYPE {\small\verb%REAL_POLY_ADD_CONV : term -> thm%}\egroup

\SYNOPSIS
Adds two real polynomials while retaining canonical form.

\DESCRIBE
For many purposes it is useful to retain polynomials in a canonical form. For
more information on the usual normal form in HOL Light, see the function
{\small\verb%REAL_POLY_CONV%}, which converts a polynomial to normal form while proving the
equivalence of the original and normalized forms. The function
{\small\verb%REAL_POLY_ADD_CONV%} is a more delicate conversion that, given a term {\small\verb%p1 + p2%}
where {\small\verb%p1%} and {\small\verb%p2%} are real polynomials in normal form, returns a theorem
{\small\verb%|- p1 + p2 = p%} where {\small\verb%p%} is in normal form.

\FAILURE
Fails if applied to a term that is not the sum of two real terms. If these
subterms are not polynomials in normal form, the overall normalization is not
guaranteed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_ADD_CONV `(x pow 2 + x) + (x pow 2 + -- &1 * x + &1)`;;
  val it : thm =
    |- (x pow 2 + x) + x pow 2 + -- &1 * x + &1 = &2 * x pow 2 + &1
\end{verbatim}
}

\USES
More delicate polynomial operations that simply the direct normalization with
{\small\verb%REAL_POLY_CONV%}.

\SEEALSO
REAL_ARITH, REAL_POLY_CONV, REAL_POLY_MUL_CONV, REAL_POLY_NEG_CONV,
REAL_POLY_POW_CONV, REAL_POLY_SUB_CONV, REAL_RING.

\ENDDOC
\DOC{REAL{\_}POLY{\_}CONV}

\TYPE {\small\verb%REAL_POLY_CONV : term -> thm%}\egroup

\SYNOPSIS
Converts a real polynomial into canonical form.

\DESCRIBE
Given a term of type {\small\verb%:real%} that is built up using addition, subtraction,
negation, multiplication, and inversion and division of constants,
{\small\verb%REAL_POLY_CONV%} converts it into a canonical polynomial form and returns a
theorem asserting the equivalence of the original and canonical terms. The
basic elements need not simply be variables or constants; anything not built up
using the operators given above will be considered `atomic' for the purposes of
this conversion, for example {\small\verb%inv(x)%} where {\small\verb%x%} is a variable. The canonical
polynomial form is a `multiplied out' sum of products, with the monomials
(product terms) ordered according to the canonical OCaml order on terms. In
particular, it is just {\small\verb%&0%} if the polynomial is identically zero.

\FAILURE
Never fails, even if the term has the wrong type; in this case it merely
returns a reflexive theorem.

\EXAMPLE
This illustrates how terms are `multiplied out':
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_CONV
     `(x + &1) * (x pow 2 + &1) * (x pow 4 + &1)`;;
  val it : thm =
    |- (x + &1) * (x pow 2 + &1) * (x pow 4 + &1) =
       x pow 7 + x pow 6 + x pow 5 + x pow 4 + x pow 3 + x pow 2 + x + &1
\end{verbatim}
}
\noindent and the following is an example of how a complicated algebraic
identity (due to Liouville?) simplifies to zero. Note that division is
permissible because it is only by constants.
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_CONV
     `((x1 + x2) pow 4 + (x1 + x3) pow 4 + (x1 + x4) pow 4 +
       (x2 + x3) pow 4 + (x2 + x4) pow 4 + (x3 + x4) pow 4) / &6 +
      ((x1 - x2) pow 4 + (x1 - x3) pow 4 + (x1 - x4) pow 4 +
       (x2 - x3) pow 4 + (x2 - x4) pow 4 + (x3 - x4) pow 4) / &6 -
      (x1 pow 2 + x2 pow 2 + x3 pow 2 + x4 pow 2) pow 2`;;
  val it : thm =
    |- ((x1 + x2) pow 4 +
        (x1 + x3) pow 4 +
        (x1 + x4) pow 4 +
        (x2 + x3) pow 4 +
        (x2 + x4) pow 4 +
        (x3 + x4) pow 4) /
       &6 +
       ((x1 - x2) pow 4 +
        (x1 - x3) pow 4 +
        (x1 - x4) pow 4 +
        (x2 - x3) pow 4 +
        (x2 - x4) pow 4 +
        (x3 - x4) pow 4) /
       &6 -
       (x1 pow 2 + x2 pow 2 + x3 pow 2 + x4 pow 2) pow 2 =
       &0
\end{verbatim}
}

\USES
Keeping terms in normal form. For simply proving equalities, {\small\verb%REAL_RING%} is
more powerful and usually more convenient.

\SEEALSO
INT_POLY_CONV, REAL_ARITH, REAL_RING, SEMIRING_NORMALIZERS_CONV.

\ENDDOC
\DOC{REAL{\_}POLY{\_}MUL{\_}CONV}

\TYPE {\small\verb%REAL_POLY_MUL_CONV : term -> thm%}\egroup

\SYNOPSIS
Multiplies two real polynomials while retaining canonical form.

\DESCRIBE
For many purposes it is useful to retain polynomials in a canonical form. For
more information on the usual normal form in HOL Light, see the function
{\small\verb%REAL_POLY_CONV%}, which converts a polynomial to normal form while proving the
equivalence of the original and normalized forms. The function
{\small\verb%REAL_POLY_MUL_CONV%} is a more delicate conversion that, given a term {\small\verb%p1 * p2%}
where {\small\verb%p1%} and {\small\verb%p2%} are real polynomials in normal form, returns a theorem
{\small\verb%|- p1 * p2 = p%} where {\small\verb%p%} is in normal form.

\FAILURE
Fails if applied to a term that is not the product of two real terms. If these
subterms are not polynomials in normal form, the overall normalization is not
guaranteed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_MUL_CONV `(x pow 2 + x) * (x pow 2 + -- &1 * x + &1)`;;
  val it : thm = |- (x pow 2 + x) * (x pow 2 + -- &1 * x + &1) = x pow 4 + x
\end{verbatim}
}

\USES
More delicate polynomial operations that simply the direct normalization with
{\small\verb%REAL_POLY_CONV%}.

\SEEALSO
REAL_ARITH, REAL_POLY_ADD_CONV, REAL_POLY_CONV, REAL_POLY_NEG_CONV,
REAL_POLY_POW_CONV, REAL_POLY_SUB_CONV, REAL_RING.

\ENDDOC
\DOC{REAL{\_}POLY{\_}NEG{\_}CONV}

\TYPE {\small\verb%REAL_POLY_NEG_CONV : term -> thm%}\egroup

\SYNOPSIS
Negates real polynomial while retaining canonical form.

\DESCRIBE
For many purposes it is useful to retain polynomials in a canonical form. For
more information on the usual normal form in HOL Light, see the function
{\small\verb%REAL_POLY_CONV%}, which converts a polynomial to normal form while proving the
equivalence of the original and normalized forms. The function
{\small\verb%REAL_POLY_NEG_CONV%} is a more delicate conversion that, given a term {\small\verb%--p%}
where {\small\verb%p%} is a real polynomial in normal form, returns a theorem {\small\verb%|- --p = p'%}
where {\small\verb%p'%} is in normal form.

\FAILURE
Fails if applied to a term that is not the negation of a real term. If negation
is applied to a polynomial in non-normal form, the overall normalization is not
guaranteed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_NEG_CONV `--(x pow 2 + -- &1)`;;
  val it : thm = |- --(x pow 2 + -- &1) = -- &1 * x pow 2 + &1
\end{verbatim}
}

\USES
More delicate polynomial operations than simply the direct normalization with
{\small\verb%REAL_POLY_CONV%}.

\SEEALSO
REAL_ARITH, REAL_POLY_ADD_CONV, REAL_POLY_CONV, REAL_POLY_MUL_CONV,
REAL_POLY_POW_CONV, REAL_POLY_SUB_CONV, REAL_RING.

\ENDDOC
\DOC{REAL{\_}POLY{\_}POW{\_}CONV}

\TYPE {\small\verb%REAL_POLY_POW_CONV : term -> thm%}\egroup

\SYNOPSIS
Raise real polynomial to numeral power while retaining canonical form.

\DESCRIBE
For many purposes it is useful to retain polynomials in a canonical form. For
more information on the usual normal form in HOL Light, see the function
{\small\verb%REAL_POLY_CONV%}, which converts a polynomial to normal form while proving the
equivalence of the original and normalized forms. The function
{\small\verb%REAL_POLY_POW_CONV%} is a more delicate conversion that, given a term
{\small\verb%p1 pow n%} where {\small\verb%p%} is a real polynomial in normal form and {\small\verb%n%} a numeral,
returns a theorem {\small\verb%|- p pow n = p'%} where {\small\verb%p'%} is in normal form.

\FAILURE
Fails if applied to a term that is not a real term raised to a numeral power.
If the subterm is not a polynomial in normal form, the overall normalization is
not guaranteed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_POW_CONV `(x + &1) pow 4`;;
  val it : thm =
    |- (x + &1) pow 4 = x pow 4 + &4 * x pow 3 + &6 * x pow 2 + &4 * x + &1
\end{verbatim}
}

\USES
More delicate polynomial operations that simply the direct normalization with
{\small\verb%REAL_POLY_CONV%}.

\SEEALSO
REAL_ARITH, REAL_POLY_ADD_CONV, REAL_POLY_CONV, REAL_POLY_MUL_CONV,
REAL_POLY_NEG_CONV, REAL_POLY_SUB_CONV, REAL_RING.

\ENDDOC
\DOC{REAL{\_}POLY{\_}SUB{\_}CONV}

\TYPE {\small\verb%REAL_POLY_SUB_CONV : term -> thm%}\egroup

\SYNOPSIS
Subtracts two real polynomials while retaining canonical form.

\DESCRIBE
For many purposes it is useful to retain polynomials in a canonical form. For
more information on the usual normal form in HOL Light, see the function
{\small\verb%REAL_POLY_CONV%}, which converts a polynomial to normal form while proving the
equivalence of the original and normalized forms. The function
{\small\verb%REAL_POLY_SUB_CONV%} is a more delicate conversion that, given a term {\small\verb%p1 - p2%}
where {\small\verb%p1%} and {\small\verb%p2%} are real polynomials in normal form, returns a theorem
{\small\verb%|- p1 - p2 = p%} where {\small\verb%p%} is in normal form.

\FAILURE
Fails if applied to a term that is not the difference of two real terms. If
these subterms are not polynomials in normal form, the overall normalization is
not guaranteed.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_POLY_SUB_CONV `(x pow 2 + x) - (x pow 2 + -- &1 * x + &1)`;;
  val it : thm = |- (x pow 2 + x) - (x pow 2 + -- &1 * x + &1) = &2 * x + -- &1
\end{verbatim}
}

\USES
More delicate polynomial operations that simply the direct normalization with
{\small\verb%REAL_POLY_CONV%}.

\SEEALSO
REAL_ARITH, REAL_POLY_SUB_CONV, REAL_POLY_CONV, REAL_POLY_MUL_CONV,
REAL_POLY_NEG_CONV, REAL_POLY_POW_CONV, REAL_RING.

\ENDDOC
\DOC{REAL{\_}RAT{\_}ABS{\_}CONV}

\TYPE {\small\verb%REAL_RAT_ABS_CONV : term -> thm%}\egroup

\SYNOPSIS
Conversion to produce absolute value of a rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_ABS_CONV `abs c`%}, where {\small\verb%c%} is a rational literal of type
{\small\verb%:real%}, returns the theorem {\small\verb%|- abs c = d%} where {\small\verb%d%} is the canonical rational
literal that is equal to {\small\verb%c%}'s absolute value. The literal {\small\verb%c%} may be an
integer literal ({\small\verb%&n%} or {\small\verb%-- &n%}), a ratio ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or a
decimal ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The returned value {\small\verb%d%} is always put
in the form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no
common factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the absolute value function applied to
one of the permitted forms of rational literal of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_ABS_CONV `abs(-- &3 / &2)`;;
  val it : thm = |- abs (-- &3 / &2) = &3 / &2
\end{verbatim}
}

\SEEALSO
REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}ADD{\_}CONV}

\TYPE {\small\verb%REAL_RAT_ADD_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_ADD_CONV `c1 + c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- c1 + c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%c1 + c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the sum of two permitted rational
literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_ADD_CONV `-- &11 / &12 + #0.09`;;
  val it : thm = |- -- &11 / &12 + #0.09 = -- &62 / &75
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}DIV{\_}CONV}

\TYPE {\small\verb%REAL_RAT_DIV_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform division on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_DIV_CONV `c1 / c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- c1 / c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%c1 / c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the quotient of two permitted rational
literals of type {\small\verb%:real%}, or if the divisor is zero.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_DIV_CONV `&2000 / (-- &40 / &12)`;;
  val it : thm = |- &2000 / (-- &40 / &12) = -- &600
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}EQ{\_}CONV}

\TYPE {\small\verb%REAL_RAT_EQ_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one rational constant of type {\small\verb%:real%} is equal to
another.

\DESCRIBE
The call {\small\verb%REAL_RAT_EQ_CONV `c1 = c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
constants of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 = c2 <=> T%} or
{\small\verb%|- c1 = c2 <=> F%} is true. The constants {\small\verb%c1%} and {\small\verb%c2%} may be integer
constants ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}).

\FAILURE
Fails if applied to a term that is not an equality comparison on two permitted
rational constants of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_EQ_CONV `#0.40 = &2 / &5`;;
  val it : thm = |- #0.40 = &2 / &5 <=> T

  # REAL_RAT_EQ_CONV `#3.14 = &22 / &7`;;
  val it : thm = |- #3.14 = &22 / &7 <=> F
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}GE{\_}CONV}

\TYPE {\small\verb%REAL_RAT_GE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one rational literal of type {\small\verb%:real%} is {\small\verb%>=%}
another.

\DESCRIBE
The call {\small\verb%REAL_RAT_GE_CONV `c1 >= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 >= c2 <=> T%} or
{\small\verb%|- c1 >= c2 <=> F%} is true. The literals {\small\verb%c1%} and {\small\verb%c2%} may be integer
literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}).

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_GE_CONV `#3.1415926 >= &22 / &7`;;
  val it : thm = |- #3.1415926 >= &22 / &7 <=> F
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}GT{\_}CONV}

\TYPE {\small\verb%REAL_RAT_GT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one rational literal of type {\small\verb%:real%} is {\small\verb%>%}
another.

\DESCRIBE
The call {\small\verb%REAL_RAT_GT_CONV `c1 > c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 > c2 <=> T%} or
{\small\verb%|- c1 > c2 <=> F%} is true. The literals {\small\verb%c1%} and {\small\verb%c2%} may be integer
literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}).

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_GT_CONV `&3 / &2 > #1.11`;;
  val it : thm = |- &3 / &2 > #1.11 <=> T
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}INV{\_}CONV}

\TYPE {\small\verb%REAL_RAT_INV_CONV : term -> thm%}\egroup

\SYNOPSIS
Conversion to invert a rational constant of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_INV_CONV `inv c`%}, where {\small\verb%c%} is a rational constant of type
{\small\verb%:real%}, returns the theorem {\small\verb%|- inv c = d%} where {\small\verb%d%} is the canonical rational
constant that is equal to {\small\verb%c%}'s multiplicative inverse (reciprocal). The
constant {\small\verb%c%} may be an integer constant ({\small\verb%&n%} or {\small\verb%-- &n%}), a ratio ({\small\verb%&p / &q%}
or {\small\verb%-- &p / &q%}), or a decimal ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The returned
value {\small\verb%d%} is always put in the form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and
{\small\verb%p%} and {\small\verb%q%} sharing no common factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is
impossible.

\FAILURE
Fails if applied to a term that is not the multiplicative inverse function
applied to one of the permitted forms of rational constant of type {\small\verb%:real%}, or
if the constant is zero.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_INV_CONV `inv(-- &5 / &9)`;;
  val it : thm = |- inv (-- &5 / &9) = -- &9 / &5
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}LE{\_}CONV}

\TYPE {\small\verb%REAL_RAT_LE_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one rational literal of type {\small\verb%:real%} is {\small\verb%<=%}
another.

\DESCRIBE
The call {\small\verb%REAL_RAT_LE_CONV `c1 <= c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 <= c2 <=> T%} or
{\small\verb%|- c1 <= c2 <=> F%} is true. The literals {\small\verb%c1%} and {\small\verb%c2%} may be integer
literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}).

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_LE_CONV `#3.1415926 <= &22 / &7`;;
  val it : thm = |- #3.1415926 <= &22 / &7 <=> T
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}LT{\_}CONV}

\TYPE {\small\verb%REAL_RAT_LT_CONV : conv%}\egroup

\SYNOPSIS
Conversion to prove whether one rational literal of type {\small\verb%:real%} is {\small\verb%<%}
another.

\DESCRIBE
The call {\small\verb%REAL_RAT_LT_CONV `c1 < c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns whichever of {\small\verb%|- c1 < c2 <=> T%} or
{\small\verb%|- c1 < c2 <=> F%} is true. The literals {\small\verb%c1%} and {\small\verb%c2%} may be integer
literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}).

\FAILURE
Fails if applied to a term that is not the appropriate inequality comparison on
two permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_LT_CONV `#3.1415926 < &355 / &113`;;
  val it : thm = |- #3.1415926 < &355 / &113 <=> T
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}MAX{\_}CONV}

\TYPE {\small\verb%REAL_RAT_MAX_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_MAX_CONV `max c1 c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- max c1 c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%max c1 c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the maximum operator applied to two
permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_MAX_CONV `max (-- &9) (&22 / &7)`;;
  val it : thm = |- max (-- &9) (&22 / &7) = &22 / &7
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV,
REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV, REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}MIN{\_}CONV}

\TYPE {\small\verb%REAL_RAT_MIN_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform addition on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_MIN_CONV `min c1 c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- min c1 c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%min c1 c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the minimum operator applied to two
permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_MIN_CONV `min (-- &9) (&22 / &7)`;;
  val it : thm = |- min (-- &9) (&22 / &7) = -- &9
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV,
REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV, REAL_RAT_LT_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV,
REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV, REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}MUL{\_}CONV}

\TYPE {\small\verb%REAL_RAT_MUL_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform multiplication on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_MUL_CONV `c1 * c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- c1 * c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%c1 * c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the product of two permitted rational
literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_MUL_CONV `#3.16227766016837952 * #3.16227766016837952`;;
  val it : thm =
    |- #3.16227766016837952 * #3.16227766016837952 =
       &24414062500000002902889155426649 / &2441406250000000000000000000000
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_LT_CONV, REAL_RAT_NEG_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}NEG{\_}CONV}

\TYPE {\small\verb%REAL_RAT_NEG_CONV : term -> thm%}\egroup

\SYNOPSIS
Conversion to negate a rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_NEG_CONV `--c`%}, where {\small\verb%c%} is a rational literal of type
{\small\verb%:real%}, returns the theorem {\small\verb%|- --c = d%} where {\small\verb%d%} is the canonical rational
literal that is equal to {\small\verb%c%}'s negation. The literal {\small\verb%c%} may be an integer
literal ({\small\verb%&n%} or {\small\verb%-- &n%}), a ratio ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or a decimal
({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The returned value {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the negation of one of the permitted
forms of rational literal of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_NEG_CONV `-- (-- &3 / &2)`;;
  val it : thm = |- --(-- &3 / &2) = &3 / &2
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV,
REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}POW{\_}CONV}

\TYPE {\small\verb%REAL_RAT_POW_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform exponentiation on a rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_POW_CONV `c pow n`%} where {\small\verb%c%} is a rational literal of
type {\small\verb%:real%} and {\small\verb%n%} is a numeral of type {\small\verb%:num%}, returns {\small\verb%|- c pow n = d%}
where {\small\verb%d%} is the canonical rational literal that is equal to {\small\verb%c%} raised to the
{\small\verb%n%}th power. The literal {\small\verb%c%} may be an integer literal ({\small\verb%&n%} or {\small\verb%-- &n%}),
a ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or a decimal ({\small\verb%#DDD.DDDD%} or
{\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the form {\small\verb%&p / &q%} or
{\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common factor, or simply
{\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not a permitted rational literal of type
{\small\verb%:real%} raised to a numeral power.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_POW_CONV `#1.414 pow 2`;;
  val it : thm = |- #1.414 pow 2 = &1999396 / &1000000
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV,
REAL_RAT_NEG_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}REDUCE{\_}CONV}

\TYPE {\small\verb%REAL_RAT_REDUCE_CONV : conv%}\egroup

\SYNOPSIS
Evaluate subexpressions built up from rational literals of type {\small\verb%:real%}, by
proof.

\DESCRIBE
When applied to a term, {\small\verb%REAL_RAT_REDUCE_CONV%} performs a recursive bottom-up
evaluation by proof of subterms built from rational literals of type {\small\verb%:real%}
using the unary operators `{\small\verb%--%}', `{\small\verb%inv%}' and `{\small\verb%abs%}', and the binary
arithmetic (`{\small\verb%+%}', `{\small\verb%-%}', `{\small\verb%*%}', `{\small\verb%/%}', `{\small\verb%pow%}') and relational (`{\small\verb%<%}', `{\small\verb%<=%}',
`{\small\verb%>%}', `{\small\verb%>=%}', `{\small\verb%=%}') operators, as well as propagating literals through
logical operations, e.g. {\small\verb%T /\ x <=> x%}, returning a theorem that the original
and reduced terms are equal.

The permissible rational literals are integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}),
ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals ({\small\verb%#DDD.DDDD%} or
{\small\verb%#DDD.DDDDeNN%}). Any numeric result is always put in the form {\small\verb%&p / &q%} or
{\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common factor, or simply
{\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Never fails, but may have no effect.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_REDUCE_CONV
     `#3.1415926535 < &355 / &113 /\ &355 / &113 < &3 + &1 / &7`;;
  val it : thm =
    |- #3.1415926535 < &355 / &113 /\ &355 / &113 < &3 + &1 / &7 <=> T
\end{verbatim}
}

\SEEALSO
NUM_REDUCE_CONV, REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV,
REAL_RAT_EQ_CONV, REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV,
REAL_RAT_LE_CONV, REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV,
REAL_RAT_MUL_CONV, REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV, REAL_RAT_RED_CONV,
REAL_RAT_SGN_CONV, REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}RED{\_}CONV}

\TYPE {\small\verb%REAL_RAT_RED_CONV : term -> thm%}\egroup

\SYNOPSIS
Performs one arithmetic or relational operation on rational literals of type
{\small\verb%:real%}.

\DESCRIBE
When applied to any of the terms {\small\verb%`--c`%}, {\small\verb%`inv c`%}, {\small\verb%`abs c`%}, {\small\verb%`c1 + c2`%},
{\small\verb%`c1 - c2`%}, {\small\verb%`c1 * c2`%}, {\small\verb%`c1 / c2`%}, {\small\verb%`c pow n`%}, {\small\verb%`c1 <= c2`%}, {\small\verb%`c1 < c2`%},
{\small\verb%`c1 >= c2`%}, {\small\verb%`c1 > c2`%}, {\small\verb%`c1 = c2`%}, where {\small\verb%c%}, {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%} and {\small\verb%n%} is a numeral of type {\small\verb%:num%},
{\small\verb%REAL_RAT_RED_CONV%} returns a theorem asserting the equivalence of the term to
a canonical rational (for the arithmetic operators) or a truth-value (for the
relational operators).

The permissible rational literals are integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}),
ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or decimals ({\small\verb%#DDD.DDDD%} or
{\small\verb%#DDD.DDDDeNN%}). Any numeric result is always put in the form {\small\verb%&p / &q%} or
{\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common factor, or simply
{\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to an inappropriate term, or if {\small\verb%c%} is zero in {\small\verb%`inv c`%}, or
if {\small\verb%c2%} is zero in {\small\verb%c1 / c2%}.

\USES
More convenient for most purposes is {\small\verb%REAL_RAT_REDUCE_CONV%}, which applies
these evaluation conversions recursively at depth. But access to this
`one-step' reduction can be handy if you want to add a conversion {\small\verb%conv%} for
some other operator on real number literals, which you can conveniently
incorporate it into {\small\verb%REAL_RAT_REDUCE_CONV%} with
{\par\samepage\setseps\small
\begin{verbatim}
  # let REAL_RAT_REDUCE_CONV' =
      DEPTH_CONV(REAL_RAT_RED_CONV ORELSEC conv);;
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV,
REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_SGN_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}SGN{\_}CONV}

\TYPE {\small\verb%REAL_RAT_SGN_CONV : term -> thm%}\egroup

\SYNOPSIS
Conversion to produce signum (sign) of a rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_SGN_CONV `real_sgn c`%}, where {\small\verb%c%} is a rational literal of
type {\small\verb%:real%}, returns the theorem {\small\verb%|- real_sgn c = d%} where {\small\verb%d%} is the
canonical rational literal that is equal to {\small\verb%c%}'s sign. The literal {\small\verb%c%} may be
an integer literal ({\small\verb%&n%} or {\small\verb%-- &n%}), a ratio ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or a
decimal ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The returned value {\small\verb%d%} is always put
in the form {\small\verb%&1%}, {\small\verb%&0%} or {\small\verb%-- &1%}.

\FAILURE
Fails if applied to a term that is not the signum function applied to
one of the permitted forms of rational literal of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_SGN_CONV `real_sgn(-- &3 / &2)`;;
  val it : thm = |- real_sgn (-- &3 / &2) = -- &1
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV,
REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV,
REAL_RAT_SUB_CONV.

\ENDDOC
\DOC{REAL{\_}RAT{\_}SUB{\_}CONV}

\TYPE {\small\verb%REAL_RAT_SUB_CONV : conv%}\egroup

\SYNOPSIS
Conversion to perform subtraction on two rational literals of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%REAL_RAT_SUB_CONV `c1 - c2`%} where {\small\verb%c1%} and {\small\verb%c2%} are rational
literals of type {\small\verb%:real%}, returns {\small\verb%|- c1 - c2 = d%} where {\small\verb%d%} is the canonical
rational literal that is equal to {\small\verb%c1 - c2%}. The literals {\small\verb%c1%} and {\small\verb%c2%} may
be integer literals ({\small\verb%&n%} or {\small\verb%-- &n%}), ratios ({\small\verb%&p / &q%} or {\small\verb%-- &p / &q%}), or
decimals ({\small\verb%#DDD.DDDD%} or {\small\verb%#DDD.DDDDeNN%}). The result {\small\verb%d%} is always put in the
form {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} with {\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} sharing no common
factor, or simply {\small\verb%&p%} or {\small\verb%-- &p%} when that is impossible.

\FAILURE
Fails if applied to a term that is not the subtraction function applied to two
permitted rational literals of type {\small\verb%:real%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RAT_SUB_CONV `&355 / &113 - #3.1415926`;;
  val it : thm = |- &355 / &113 - #3.1415926 = &181 / &565000000
\end{verbatim}
}

\SEEALSO
REAL_RAT_ABS_CONV, REAL_RAT_ADD_CONV, REAL_RAT_DIV_CONV, REAL_RAT_EQ_CONV,
REAL_RAT_GE_CONV, REAL_RAT_GT_CONV, REAL_RAT_INV_CONV, REAL_RAT_LE_CONV,
REAL_RAT_LT_CONV, REAL_RAT_MAX_CONV, REAL_RAT_MIN_CONV, REAL_RAT_MUL_CONV,
REAL_RAT_NEG_CONV, REAL_RAT_POW_CONV, REAL_RAT_REDUCE_CONV, REAL_RAT_RED_CONV,
REAL_RAT_SGN_CONV.

\ENDDOC
\DOC{REAL{\_}RING}

\TYPE {\small\verb%REAL_RING : term -> thm%}\egroup

\SYNOPSIS
Ring decision procedure instantiated to real numbers.

\DESCRIBE
The rule {\small\verb%REAL_RING%} should be applied to a formula that, after suitable
normalization, can be considered a universally quantified Boolean combination
of equations and inequations between terms of type {\small\verb%:real%}. If that formula
holds in all integral domains, {\small\verb%REAL_RING%} will prove it. Any ``alien'' atomic
formulas that are not real number equations will not contribute to the proof
but will not in themselves cause an error. The function is a particular
instantiation of {\small\verb%RING%}, which is a more generic procedure for ring and
semiring structures.

\FAILURE
Fails if the formula is unprovable by the methods employed. This does not
necessarily mean that it is not valid for {\small\verb%:real%}, but rather that it is not
valid on all integral domains (see below).

\EXAMPLE
This simple example is based on the inversion of a homographic function (from
Gosper's notes on continued fractions):
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING
     `y * (c * x + d) = a * x + b ==> x * (c * y - a) = b - d * y`;;
  2 basis elements and 0 critical pairs
  val it : thm = |- y * (c * x + d) = a * x + b ==> x * (c * y - a) = b - d * y
\end{verbatim}
}
The following more complicated example verifies a classic Cardano reduction
formula for cubic equations:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING
     `p = (&3 * a1 - a2 pow 2) / &3 /\
      q = (&9 * a1 * a2 - &27 * a0 - &2 * a2 pow 3) / &27 /\
      z = x - a2 / &3 /\
      x * w = w pow 2 - p / &3 /\
      ~(p = &0)
      ==> (z pow 3 + a2 * z pow 2 + a1 * z + a0 = &0 <=>
          (w pow 3) pow 2 - q * (w pow 3) - p pow 3 / &27 = &0)`;;
  ...
\end{verbatim}
}
Note that formulas depending on specific features of the real numbers are not
always provable by this generic ring procedure. For example we can prove:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING
     `s pow 2 = &2
      ==> (x pow 4 + &1 = &0 <=>
           x pow 2 + s * x + &1 = &0 \/ x pow 2 - s * x + &1 = &0)`;;
  ...
\end{verbatim}
}
\noindent but not the much simpler real-specific fact:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING `x pow 4 + 1 = &0 ==> F`;;
  Exception: Failure "tryfind".
\end{verbatim}
}
To support real-specific nonlinear reasoning, you may like to investigate the
experimental decision procedure in {\small\verb%Examples/sos.ml%}. For general support for
division (fields) see {\small\verb%REAL_FIELD%}.

\USES
Often useful for generating non-trivial algebraic lemmas. Even when it is not
capable of solving the whole problem, it can often deal with the most tedious
algebraic parts. For example after loading in the definitions of trig
functions:
{\par\samepage\setseps\small
\begin{verbatim}
  # needs "Library/transc.ml";;
\end{verbatim}
}
\noindent you may wish to prove a tedious trig identity such as:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(--((&7 * cos x pow 6) * sin x) * &7) / &49 -
       (--((&5 * cos x pow 4) * sin x) * &5) / &25 * &3 +
        --((&3 * cos x pow 2) * sin x) + sin x =
       sin x pow 7`;;
\end{verbatim}
}
\noindent which can be done by {\small\verb%REAL_RING%} together with one simple lemma:
{\par\samepage\setseps\small
\begin{verbatim}
  # SIN_CIRCLE;;
  val it : thm = |- !x. sin x pow 2 + cos x pow 2 = &1
\end{verbatim}
}
\noindent as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(MP_TAC(SPEC `x:real` SIN_CIRCLE) THEN CONV_TAC REAL_RING);;
  2 basis elements and 0 critical pairs
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ARITH_RULE, ARITH_TAC, INT_RING, NUM_RING, real_ideal_cofactors, REAL_ARITH,
REAL_FIELD, RING.

\ENDDOC
\DOC{RECALL{\_}ACCEPT{\_}TAC}

\TYPE {\small\verb%RECALL_ACCEPT_TAC : ('a -> thm) -> 'a -> goal -> goalstate%}\egroup

\SYNOPSIS
Delay evaluation of theorem-producing function till needed.

\DESCRIBE
Given a theorem-producing inference rule {\small\verb%f%} and its argument {\small\verb%a%}, the tactic
{\small\verb%RECALL_ACCEPT_TAC f a%} will evaluate {\small\verb%th = f a%} and do {\small\verb%ACCEPT_TAC th%}, but
only when the tactic is applied to a goal.

\FAILURE
Never fails until subsequently applied to a goal, but then may fail if the
theorem-producing function does.

\EXAMPLE
You might for example do
{\par\samepage\setseps\small
\begin{verbatim}
  RECALL_ACCEPT_TAC (EQT_ELIM o NUM_REDUCE_CONV) `16 EXP 53 < 15 EXP 55`;;
\end{verbatim}
}
\noindent and the call
{\par\samepage\setseps\small
\begin{verbatim}
  (EQT_ELIM o NUM_REDUCE_CONV) `16 EXP 53 < 15 EXP 55`
\end{verbatim}
}
\noindent will be delayed until the tactic is applied.

\USES
Delaying a time-consuming compound inference rule in a tactic script until it
is actually used.

\ENDDOC
\DOC{REDEPTH{\_}CONV}

\TYPE {\small\verb%REDEPTH_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion bottom-up to all subterms, retraversing changed ones.

\DESCRIBE
{\small\verb%REDEPTH_CONV c tm%} applies the conversion {\small\verb%c%} repeatedly to all subterms of
the term {\small\verb%tm%} and recursively applies {\small\verb%REDEPTH_CONV c%} to each subterm at which
{\small\verb%c%} succeeds, until there is no subterm remaining for which application of {\small\verb%c%}
succeeds.

More precisely, {\small\verb%REDEPTH_CONV c tm%} repeatedly applies the conversion {\small\verb%c%} to
all the subterms of the term {\small\verb%tm%}, including the term {\small\verb%tm%} itself. The supplied
conversion {\small\verb%c%} is applied to the subterms of {\small\verb%tm%} in bottom-up order and is
applied repeatedly (zero or more times, as is done by {\small\verb%REPEATC%}) to each
subterm until it fails.  If {\small\verb%c%} is successfully applied at least once to a
subterm, {\small\verb%t%} say, then the term into which {\small\verb%t%} is transformed is retraversed by
applying {\small\verb%REDEPTH_CONV c%} to it.

\FAILURE
{\small\verb%REDEPTH_CONV c tm%} never fails but can diverge if the conversion {\small\verb%c%} can be
applied repeatedly to some subterm of {\small\verb%tm%} without failing.

\EXAMPLE
The following example shows how {\small\verb%REDEPTH_CONV%} retraverses subterms:
{\par\samepage\setseps\small
\begin{verbatim}
  # REDEPTH_CONV BETA_CONV `(\f x. (f x) + 1) (\y.y) 2`;;
  val it : thm = |- (\f x. f x + 1) (\y. y) 2 = 2 + 1
\end{verbatim}
}
\noindent Here, {\small\verb%BETA_CONV%} is first applied successfully to the (beta-redex)
subterm:
{\par\samepage\setseps\small
\begin{verbatim}
   `(\f x. (f x) + 1) (\y.y)`
\end{verbatim}
}
\noindent This application reduces this subterm to:
{\par\samepage\setseps\small
\begin{verbatim}
   `(\x. ((\y.y) x) + 1)`
\end{verbatim}
}
\noindent {\small\verb%REDEPTH_CONV BETA_CONV%} is then recursively applied to this
transformed subterm, eventually reducing it to {\small\verb%`(\x. x + 1)`%}. Finally, a
beta-reduction of the top-level term, now the simplified beta-redex
{\small\verb%`(\x. x + 1) 2`%}, produces {\small\verb%`2 + 1`%}.

\SEEALSO
DEPTH_CONV, ONCE_DEPTH_CONV, TOP_DEPTH_CONV, TOP_SWEEP_CONV.

\ENDDOC
\DOC{REDEPTH{\_}SQCONV}

\TYPE {\small\verb%REDEPTH_SQCONV : strategy%}\egroup

\SYNOPSIS
Applies simplification bottom-up to all subterms, retraversing changed ones.

\DESCRIBE
HOL Light's simplification functions (e.g. {\small\verb%SIMP_TAC%}) have their traversal
algorithm controlled by a ``strategy''. {\small\verb%REDEPTH_SQCONV%} is a strategy
corresponding to {\small\verb%REDEPTH_CONV%} for ordinary conversions: simplification is
applied bottom-up to all subterms, retraversing changed ones.

\FAILURE
Not applicable.

\SEEALSO
DEPTH_SQCONV, ONCE_DEPTH_SQCONV, REDEPTH_CONV, TOP_DEPTH_SQCONV,
TOP_SWEEP_SQCONV.

\ENDDOC
\DOC{reduce{\_}interface}

\TYPE {\small\verb%reduce_interface : string * term -> unit%}\egroup

\SYNOPSIS
Remove a specific overload/interface mapping for an identifier.

\DESCRIBE
HOL Light allows an identifier to map to a specific constant (see
{\small\verb%override_interface%}) or be overloaded to several depending on type (see
{\small\verb%overload_interface%}). A call to {\small\verb%remove_interface "ident"%} removes all such
mappings for the identifier {\small\verb%ident%}.

\FAILURE
Never fails, whether or not there were any interface mappings in effect.

\SEEALSO
overload_interface, override_interface, remove_interface, the_interface.

\ENDDOC
\DOC{refine}

\TYPE {\small\verb%refine : refinement -> goalstack%}\egroup

\SYNOPSIS
Applies a refinement to the current goalstack.

\DESCRIBE
The call {\small\verb%refine r%} applies the refinement {\small\verb%r%} to the current goalstate, adding
the resulting goalstate at the head of the current goalstack list. (A goalstate
consists of a list of subgoals as well as justification and metavariable
information.)

\FAILURE
Fails if the refinement fails.

\COMMENTS
Most users will not want to handle refinements explicitly. Usually one just
applies a tactic to the first goal in a goalstate.

\ENDDOC
\DOC{REFL}

\TYPE {\small\verb%REFL : term -> thm%}\egroup

\SYNOPSIS
Returns theorem expressing reflexivity of equality.

\DESCRIBE
{\small\verb%REFL%} maps any term {\small\verb%`t`%} to the corresponding theorem {\small\verb%|- t = t%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REFL `2`;;
  val it : thm = |- 2 = 2

  # REFL `p:bool`;;
  val it : thm = |- p <=> p
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
ALL_CONV, REFL_TAC.

\ENDDOC
\DOC{REFL{\_}TAC}

\TYPE {\small\verb%REFL_TAC : tactic%}\egroup

\SYNOPSIS
Solves a goal that is an equation between alpha-equivalent terms.

\DESCRIBE
When applied to a goal {\small\verb%A ?- t = t'%}, where {\small\verb%t%} and {\small\verb%t'%} are alpha-equivalent,
{\small\verb%REFL_TAC%} completely solves it.
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t = t'
   =============  REFL_TAC

\end{verbatim}
}

\FAILURE
Fails unless the goal is an equation between alpha-equivalent terms.

\SEEALSO
ACCEPT_TAC, MATCH_ACCEPT_TAC, REWRITE_TAC.

\ENDDOC
\DOC{REFUTE{\_}THEN}

\TYPE {\small\verb%REFUTE_THEN : thm_tactic -> goal -> goalstate%}\egroup

\SYNOPSIS
Assume the negation of the goal and apply theorem-tactic to it.

\DESCRIBE
The tactic {\small\verb%REFUTE_THEN ttac%} applied to a goal {\small\verb%g%}, assumes the negation of
the goal and applies {\small\verb%ttac%} to it and a similar goal with a conclusion of {\small\verb%F%}.
More precisely, if the original goal {\small\verb%A ?- u%} is unnegated and {\small\verb%ttac%}'s action
is
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- F
   ========  ttac (ASSUME `~u`)
    B ?- v
\end{verbatim}
}
\noindent then we have
{\par\samepage\setseps\small
\begin{verbatim}
     A ?- u
   ==============  REFUTE_THEN ttac
     B ?- v
\end{verbatim}
}
For example, if {\small\verb%ttac%} is just {\small\verb%ASSUME_TAC%}, this corresponds to a classic
`proof by contradiction':
{\par\samepage\setseps\small
\begin{verbatim}
         A ?- u
   =================  REFUTE_THEN ASSUME_TAC
    A u {~u} ?- F
\end{verbatim}
}
Whatever {\small\verb%ttac%} may be, if the conclusion {\small\verb%u%} of the goal is negated, the
effect is the same except that the assumed theorem will not be double-negated,
so the effect is the same as {\small\verb%DISCH_THEN%}.

\FAILURE
Never fails unless the underlying theorem-tactic {\small\verb%ttac%} does.

\USES
Classical `proof by contradiction'.

\COMMENTS
When applied to an unnegated goal, this tactic embodies implicitly the
classical principle of `proof by contradiction', but for negated goals the
tactic is also intuitionistically valid.

\SEEALSO
BOOL_CASES_TAC, DISCH_THEN.

\ENDDOC
\DOC{remark}

\TYPE {\small\verb%remark : string -> unit%}\egroup

\SYNOPSIS
Output a string and newline if and only if {\small\verb%verbose%} flag is set.

\DESCRIBE
If the {\small\verb%verbose%} flag is set to {\small\verb%true%}, then the call {\small\verb%remark s%} prints the
string {\small\verb%s%} and a following newline. If the {\small\verb%verbose%} flag is set to {\small\verb%false%},
this call does nothing. This function is used for informative output in several
automated rules such as {\small\verb%MESON%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # remark "Proof is going OK so far";;
  Proof is going OK so far
  val it : unit = ()
  # verbose := false;;
  val it : unit = ()
  # remark "Proof is going OK so far";;
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
report, verbose, REMARK_TAC.

\ENDDOC
\DOC{REMARK{\_}TAC}

\TYPE {\small\verb%REMARK_TAC : string -> tactic%}\egroup

\SYNOPSIS
A tactic version of {\small\verb%remark%}.

\DESCRIBE
Given any goal {\small\verb%A ?- p%}, the tactic {\small\verb%REMARK_TAC s%} prints the string s
to standard output.
As {\small\verb%remark%} does, this outputs a string only if {\small\verb%verbose%} flag is set.

\FAILURE
Never fails.

\SEEALSO
PRINT_GOAL_TAC, remark, verbose

\ENDDOC
\DOC{remove}

\TYPE {\small\verb%remove : ('a -> bool) -> 'a list -> 'a * 'a list%}\egroup

\SYNOPSIS
Separates the first element of a list to satisfy a predicate from the rest of
the list.

\FAILURE
Fails if no element satisfies the predicate. This will always be the case for
an empty list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # remove (fun x -> x >= 3) [1;2;3;4;5;6];;
  val it : int * int list = (3, [1; 2; 4; 5; 6])
\end{verbatim}
}

\SEEALSO
partition, filter.

\ENDDOC
\DOC{remove{\_}interface}

\TYPE {\small\verb%remove_interface : string -> unit%}\egroup

\SYNOPSIS
Remove all overload/interface mappings for an identifier.

\DESCRIBE
HOL Light allows an identifier to map to a specific constant (see
{\small\verb%override_interface%}) or be overloaded to several depending on type (see
{\small\verb%overload_interface%}). A call to {\small\verb%remove_interface "ident"%} removes all such
mappings for the identifier {\small\verb%ident%}.

\FAILURE
Never fails, whether or not there were any interface mappings in effect.

\SEEALSO
overload_interface, override_interface, reduce_interface, the_interface.

\ENDDOC
\DOC{REMOVE{\_}THEN}

\TYPE {\small\verb%REMOVE_THEN : string -> thm_tactic -> tactic%}\egroup

\SYNOPSIS
Apply a theorem tactic to named assumption, removing the assumption.

\DESCRIBE
The tactic {\small\verb%REMOVE_THEN "name" ttac%} applies the theorem-tactic {\small\verb%ttac%} to the
assumption labelled {\small\verb%name%} (or the first in the list if there is more than
one), removing the assumption from the goal.

\FAILURE
Fails if there is no assumption of that name or if the theorem-tactic fails
when applied to it.

\EXAMPLE
See {\small\verb%LABEL_TAC%} for a relevant example.

\USES
Using an assumption identified by name that will not be needed again in the
proof.

\SEEALSO
ASSUME, FIND_ASSUM, HYP, LABEL_TAC, USE_THEN.

\ENDDOC
\DOC{remove{\_}type{\_}abbrev}

\TYPE {\small\verb%remove_type_abbrev : string -> unit%}\egroup

\SYNOPSIS
Removes use of name as a type abbreviation.

\DESCRIBE
A call {\small\verb%remove_type_abbrev "s"%} removes any use of {\small\verb%s%} as a type abbreviation,
whether there is one already. Note that since type abbreviations have no
logical status, being only a parsing abbreviation, this has no logical
significance.

\FAILURE
Never fails.

\EXAMPLE
Suppose we set up a type abbreviation:
{\par\samepage\setseps\small
\begin{verbatim}
  # new_type_abbrev("btriple",`:bool#bool#bool`);;
  val it : unit = ()
  # type_abbrevs();;
  val it : (string * hol_type) list = [("btriple", `:bool#bool#bool`)]
\end{verbatim}
}
\noindent We can remove it again:
{\par\samepage\setseps\small
\begin{verbatim}
  # remove_type_abbrev "btriple";;
  val it : unit = ()
  # type_abbrevs();;
  val it : (string * hol_type) list = []
\end{verbatim}
}

\SEEALSO
new_type_abbrev, type_abbrevs.

\ENDDOC
\DOC{repeat}

\TYPE {\small\verb%repeat : ('a -> 'a) -> 'a -> 'a%}\egroup

\SYNOPSIS
Repeatedly apply a function until it fails.

\DESCRIBE
The call {\small\verb%repeat f x%} successively applies {\small\verb%f%} over and over again starting
with {\small\verb%x%}, and stops at the first point when a {\small\verb%Failure _%} exception occurs.

\FAILURE
Never fails. If {\small\verb%f%} fails at once it returns {\small\verb%x%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # repeat (snd o dest_forall) `!x y z. x + y + z < 1`;;
  val it : term = `x + y + z < 1`
\end{verbatim}
}

\COMMENTS
If you know exactly how many times you want to apply it, you may prefer
{\small\verb%funpow%}.

\SEEALSO
funpow, fail.

\ENDDOC
\DOC{REPEATC}

\TYPE {\small\verb%REPEATC : conv -> conv%}\egroup

\SYNOPSIS
Repeatedly apply a conversion (zero or more times) until it fails.

\DESCRIBE
If {\small\verb%c%} is a conversion effects a transformation of a term {\small\verb%t%} to a term {\small\verb%t'%},
that is if {\small\verb%c%} maps {\small\verb%t%} to the theorem {\small\verb%|- t = t`%}, then {\small\verb%REPEATC c%} is the
conversion that repeats this transformation as often as possible.  More
exactly, if {\small\verb%c%} maps the term {\small\verb%`ti`%} to {\small\verb%|- ti=t(i+1)%} for {\small\verb%i%} from {\small\verb%1%} to {\small\verb%n%},
but fails when applied to the {\small\verb%n+1%}th term {\small\verb%`t(n+1)`%}, then {\small\verb%REPEATC c `t1`%}
returns {\small\verb%|- t1 = t(n+1)%}. And if {\small\verb%c `t`%} fails, them {\small\verb%REPEATC c `t`%} returns
{\small\verb%|- t = t%}.

\FAILURE
Never fails, but can diverge if the supplied conversion never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BETA_CONV `(\x. (\y. x + y) (x + 1)) 1`;;
  val it : thm = |- (\x. (\y. x + y) (x + 1)) 1 = (\y. 1 + y) (1 + 1)

  # REPEATC BETA_CONV `(\x. (\y. x + y) (x + 1)) 1`;;
  val it : thm = |- (\x. (\y. x + y) (x + 1)) 1 = 1 + 1 + 1
\end{verbatim}
}

\ENDDOC
\DOC{REPEAT{\_}GTCL}

\TYPE {\small\verb%REPEAT_GTCL : thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Applies a theorem-tactical until it fails when applied to a goal.

\DESCRIBE
When applied to a theorem-tactical, a theorem-tactic, a theorem and a goal:
{\par\samepage\setseps\small
\begin{verbatim}
   REPEAT_GTCL ttl ttac th goal
\end{verbatim}
}
\noindent {\small\verb%REPEAT_GTCL%} repeatedly modifies the theorem according to
{\small\verb%ttl%} till the result of handing it to {\small\verb%ttac%} and applying it to the goal
fails (this may be no times at all).

\FAILURE
Fails iff the theorem-tactic fails immediately when applied to the theorem
and the goal.

\EXAMPLE
The following tactic matches {\small\verb%th%}'s antecedents against the assumptions
of the goal until it can do so no longer, then puts the resolvents
onto the assumption list:
{\par\samepage\setseps\small
\begin{verbatim}
   REPEAT_GTCL IMP_RES_THEN ASSUME_TAC th
\end{verbatim}
}

\SEEALSO
REPEAT_TCL, THEN_TCL.

\ENDDOC
\DOC{REPEAT{\_}TCL}

\TYPE {\small\verb%REPEAT_TCL : thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Repeatedly applies a theorem-tactical until it fails when applied to the
theorem.

\DESCRIBE
When applied to a theorem-tactical, a theorem-tactic and a theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   REPEAT_TCL ttl ttac th
\end{verbatim}
}
\noindent {\small\verb%REPEAT_TCL%} repeatedly modifies the theorem according to {\small\verb%ttl%}
until it fails when given to the theorem-tactic {\small\verb%ttac%}.

\FAILURE
Fails iff the theorem-tactic fails immediately when applied to the theorem.

\EXAMPLE
It is often desirable to repeat the action of basic theorem-tactics. For
example {\small\verb%CHOOSE_THEN%} strips off a single existential quantification, so one
might use {\small\verb%REPEAT_TCL CHOOSE_THEN%} to get rid of them all.

Alternatively, one might want to repeatedly break apart a theorem which is a
nested conjunction and apply the same theorem-tactic to each conjunct. For
example the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(0 = w /\ 0 = x) /\ 0 = y /\ 0 = z ==> w + x + y + z = 0`;;
  Warning: Free variables in goal: w, x, y, z
  val it : goalstack = 1 subgoal (1 total)

  `(0 = w /\ 0 = x) /\ 0 = y /\ 0 = z ==> w + x + y + z = 0`
\end{verbatim}
}
\noindent might be solved by
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN (REPEAT_TCL CONJUNCTS_THEN (SUBST1_TAC o SYM)) THEN
      REWRITE_TAC[ADD_CLAUSES]);;
\end{verbatim}
}

\SEEALSO
REPEAT_GTCL, THEN_TCL.

\ENDDOC
\DOC{REPEAT}

\TYPE {\small\verb%REPEAT : tactic -> tactic%}\egroup

\SYNOPSIS
Repeatedly applies a tactic until it fails.

\DESCRIBE
The tactic {\small\verb%REPEAT t%} is a tactic which applies {\small\verb%t%} to a goal, and while it
succeeds, continues applying it to all subgoals generated.

\FAILURE
The application of {\small\verb%REPEAT%} to a tactic never fails, and neither does the
composite tactic, even if the basic tactic fails immediately, unless it raises
an exception other that {\small\verb%Failure ...%}.

\EXAMPLE
If we start with a goal having many universal quantifiers:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!w x y z. w < z /\ x < y ==> w * x + 1 <= y * z`;;
\end{verbatim}
}
\noindent then {\small\verb%GEN_TAC%} will strip them off one at a time:
{\par\samepage\setseps\small
\begin{verbatim}
  # e GEN_TAC;;
  val it : goalstack = 1 subgoal (1 total)

  `!x y z. w < z /\ x < y ==> w * x + 1 <= y * z`
\end{verbatim}
}
\noindent and {\small\verb%REPEAT GEN_TAC%} will strip them off as far as possible:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `w < z /\ x < y ==> w * x + 1 <= y * z`
\end{verbatim}
}
Similarly, {\small\verb%REPEAT COND_CASES_TAC%} will eliminate all free conditionals in the
goal instead of just one.

\SEEALSO
EVERY, FIRST, ORELSE, THEN, THENL.

\ENDDOC
\DOC{replicate}

\TYPE {\small\verb%replicate : 'a -> int -> 'a list%}\egroup

\SYNOPSIS
Makes a list consisting of a value replicated a specified number of times.

\DESCRIBE
{\small\verb%replicate x n%} returns {\small\verb%[x;...;x]%}, a list of length {\small\verb%n%}.

\FAILURE
Fails if number of replications is less than zero.

\ENDDOC
\DOC{REPLICATE{\_}TAC}

\TYPE {\small\verb%REPLICATE_TAC : int -> tactic -> tactic%}\egroup

\SYNOPSIS
Apply a tactic a specific number of times.

\DESCRIBE
The call {\small\verb%REPLICATE n tac%} gives a new tactic that it equivalent to an {\small\verb%n%}-fold
repetition of {\small\verb%tac%}, i.e. {\small\verb%tac THEN tac THEN ... THEN tac%}.

\FAILURE
The call {\small\verb%REPLICATE n tac%} never fails, but when applied to a goal it will fail
if the tactic does.

\EXAMPLE
We might conceivably want to strip off exactly three universal quantifiers from
a goal that contains more than three. We can use {\small\verb%REPLICATE_TAC 3 GEN_TAC%} to
do that.

\SEEALSO
EVERY, MAP_EVERY, THEN.

\ENDDOC
\DOC{report}

\TYPE {\small\verb%report : string -> unit%}\egroup

\SYNOPSIS
Prints a string and a following line break.

\DESCRIBE
The call {\small\verb%report s%} prints the string {\small\verb%s%} to the terminal and then a following
newline.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # report "Proof completed OK";;
  Proof completed OK
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
remark, warn.

\ENDDOC
\DOC{report{\_}timing}

\TYPE {\small\verb%report_timing : bool ref%}\egroup

\SYNOPSIS
Flag to determine whether {\small\verb%time%} function outputs CPU time measure.

\DESCRIBE
When {\small\verb%report_timing%} is true, a call {\small\verb%time f x%} will evaluate {\small\verb%f x%} as usual
but also as a side-effect print out the CPU time taken. If {\small\verb%report_timing%} is
false, nothing will be printed. Times are already printed in this way
automatically as informative output in some rules like {\small\verb%MESON%}, so this can be
used to silence them.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # time NUM_REDUCE_CONV `2 EXP 300 < 2 EXP 200`;;
  CPU time (user): 0.13
  val it : thm = |- 2 EXP 300 < 2 EXP 200 <=> F
  # report_timing := false;;
  val it : unit = ()
  # time NUM_REDUCE_CONV `2 EXP 300 < 2 EXP 200`;;
  val it : thm = |- 2 EXP 300 < 2 EXP 200 <=> F
\end{verbatim}
}

\SEEALSO
time.

\ENDDOC
\DOC{reserved{\_}words}

\TYPE {\small\verb%reserved_words : unit -> string list%}\egroup

\SYNOPSIS
Returns the list of reserved words.

\DESCRIBE
Certain identifiers in HOL are reserved, e.g. `{\small\verb%if%}', `{\small\verb%let%}' and `{\small\verb%|%}',
meaning that they are special to the parser and cannot be used as ordinary
identifiers. The call {\small\verb%reserved_words()%} returns a list of such identifiers.

\FAILURE
Never fails.

\EXAMPLE
In the default HOL state:
{\par\samepage\setseps\small
\begin{verbatim}
  # reserved_words();;
  val it : string list =
    ["("; ")"; "["; "]"; "{\small\verb%"; "%}"; ":"; ";"; "."; "|"; "let"; "in"; "and";
     "if"; "then"; "else"; "//"]
\end{verbatim}
}

\SEEALSO
is_reserved_word, reserve_words, unreserve_words.

\ENDDOC
\DOC{reserve{\_}words}

\TYPE {\small\verb%reserve_words : string list -> unit%}\egroup

\SYNOPSIS
Add given strings to the set of reserved words.

\DESCRIBE
Certain identifiers in HOL are reserved, e.g. `{\small\verb%if%}', `{\small\verb%let%}' and `{\small\verb%|%}',
meaning that they are special to the parser and cannot be used as ordinary
identifiers. A call {\small\verb%reserve_words l%} adds all strings in {\small\verb%l%} to the list of
reserved identifiers.

\FAILURE
Never fails, regardless of whether the given strings were already reserved.

\SEEALSO
is_reserved_word, reserved_words, unreserve_words.

\ENDDOC
\DOC{retypecheck}

\TYPE {\small\verb%retypecheck : (string * pretype) list -> preterm -> preterm%}\egroup

\SYNOPSIS
Typecheck a term, iterating over possible overload resolutions.

\DESCRIBE
This is the main HOL Light typechecking function. Given an environment {\small\verb%env%} of
pretype assignments for variables, it assigns a pretype to all variables and
constants, including performing resolution of overloaded constants based on
what type information there is. Normally, this happens implicitly when a term
is entered in the quotation parser.

\FAILURE
Fails if some terms cannot be consistently assigned a type.

\COMMENTS
Only users seeking to change HOL's parser and typechecker quite radically need
to use this function.

\SEEALSO
term_of_preterm.

\ENDDOC
\DOC{rev}

\TYPE {\small\verb%rev : 'a list -> 'a list%}\egroup

\SYNOPSIS
Reverses a list.

\DESCRIBE
{\small\verb%rev [x1;...;xn]%} returns {\small\verb%[xn;...;x1]%}.

\FAILURE
Never fails.

\ENDDOC
\DOC{REVERSE{\_}CONV}

\TYPE {\small\verb%REVERSE_CONV : conv%}\egroup

\SYNOPSIS
Evaluate the list reversal function applied to a specific list.

\DESCRIBE
When applied to a term {\small\verb%`REVERSE [t1; ...; tn]`%} with a concrete list (though
not necessarily with constant or ground elements) the conversion {\small\verb%REVERSE_CONV%}
returns the appropriate theorem {\small\verb%|- REVERSE [t1; ...; tn] = [tn; ...; t1]%}.

\FAILURE
Fails if the term is not of the expected form.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # REVERSE_CONV `REVERSE [1;2;3]`;;
  val it : thm = |- REVERSE [1; 2; 3] = [3; 2; 1]

  # REVERSE_CONV `REVERSE [one;two;three]`;;
  val it : thm = |- REVERSE [one; two; three] = [three; two; one]
\end{verbatim}
}

\SEEALSO
EL_CONV, LENGTH_CONV, LIST_CONV, LIST_OF_SEQ_CONV.

\ENDDOC
\DOC{reverse{\_}interface{\_}mapping}

\TYPE {\small\verb%reverse_interface_mapping : bool ref%}\egroup

\SYNOPSIS
Determines whether interface map is printed on output (default {\small\verb%true%}).

\DESCRIBE
The reference variable {\small\verb%reverse_interface_mapping%} is one of several settable
parameters controlling printing of terms by {\small\verb%pp_print_term%}, and hence the
automatic printing of terms and theorems at the toplevel. When
{\small\verb%reverse_interface_mapping%} is {\small\verb%true%} (as it is by default), the front-end
interface map for a constant or variable is printed. When it is {\small\verb%false%}, the
core constant or variable is printed.

\FAILURE
Not applicable.

\EXAMPLE
Here is a simple library theorem about real numbers as it usually appears:
{\par\samepage\setseps\small
\begin{verbatim}
  # reverse_interface_mapping := true;;
  val it : unit = ()
  # REAL_EQ_SUB_LADD;;
  val it : thm = |- !x y z. x = y - z <=> x + z = y
\end{verbatim}
}
\noindent but with another setting of {\small\verb%reverse_interface_mapping%} we see that
the usual symbol `{\small\verb%+%}' is an interface for {\small\verb%real_add%}, while the `iff' sign is
just an interface for Boolean equality:
{\par\samepage\setseps\small
\begin{verbatim}
  # reverse_interface_mapping := false;;
  val it : unit = ()
  # REAL_EQ_SUB_LADD;;
  val it : thm = |- !x y z. (x = real_sub y z) = real_add x z = y
\end{verbatim}
}

\SEEALSO
pp_print_term, prebroken_binops, print_all_thm,
print_unambiguous_comprehensions, the_interface, typify_universal_set,
unspaced_binops.

\ENDDOC
\DOC{rev{\_}assoc}

\TYPE {\small\verb%rev_assoc : 'a -> ('b * 'a) list -> 'b%}\egroup

\SYNOPSIS
Searches a list of pairs for a pair whose second component equals a specified
value.

\DESCRIBE
{\small\verb%rev_assoc y [(x1,y1);...;(xn,yn)]%} returns the first {\small\verb%xi%} in the list
such that {\small\verb%yi%} equals {\small\verb%y%}.

\FAILURE
Fails if no matching pair is found. This will always be the case if the list
is empty.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rev_assoc 2 [(1,4);(3,2);(2,5);(2,6)];;
  val it : int = 3
\end{verbatim}
}

\SEEALSO
assoc, find, mem, tryfind, exists, forall.

\ENDDOC
\DOC{rev{\_}assocd}

\TYPE {\small\verb%rev_assocd : 'a -> ('b * 'a) list -> 'b -> 'b%}\egroup

\SYNOPSIS
Looks up item in association list taking default in case of failure.

\DESCRIBE
The call {\small\verb%rev_assocd y [x1,y1; ...; xn,yn] x%} returns the first {\small\verb%xi%} in the
list where the corresponding {\small\verb%yi%} is the same as {\small\verb%y%}. If there is no such item,
it returns the value {\small\verb%x%}. This is similar to {\small\verb%rev_assoc%} except that the latter
will fail rather than take a default.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rev_assocd 6 [1,2; 2,4; 3,6] (-1);;
  val it : int = 3
  # rev_assocd 8 [1,2; 2,4; 3,6] (-1);;
  val it : int = -1
\end{verbatim}
}

\USES
Simple lookup without exception handling.

\SEEALSO
assocd, rev_assoc.

\ENDDOC
\DOC{rev{\_}itlist}

\TYPE {\small\verb%rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b%}\egroup

\SYNOPSIS
Applies a binary function between adjacent elements of the reverse of a list.

\DESCRIBE
{\small\verb%rev_itlist f [x1;...;xn] y%} returns {\small\verb%f xn ( ... (f x2 (f x1 y))...)%}.
It returns {\small\verb%y%} if the list is empty.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rev_itlist (fun x y -> x * y) [1;2;3;4] 1;;
  val it : int = 24
\end{verbatim}
}

\SEEALSO
itlist, end_itlist.

\ENDDOC
\DOC{rev{\_}itlist2}

\TYPE {\small\verb%rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c%}\egroup

\SYNOPSIS
Applies a paired function between adjacent elements of 2 lists.

\DESCRIBE
{\small\verb%itlist2 f ([x1;...;xn],[y1;...;yn]) z%} returns
{\par\samepage\setseps\small
\begin{verbatim}
   f xn yn ( ... (f x2 y2 (f x1 y1 z))...)%}.
\end{verbatim}
}
\noindent It returns {\small\verb%z%} if both lists are empty.

\FAILURE
Fails if the two lists are of different lengths.

\EXAMPLE
This takes a `dot product' of two vectors of integers:
{\par\samepage\setseps\small
\begin{verbatim}
  # let dot v w = rev_itlist2 (fun x y z -> x * y + z) v w 0;;
  val dot : int list -> int list -> int = <fun>
  # dot [1;2;3] [4;5;6];;
  val it : int = 32
\end{verbatim}
}
\SEEALSO
itlist, rev_itlist, rev_itlist2, end_itlist, uncurry.

\ENDDOC
\DOC{rev{\_}splitlist}

\TYPE {\small\verb%rev_splitlist : ('a -> 'a * 'b) -> 'a -> 'a * 'b list%}\egroup

\SYNOPSIS
Applies a binary destructor repeatedly in right-associative mode.

\DESCRIBE
If a destructor function {\small\verb%d%} inverts a binary constructor {\small\verb%f%}, for example
{\small\verb%dest_comb%} for {\small\verb%mk_comb%}, and fails when applied to {\small\verb%y%}, then:
{\par\samepage\setseps\small
\begin{verbatim}
  rev_splitlist d f(...(f(f(w,x1),x2),...xn)
\end{verbatim}
}
\noindent returns
{\par\samepage\setseps\small
\begin{verbatim}
  (w,[x1; ... ; xn])
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
The function {\small\verb%strip_comb%} is actually just defined as
{\small\verb%rev_splitlist dest_comb%}, which acts as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # rev_splitlist dest_comb `x + 1 + 2`;;
  val it : term * term list = (`(+)`, [`x`; `1 + 2`])
\end{verbatim}
}

\SEEALSO
itlist, nsplit, splitlist, striplist.

\ENDDOC
\DOC{REWRITES{\_}CONV}

\TYPE {\small\verb%REWRITES_CONV : ('a * (term -> 'b)) net -> term -> 'b%}\egroup

\SYNOPSIS
Apply a prioritized conversion net to the term at the top level.

\DESCRIBE
The underlying machinery in rewriting and simplification assembles
(conditional) rewrite rules and other conversions into a net, including a
priority number so that, for example, pure rewrites get applied before
conditional rewrites. If {\small\verb%net%} is such a net (for example, constructed using
{\small\verb%mk_rewrites%} and {\small\verb%net_of_thm%}), then {\small\verb%REWRITES_CONV net%} is a conversion that
uses all those conversions at the toplevel to attempt to rewrite the term. If a
conditional rewrite is applied, the resulting theorem will have an assumption.
This is the primitive operation that performs HOL Light rewrite steps.

\FAILURE
Fails when applied to the term if none of the conversions in the net are
applicable.

\SEEALSO
GENERAL_REWRITE_CONV, GEN_REWRITE_CONV, mk_rewrites, net_of_conv, net_of_thm,
REWRITE_CONV.

\ENDDOC
\DOC{REWRITE{\_}CONV}

\TYPE {\small\verb%REWRITE_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Rewrites a term including built-in tautologies in the list of rewrites.

\DESCRIBE
Rewriting a term using {\small\verb%REWRITE_CONV%} utilizes as rewrites two sets
of theorems: the tautologies in the ML list {\small\verb%basic_rewrites%} and the
ones supplied by the user. The rule searches top-down and recursively
for subterms which match the left-hand side of any of the possible
rewrites, until none of the transformations are applicable. There is no
ordering specified among the set of rewrites.

Variants of this conversion allow changes in the set of equations used:
{\small\verb%PURE_REWRITE_CONV%} and others in its family do not rewrite with the
theorems in {\small\verb%basic_rewrites%}.

The top-down recursive search for matches may not be desirable, as
this may increase the number of inferences being made or may result in
divergence. In this case other rewriting tools such as
{\small\verb%ONCE_REWRITE_CONV%} and {\small\verb%GEN_REWRITE_CONV%} can be used, or the set of
theorems given may be reduced.

See {\small\verb%GEN_REWRITE_CONV%} for the general strategy for simplifying
theorems in HOL using equational theorems.

\FAILURE
Does not fail, but may diverge if the sequence of rewrites is
non-terminating.

\USES
Used to manipulate terms by rewriting them with theorems.
While resulting in high degree of automation, {\small\verb%REWRITE_CONV%} can
spawn a large number of inference steps. Thus, variants such
as {\small\verb%PURE_REWRITE_CONV%}, or other rules such as {\small\verb%SUBS_CONV%}, may be used
instead to improve efficiency.

\SEEALSO
basic_rewrites, GEN_REWRITE_CONV, ONCE_REWRITE_CONV,
PURE_REWRITE_CONV, REWR_CONV, SUBS_CONV.

\ENDDOC
\DOC{REWRITE{\_}RULE}

\TYPE {\small\verb%REWRITE_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Rewrites a theorem including built-in tautologies in the list of rewrites.

\DESCRIBE
Rewriting a theorem using {\small\verb%REWRITE_RULE%} utilizes as rewrites two sets
of theorems: the tautologies in the ML list {\small\verb%basic_rewrites%} and the
ones supplied by the user. The rule searches top-down and recursively
for subterms which match the left-hand side of any of the possible
rewrites, until none of the transformations are applicable. There is no
ordering specified among the set of rewrites.

Variants of this rule allow changes in the set of equations used:
{\small\verb%PURE_REWRITE_RULE%} and others in its family do not rewrite with the
theorems in {\small\verb%basic_rewrites%}. Rules such as {\small\verb%ASM_REWRITE_RULE%} add the
assumptions of the object theorem (or a specified subset of these assumptions)
to the set of possible rewrites.

The top-down recursive search for matches may not be desirable, as
this may increase the number of inferences being made or may result in
divergence. In this case other rewriting tools such as
{\small\verb%ONCE_REWRITE_RULE%} and {\small\verb%GEN_REWRITE_RULE%} can be used, or the set of
theorems given may be reduced.

See {\small\verb%GEN_REWRITE_RULE%} for the general strategy for simplifying
theorems in HOL using equational theorems.

\FAILURE
Does not fail, but may diverge if the sequence of rewrites is
non-terminating.

\USES
Used to manipulate theorems by rewriting them with other theorems.
While resulting in high degree of automation, {\small\verb%REWRITE_RULE%} can
spawn a large number of inference steps. Thus, variants such
as {\small\verb%PURE_REWRITE_RULE%}, or other rules such as {\small\verb%SUBST%}, may be used
instead to improve efficiency.

\SEEALSO
ASM_REWRITE_RULE, basic_rewrites, GEN_REWRITE_RULE, ONCE_REWRITE_RULE,
PURE_REWRITE_RULE, REWR_CONV, REWRITE_CONV, SUBST.

\ENDDOC
\DOC{REWRITE{\_}TAC}

\TYPE {\small\verb%REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Rewrites a goal including built-in tautologies in the list of rewrites.

\DESCRIBE
Rewriting tactics in HOL provide a recursive left-to-right matching
and rewriting facility that automatically decomposes subgoals and
justifies segments of proof in which equational theorems are used,
singly or collectively.  These include the unfolding of definitions,
and the substitution of equals for equals.  Rewriting is used either
to advance or to complete the decomposition of subgoals.

{\small\verb%REWRITE_TAC%} transforms (or solves) a goal by using as rewrite rules
(i.e. as left-to-right replacement rules) the conclusions of the given
list of (equational) theorems, as well as a set of built-in theorems
(common tautologies) held in the ML variable {\small\verb%basic_rewrites%}.
Recognition of a tautology often terminates the subgoaling process
(i.e. solves the goal).

The equational rewrites generated are applied recursively and to
arbitrary depth, with matching and instantiation of variables and type
variables.  A list of rewrites can set off an infinite rewriting
process, and it is not, of course, decidable in general whether a
rewrite set has that property. The order in which the rewrite theorems
are applied is unspecified, and the user should not depend on any
ordering.

See {\small\verb%GEN_REWRITE_TAC%} for more details on the rewriting process.
Variants of {\small\verb%REWRITE_TAC%} allow the use of a different set of
rewrites. Some of them, such as {\small\verb%PURE_REWRITE_TAC%}, exclude the basic
tautologies from the possible transformations. {\small\verb%ASM_REWRITE_TAC%} and
others include the assumptions at the goal in the set of possible
rewrites.

Still other tactics allow greater control over the search for
rewritable subterms. Several of them such as {\small\verb%ONCE_REWRITE_TAC%} do not
apply rewrites recursively. {\small\verb%GEN_REWRITE_TAC%} allows a rewrite to be
applied at a particular subterm.

\FAILURE
{\small\verb%REWRITE_TAC%} does not fail. Certain sets of rewriting theorems on
certain goals may cause a non-terminating sequence of rewrites.
Divergent rewriting behaviour results from a term {\small\verb%t%} being
immediately or eventually rewritten to a term containing {\small\verb%t%} as a
sub-term. The exact behaviour depends on the {\small\verb%HOL%} implementation; it
may be possible (unfortunately) to fall into Lisp in this event.

\EXAMPLE
The arithmetic theorem {\small\verb%GT%}, {\small\verb%|- !n m. m > n <=> n < m%}, is used below to
advance a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `4 < 5`;;
  val it : goalstack = 1 subgoal (1 total)

  `4 < 5`

  # e(REWRITE_TAC[GT]);;
  val it : goalstack = 1 subgoal (1 total)

  `4 < 5`
\end{verbatim}
}
\noindent It is used below with the theorem {\small\verb%LT_0%}, {\small\verb%|- !n. 0 < SUC n%}, to
solve a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `SUC n > 0`;;
  Warning: Free variables in goal: n
  val it : goalstack = 1 subgoal (1 total)

  `SUC n > 0`

  # e(REWRITE_TAC[GT; LT_0]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Rewriting is a powerful and general mechanism in HOL, and an
important part of many proofs.  It relieves the user of the burden of
directing and justifying a large number of minor proof steps.
{\small\verb%REWRITE_TAC%} fits a forward proof sequence smoothly into the general
goal-oriented framework. That is, (within one subgoaling step) it
produces and justifies certain forward inferences, none of which are
necessarily on a direct path to the desired goal.

{\small\verb%REWRITE_TAC%} may be more powerful a tactic than is needed in certain
situations; if efficiency is at stake, alternatives might be
considered.

\SEEALSO
ASM_REWRITE_TAC, GEN_REWRITE_TAC, IMP_REWRITE_TAC, ONCE_ASM_REWRITE_TAC,
ONCE_REWRITE_TAC, PURE_ASM_REWRITE_TAC, PURE_ONCE_ASM_REWRITE_TAC,
PURE_ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWR_CONV, REWRITE_CONV,
SUBST_ALL_TAC, SUBST1_TAC, TARGET_REWRITE_TAC.

\ENDDOC
\DOC{REWR{\_}CONV}

\TYPE {\small\verb%REWR_CONV : thm -> term -> thm%}\egroup

\SYNOPSIS
Uses an instance of a given equation to rewrite a term.

\DESCRIBE
{\small\verb%REWR_CONV%} is one of the basic building blocks for the implementation of
rewriting in the HOL system. In particular, the term replacement or rewriting
done by all the built-in rewriting rules and tactics is ultimately done by
applications of {\small\verb%REWR_CONV%} to appropriate subterms.  The description given
here for {\small\verb%REWR_CONV%} may therefore be taken as a specification of the atomic
action of replacing equals by equals that is used in all these higher level
rewriting tools.

The first argument to {\small\verb%REWR_CONV%} is expected to be an equational theorem
which is to be used as a left-to-right rewrite rule.  The general form of this
theorem is:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[x1,...,xn] = u[x1,...,xn]
\end{verbatim}
}
\noindent where {\small\verb%x1%}, ..., {\small\verb%xn%} are all the variables that occur free in the
left-hand side of the conclusion of the theorem but do not occur free in the
assumptions. Any of these variables may also be universally quantified at the
outermost level of the equation, as for example in:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- !x1...xn. t[x1,...,xn] = u[x1,...,xn]
\end{verbatim}
}
\noindent Note that {\small\verb%REWR_CONV%} will also work, but will give a generally
undesirable result (see below), if the right-hand side of the equation contains
free variables that do not also occur free on the left-hand side, as for
example in:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[x1,...,xn] = u[x1,...,xn,y1,...,ym]
\end{verbatim}
}
\noindent where the variables {\small\verb%y1%}, ..., {\small\verb%ym%} do not occur free in
{\small\verb%t[x1,...,xn]%}.

If {\small\verb%th%} is an equational theorem of the kind shown above, then
{\small\verb%REWR_CONV th%} returns a conversion that maps terms of the form
{\small\verb%t[e1,...,en/x1,...,xn]%}, in which the terms {\small\verb%e1%}, ..., {\small\verb%en%} are free for
{\small\verb%x1%}, ..., {\small\verb%xn%} in {\small\verb%t%}, to theorems of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[e1,...,en/x1,...,xn] = u[e1,...,en/x1,...,xn]
\end{verbatim}
}
\noindent That is, {\small\verb%REWR_CONV th tm%} attempts to match the left-hand side of
the rewrite rule {\small\verb%th%} to the term {\small\verb%tm%}.  If such a match is possible, then
{\small\verb%REWR_CONV%} returns the corresponding substitution instance of {\small\verb%th%}.

If {\small\verb%REWR_CONV%} is given a theorem {\small\verb%th%}:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[x1,...,xn] = u[x1,...,xn,y1,...,ym]
\end{verbatim}
}
\noindent where the variables {\small\verb%y1%}, ..., {\small\verb%ym%} do not occur free in the
left-hand side, then the result of applying the conversion {\small\verb%REWR_CONV th%} to
a term {\small\verb%t[e1,...,en/x1,...,xn]%} will be:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[e1,...,en/x1,...,xn] = u[e1,...,en,v1,...,vm/x1,...,xn,y1,...,ym]
\end{verbatim}
}
\noindent where {\small\verb%v1%}, ..., {\small\verb%vm%} are variables chosen so as to be free nowhere
in {\small\verb%th%} or in the input term.  The user has no control over the choice of the
variables {\small\verb%v1%}, ..., {\small\verb%vm%}, and the variables actually chosen may well be
inconvenient for other purposes.  This situation is, however, relatively rare;
in most equations the free variables on the right-hand side are a subset of the
free variables on the left-hand side.

In addition to doing substitution for free variables in the supplied equational
theorem (or `rewrite rule'), {\small\verb%REWR_CONV th tm%} also does type instantiation,
if this is necessary in order to match the left-hand side of the given rewrite
rule {\small\verb%th%} to the term argument {\small\verb%tm%}.  If, for example, {\small\verb%th%} is the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- t[x1,...,xn] = u[x1,...,xn]
\end{verbatim}
}
\noindent and the input term {\small\verb%tm%} is (a substitution instance of) an instance
of {\small\verb%t[x1,...,xn]%} in which the types {\small\verb%ty1%}, ..., {\small\verb%tyi%} are substituted for the
type variables {\small\verb%vty1%}, ..., {\small\verb%vtyi%}, that is if:
{\par\samepage\setseps\small
\begin{verbatim}
   tm = t[ty1,...,tyn/vty1,...,vtyn][e1,...,en/x1,...,xn]
\end{verbatim}
}
\noindent then {\small\verb%REWR_CONV th tm%} returns:
{\par\samepage\setseps\small
\begin{verbatim}
   A |- (t = u)[ty1,...,tyn/vty1,...,vtyn][e1,...,en/x1,...,xn]
\end{verbatim}
}
\noindent Note that, in this case, the type variables {\small\verb%vty1%}, ..., {\small\verb%vtyi%} must
not occur anywhere in the hypotheses {\small\verb%A%}.  Otherwise, the conversion will fail.

\FAILURE
{\small\verb%REWR_CONV th%} fails if {\small\verb%th%} is not an equation or an equation universally
quantified at the outermost level.  If {\small\verb%th%} is such an equation:
{\par\samepage\setseps\small
\begin{verbatim}
  th = A |- !v1....vi. t[x1,...,xn] = u[x1,...,xn,y1,...,yn]
\end{verbatim}
}
\noindent then {\small\verb%REWR_CONV th tm%} fails unless the term {\small\verb%tm%} is
alpha-equivalent to an instance of the left-hand side {\small\verb%t[x1,...,xn]%} which
can be obtained by instantiation of free type variables (i.e. type variables
not occurring in the assumptions {\small\verb%A%}) and substitution for the free variables
{\small\verb%x1%}, ..., {\small\verb%xn%}.

\EXAMPLE
The following example illustrates a straightforward use of {\small\verb%REWR_CONV%}.
The supplied rewrite rule is polymorphic, and both substitution for free
variables and type instantiation may take place.  {\small\verb%EQ_SYM_EQ%} is the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- !x y:A. x = y <=> y = x
\end{verbatim}
}
\noindent and {\small\verb%REWR_CONV EQ_SYM%} behaves as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWR_CONV EQ_SYM_EQ `1 = 2`;;
  val it : thm = |- 1 = 2 <=> 2 = 1
  # REWR_CONV EQ_SYM_EQ `1 < 2`;;
  Exception: Failure "term_pmatch".
\end{verbatim}
}
\noindent The second application fails because the left-hand side {\small\verb%`x = y`%} of
the rewrite rule does not match the term to be rewritten, namely {\small\verb%`1 < 2`%}.

In the following example, one might expect the result to be the theorem
{\small\verb%A |- f 2 = 2%}, where {\small\verb%A%} is the assumption of the supplied rewrite rule:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWR_CONV (ASSUME `!x:A. f x = x`) `f 2:num`;;
  Exception: Failure "term_pmatch: can't instantiate local constant".
\end{verbatim}
}
\noindent The application fails, however, because the type variable {\small\verb%A%} appears
in the assumption of the theorem returned by {\small\verb%ASSUME `!x:A. f x = x`%}.

Failure will also occur in situations like:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWR_CONV (ASSUME `f (n:num) = n`) `f 2:num`;;
  Exception: Failure "term_pmatch: can't instantiate local constant".
\end{verbatim}
}
\noindent where the left-hand side of the supplied equation contains a free
variable (in this case {\small\verb%n%}) which is also free in the assumptions, but which
must be instantiated in order to match the input term.

\SEEALSO
IMP_REWR_CONV, ORDERED_REWR_CONV, REWRITE_CONV.

\ENDDOC
\DOC{rhs}

\TYPE {\small\verb%rhs : term -> term%}\egroup

\SYNOPSIS
Returns the right-hand side of an equation.

\DESCRIBE
{\small\verb%rhs `t1 = t2`%} returns {\small\verb%`t2`%}.

\FAILURE
Fails with {\small\verb%rhs%} if term is not an equality.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # rhs `2 + 2 = 4`;;
  val it : term = `4`
\end{verbatim}
}

\SEEALSO
dest_eq, lhs, rand.

\ENDDOC
\DOC{rightbin}

\TYPE {\small\verb%rightbin : ('a -> 'b * 'c) -> ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c%}\egroup

\SYNOPSIS
Parses iterated right-associated binary operator.

\DESCRIBE
If {\small\verb%p%} is a parser for ``items'' of some kind, {\small\verb%s%} is a parser for some
``separator'', {\small\verb%c%} is a `constructor' function taking an element as parsed by
{\small\verb%s%} and two other elements as parsed by {\small\verb%p%} and giving a new such element, and
{\small\verb%e%} is an error message, then {\small\verb%rightbin p s c e%} will parse an iterated sequence
of items by {\small\verb%p%} and separated by something parsed with {\small\verb%s%}. It will repeatedly
apply the constructor function {\small\verb%c%} to compose these elements into one,
associating to the right. For example, the input:
{\par\samepage\setseps\small
\begin{verbatim}
  <p1> <s1> <p2> <s2> <p3> <s3> <p4>
\end{verbatim}
}
meaning successive segments {\small\verb%pi%} that are parsed by {\small\verb%p%} and {\small\verb%sj%} that are
parsed by {\small\verb%s%}, will result in
{\par\samepage\setseps\small
\begin{verbatim}
  c s1 c1 (c s2 p2 (c s3 p3 p4))
\end{verbatim}
}

\FAILURE
The call {\small\verb%rightbin p s c e%} never fails, though the resulting parser may.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, some.

\ENDDOC
\DOC{RIGHT{\_}BETAS}

\TYPE {\small\verb%RIGHT_BETAS : term list -> thm -> thm%}\egroup

\SYNOPSIS
Apply and beta-reduce equational theorem with abstraction on RHS.

\DESCRIBE
Given a list of arguments {\small\verb%[`a1`; ...; `an`]%} and a theorem of the form
{\small\verb%A |- f = \x1 ... xn. t[x1,...xn]%}, the rule {\small\verb%RIGHT_BETAS%} returns
{\small\verb%A |- f a1 ... an = t[a1,...,an]%}. That is, it applies the theorem to the list
of arguments and beta-reduces the right-hand side.

\FAILURE
Fails if the argument types are wrong or the RHS has too few abstractions.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # RIGHT_BETAS [`x:num`; `y:num`] (ASSUME `f = \a b c. a + b + c + 1`);;
  val it : thm = f = (\a b c. a + b + c + 1) |- f x y = (\c. x + y + c + 1)
\end{verbatim}
}

\SEEALSO
BETA_CONV, BETAS_CONV.

\ENDDOC
\DOC{RING}

\TYPE {\small\verb%RING : (term -> num) * (num -> term) * conv * term * term * term * term * term * term * term * thm * thm * (term -> thm) -> term -> thm%}\egroup

\SYNOPSIS
Generic ring procedure.

\DESCRIBE
The {\small\verb%RING%} function takes a number of arguments specifying a ring structure and
giving operations for computing and proving over it. Specifically the call is:
{\par\samepage\setseps\small
\begin{verbatim}
  RING(toterm,tonum,EQ_CONV,
       neg,add,sub,inv,mul,div,pow,
       INTEGRAL_TH,FIELD_TH,POLY_CONV)
\end{verbatim}
}
\noindent where {\small\verb%toterm%} is a conversion from constant terms in the structure
to rational numbers (e.g. {\small\verb%rat_of_term%} for the reals), {\small\verb%tonum%} is the opposite
(e.g. {\small\verb%term_of_rat%} for the reals), {\small\verb%EQ_CONV%} is an equality test conversion
(e.g. {\small\verb%REAL_RAT_EQ_CONV%}), {\small\verb%neg%} is negation, {\small\verb%add%} is addition, {\small\verb%sub%} is
subtraction, {\small\verb%inv%} is multiplicative inverse, {\small\verb%div%} is division, {\small\verb%pow%} is
power, {\small\verb%INTEGRAL_TH%} is an integrality theorem and {\small\verb%FIELD_TH%} is a field
theorem (see below) and {\small\verb%POLY_CONV%} is a polynomial normalization theorem for
the structure as returned by {\small\verb%SEMIRING_NORMALIZERS_CONV%} (e.g. {\small\verb%REAL_POLY_CONV%}
for the reals).

The integrality theorem essentially states that if a product is zero, so is one
of the factors (i.e. the structure is an integral domain), but this is stated
in an unnatural way to allow application to structures without negation. It is
permissible in this case to use boolean variables instead of operators such as
negation and subtraction. The precise form of the theorem (notation for natural
numbers, but this is supposed to be over the same structure):
{\par\samepage\setseps\small
\begin{verbatim}
  |- (!x. 0 * x = 0) /\
     (!x y z. x + y = x + z <=> y = z) /\
     (!w x y z. w * y + x * z = w * z + x * y <=> w = x \/ y = z)
\end{verbatim}
}

The field theorem is of the following form. It is not logically necessary, and
if the structure is not a field you can just pass in {\small\verb%TRUTH%} instead. However,
it is usually beneficial for performance to include it.
{\par\samepage\setseps\small
\begin{verbatim}
  |- !x y. ~(x = y) <=> ?z. (x - y) * z = 1
\end{verbatim}
}

It returns a proof procedure that will attempt to prove a formula that, after
suitable normalization, can be considered a universally quantified Boolean
combination of equations and inequations between terms of the right type. If
that formula holds in all integral domains, it will prove it. Any ``alien''
atomic formulas that are not natural number equations will not contribute to
the proof.

\FAILURE
Fails if the theorems are malformed.

\EXAMPLE
The instantiation for the real numbers (in fact this is already available under
the name {\small\verb%REAL_RING%}) could be coded as:
{\par\samepage\setseps\small
\begin{verbatim}
  let REAL_RING =
    let REAL_INTEGRAL = prove
     (`(!x. &0 * x = &0) /\
       (!x y z. (x + y = x + z) <=> (y = z)) /\
       (!w x y z. (w * y + x * z = w * z + x * y) <=> (w = x) \/ (y = z))`,
      REWRITE_TAC[MULT_CLAUSES; EQ_ADD_LCANCEL] THEN
      REWRITE_TAC[GSYM REAL_OF_NUM_EQ;
                  GSYM REAL_OF_NUM_ADD; GSYM REAL_OF_NUM_MUL] THEN
      ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN
      REWRITE_TAC[GSYM REAL_ENTIRE] THEN REAL_ARITH_TAC)
    and REAL_INVERSE = prove
     (`!x y:real. ~(x = y) <=> ?z. (x - y) * z = &1`,
      REPEAT GEN_TAC THEN
      GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [GSYM REAL_SUB_0] THEN
      MESON_TAC[REAL_MUL_RINV; REAL_MUL_LZERO; REAL_ARITH `~(&1 = &0)`]) in
    RING(rat_of_term,term_of_rat,REAL_RAT_EQ_CONV,
         `(--):real->real`,`(+):real->real->real`,`(-):real->real->real`,
         `(inv):real->real`,`(*):real->real->real`,`(/):real->real->real`,
         `(pow):real->num->real`,
         REAL_INTEGRAL,REAL_INVERSE,REAL_POLY_CONV);;
\end{verbatim}
}
\noindent after which, for example, we can verify a reduction for cubic
equations to quadratics entirely automatically:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_RING
     `p = (&3 * a1 - a2 pow 2) / &3 /\
      q = (&9 * a1 * a2 - &27 * a0 - &2 * a2 pow 3) / &27 /\
      z = x - a2 / &3 /\
      x * w = w pow 2 - p / &3 /\
      ~(p = &0)
      ==> (z pow 3 + a2 * z pow 2 + a1 * z + a0 = &0 <=>
          (w pow 3) pow 2 - q * (w pow 3) - p pow 3 / &27 = &0)`;;
\end{verbatim}
}

\SEEALSO
ideal_cofactors, NUM_RING, REAL_FIELD, REAL_RING, real_ideal_cofactors,
RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{RING{\_}AND{\_}IDEAL{\_}CONV}

\TYPE {\small\verb%RING_AND_IDEAL_CONV : (term -> num) * (num -> term) * conv * term * term * term * term * term * term * term * thm * (term -> thm) -> (term -> thm) * (term list -> term -> term list)%}\egroup

\SYNOPSIS
Returns a pair giving a ring proof procedure and an ideal membership routine.

\DESCRIBE
This function combines the functionality of {\small\verb%RING%} and {\small\verb%ideal_cofactors%}. Each
of these requires the same rather lengthy input. When you want to apply both to
the same set of parameters, you can do so using {\small\verb%RING_AND_IDEAL_CONV%}. That is:
{\par\samepage\setseps\small
\begin{verbatim}
  RING_AND_IDEAL_CONV parms
\end{verbatim}
}
\noindent is functionally equivalent to:
{\par\samepage\setseps\small
\begin{verbatim}
  RING parms,ideal_cofactors parms
\end{verbatim}
}
For more information, see the documentation for those two functions.

\FAILURE
Fails if the parameters are wrong.

\SEEALSO
ideal_cofactors, RING.

\ENDDOC
\DOC{rotate}

\TYPE {\small\verb%rotate : int -> refinement%}\egroup

\SYNOPSIS
Rotate a goalstate.

\DESCRIBE
The function {\small\verb%rotate n gl%} rotates a list {\small\verb%gl%} of subgoals by {\small\verb%n%} places. The
function {\small\verb%r%} is the special case where this modification is applied to the
imperative variable of unproven subgoals.

\FAILURE
Fails only if the list of goals is empty.

\SEEALSO
r.

\ENDDOC
\DOC{RULE{\_}ASSUM{\_}TAC}

\TYPE {\small\verb%RULE_ASSUM_TAC : (thm -> thm) -> tactic%}\egroup

\SYNOPSIS
Maps an inference rule over the assumptions of a goal.

\DESCRIBE
When applied to an inference rule {\small\verb%f%} and a goal {\small\verb%({A1;...;An} ?- t)%},
the {\small\verb%RULE_ASSUM_TAC%} tactical applies the inference rule to each of the
assumptions to give a new goal.
{\par\samepage\setseps\small
\begin{verbatim}
             {A1,...,An} ?- t
   ====================================  RULE_ASSUM_TAC f
    {f(.. |- A1),...,f(.. |- An)} ?- t
\end{verbatim}
}

\FAILURE
The application of {\small\verb%RULE_ASSUM_TAC f%} to a goal fails iff {\small\verb%f%} fails when
applied to any of the assumptions of the goal.

\COMMENTS
It does not matter if the goal has no assumptions, but in this case
{\small\verb%RULE_ASSUM_TAC%} has no effect.

\SEEALSO
ASSUM_LIST, MAP_EVERY, MAP_FIRST, POP_ASSUM_LIST.

\ENDDOC
\DOC{search}

\TYPE {\small\verb%search : term list -> (string * thm) list%}\egroup

\SYNOPSIS
Search the database of theorems according to query patterns.

\DESCRIBE
The {\small\verb%search%} function is intended to locate a desired theorem by searching
based on term patterns or names. The database of theorems to be searched is
held in {\small\verb%theorems%}, which initially contains all theorems individually bound to
OCaml identifiers in the main system, and can be augmented or otherwise
modified by the user. (See in particular the update script in
{\small\verb%update_database.ml%} which creates a database according to the current
OCaml environment.)

The input to {\small\verb%search%} is a list of terms that are treated as patterns.
Normally, a term {\small\verb%pat%} is interpreted as a search for `a theorem with any
subterm of the form {\small\verb%pat%}', e.g. a pattern {\small\verb%x + y%} for any subterm of the form
{\small\verb%s + t%}. However, several syntax functions create composite terms that are
interpreted specially by {\small\verb%search%}:

\begin{itemize}

\item {\small\verb%omit pat%} --- Search for theorems {\em not} satisfying {\small\verb%pat%}

\item {\small\verb%exactly `t`%} --- Search for theorems with subterms alpha-equivalent to
{\small\verb%t%} (not just of the general form {\small\verb%t%})

\item {\small\verb%name "str"%} --- Search for theorems whose name contains {\small\verb%str%} as a
substring.

\end{itemize}

\FAILURE
Never fails.

\EXAMPLE
Search for theorems with a subterm of the form {\small\verb%s <= t / u%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # search [`x <= y / z`];;
  val it : (string * thm) list =
    [("RAT_LEMMA4",
      |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 <= x2 / y2 <=> x1 * y2 <= x2 * y1));
     ("REAL_LE_DIV", |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x / y);
     ("REAL_LE_DIV2_EQ", |- !x y z. &0 < z ==> (x / z <= y / z <=> x <= y));
     ("REAL_LE_RDIV_EQ", |- !x y z. &0 < z ==> (x <= y / z <=> x * z <= y));
     ("SUM_BOUND_GEN",
      |- !s t b.
             FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b / &(CARD s))
             ==> sum s f <= b)]
\end{verbatim}
}
Search for theorems whose name contains {\small\verb%"CROSS"%} and whose conclusion involves
the cardinality function {\small\verb%CARD%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # search [name "CROSS"; `CARD`];;
  Warning: inventing type variables
  val it : (string * thm) list =
    [("CARD_CROSS",
      |- !s t. FINITE s /\ FINITE t ==> CARD (s CROSS t) = CARD s * CARD t)]
\end{verbatim}
}
Search for theorems that involve finiteness of the image of a set under a
function, but also do not involve logical equivalence:
{\par\samepage\setseps\small
\begin{verbatim}
  # search [`FINITE(IMAGE f s)`; omit `(<=>)`];;
  Warning: inventing type variables
  val it : (string * thm) list =
    [("FINITE_IMAGE", |- !f s. FINITE s ==> FINITE (IMAGE f s))]
\end{verbatim}
}

\SEEALSO
theorems.

\ENDDOC
\DOC{SELECT{\_}CONV}

\TYPE {\small\verb%SELECT_CONV : term -> thm%}\egroup

\SYNOPSIS
Eliminates an epsilon term by introducing an existential quantifier.

\DESCRIBE
The conversion {\small\verb%SELECT_CONV%} expects a boolean term of the form
{\small\verb%`P[@x.P[x]/x]`%}, which asserts that the epsilon term {\small\verb%@x.P[x]%} denotes
a value, {\small\verb%x%} say, for which {\small\verb%P[x]%} holds.  This assertion is equivalent
to saying that there exists such a value, and {\small\verb%SELECT_CONV%} applied to a
term of this form returns the theorem {\small\verb%|- P[@x.P[x]/x] = ?x. P[x]%}.

\FAILURE
Fails if applied to a term that is not of the form {\small\verb%`P[@x.P[x]/x]`%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SELECT_CONV `(@n. n < m) < m`;;
  val it : thm = |- (@n. n < m) < m <=> (?n. n < m)
\end{verbatim}
}
\USES
Particularly useful in conjunction with {\small\verb%CONV_TAC%} for proving properties
of values denoted by epsilon terms.  For example, suppose that one wishes
to prove the goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m. 0 < m ==> (@n. n < m) < SUC m`;;
\end{verbatim}
}
\noindent We start off:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC THEN
      MATCH_MP_TAC(ARITH_RULE `!m n. m < n ==> m < SUC n`));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`0 < m`]

  `(@n. n < m) < m`
\end{verbatim}
}
\noindent This is now in the correct form for using {\small\verb%SELECT_CONV%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(CONV_TAC SELECT_CONV);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`0 < m`]

  `?n. n < m`
\end{verbatim}
}
\noindent and the resulting subgoal is straightforward to prove, e.g.
by {\small\verb%ASM_MESON_TAC[]%} or {\small\verb%EXISTS_TAC `0` THEN ASM_REWRITE_TAC[]%}.

\SEEALSO
SELECT_ELIM, SELECT_RULE.

\ENDDOC
\DOC{SELECT{\_}ELIM{\_}TAC}

\TYPE {\small\verb%SELECT_ELIM_TAC : tactic%}\egroup

\SYNOPSIS
Eliminate select terms from a goal.

\DESCRIBE
The tactic {\small\verb%SELECT_ELIM_TAC%} attempts to remove from a goal any select terms,
i.e. instances of the Hilbert choice operator {\small\verb%@x. P[x]%}. First, any instances
that occur inside their own predicate, i.e. {\small\verb%P[@x. P[x]]%}, are replaced simply
by {\small\verb%?x. P[x]%}, as with {\small\verb%SELECT_CONV%}. Other select-terms are eliminated by
replacing each on with a new variable {\small\verb%v%} and adding a corresponding instance
of the axiom {\small\verb%SELECT_AX%}, of the form {\small\verb%!x. P[x] ==> P[v]%}. Note that the latter
does not strictly preserve logical equivalence, only implication. So it is
possible to replace a provable goal by an unprovable one. But since not much is
provable about a select term except via the axiom {\small\verb%SELECT_AX%}, this is not
likely in practice.

\FAILURE
Never fails.

\EXAMPLE
Suppose we set the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(@n. n < 3) < 3 /\ (@n. n < 3) < 5`;;
\end{verbatim}
}
\noindent An application of {\small\verb%SELECT_ELIM_TAC%} returns:
{\par\samepage\setseps\small
\begin{verbatim}
  # e SELECT_ELIM_TAC;;
  val it : goalstack = 1 subgoal (1 total)

  `!_73133. (!x. x < 3 ==> _73133 < 3) ==> (?n. n < 3) /\ _73133 < 5`
\end{verbatim}
}

\USES
This is already applied as an initial normalization by {\small\verb%MESON%} and other rules.
Users may occasionally find it helpful.

\SEEALSO
SELECT_CONV.

\ENDDOC
\DOC{SELECT{\_}RULE}

\TYPE {\small\verb%SELECT_RULE : thm -> thm%}\egroup

\SYNOPSIS
Introduces an epsilon term in place of an existential quantifier.

\DESCRIBE
The inference rule {\small\verb%SELECT_RULE%} expects a theorem asserting the
existence of a value {\small\verb%x%} such that {\small\verb%P%} holds.  The equivalent assertion
that the epsilon term {\small\verb%@x.P%} denotes a value of {\small\verb%x%} for
which {\small\verb%P%} holds is returned as a theorem.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- ?x. P
   ------------------  SELECT_RULE
    A |- P[(@x.P)/x]
\end{verbatim}
}
\FAILURE
Fails if applied to a theorem the conclusion of which is not
existentially quantified.

\EXAMPLE
The axiom {\small\verb%INFINITY_AX%} in the theory {\small\verb%ind%} is of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   |- ?f. ONE_ONE f /\ ~ONTO f
\end{verbatim}
}
\noindent Applying {\small\verb%SELECT_RULE%} to this theorem returns the following.
{\par\samepage\setseps\small
\begin{verbatim}
  # SELECT_RULE INFINITY_AX;;
  val it : thm =
    |- ONE_ONE (@f. ONE_ONE f /\ ~ONTO f) /\ ~ONTO (@f. ONE_ONE f /\ ~ONTO f)
\end{verbatim}
}
\USES
May be used to introduce an epsilon term to permit rewriting with a
constant defined using the epsilon operator.

\SEEALSO
CHOOSE, SELECT_AX, SELECT_CONV.

\ENDDOC
\DOC{self{\_}destruct}

\TYPE {\small\verb%self_destruct : string -> unit%}\egroup

\SYNOPSIS
Exits HOL Light but saves current state ready to restart.

\DESCRIBE
This operation is only available in HOL images created using checkpointing (as
in the default Linux build arising from {\small\verb%make all%}), not when the HOL Light
sources have simply been loaded into the OCaml toplevel without checkpointing.
A call {\small\verb%self_destruct s%} will exit the current OCaml / HOL Light session, but
save the current state to an image {\small\verb%hol.snapshot%}. Users can then start this
image; it will display the usual banner and also the string {\small\verb%s%}, and the user
will then be in the same state as before {\small\verb%self_destruct%}.

\FAILURE
Never fails, except in the face of OS-level problems such as running out of
disc space.

\USES
Very useful to start HOL Light quickly with many background theories or tools
loaded, rather than needing to rebuild them from sources.

\COMMENTS
Unfortunately I do not know of any checkpointing tool that can give this
behaviour under Windows or Mac OS X. See the README file and tutorial for
additional information on Linux checkpointing options.

\EXAMPLE
Suppose that all the proofs you are doing at the moment need more theorems
about prime numbers, and also a list of all prime numbers up to 1000. We reach
a suitable state:
{\par\samepage\setseps\small
\begin{verbatim}
  # needs "Library/prime.ml";;
  ...
  # let primes_1000 = rev(rev_itlist
      (fun q ps -> if exists (fun p -> q mod p = 0) ps then ps else q::ps)
      (2--1000) []);;
  ...
\end{verbatim}
}
\noindent and now issue the checkpointing command:
{\par\samepage\setseps\small
\begin{verbatim}
  self_destruct "Preloaded with prime number material";;
\end{verbatim}
}
HOL Light will exit and a new file {\small\verb%hol.snapshot%} will be created. You might
want to rename it as {\small\verb%hol.prime%} in the OS so it has a more intuitive name and
doesn't get overwritten by later checkpoints
{\par\samepage\setseps\small
\begin{verbatim}
  $ mv hol.snapshot hol.prime
\end{verbatim}
}
\noindent You can then start the new image just by {\small\verb%hol.prime%}:
{\par\samepage\setseps\small
\begin{verbatim}
  $ hol.prime
          HOL Light 2.10, built 16 March 2006 on OCaml 3.08.3
          Preloaded with prime number material

  val it : unit = ()
  #
\end{verbatim}
}
\noindent and continue where you left off, with all the prime-number material
available instantly:
{\par\samepage\setseps\small
\begin{verbatim}
  # PRIME_DIVPROD;;
  val it : thm =
    |- !p a b. prime p /\ p divides a * b ==> p divides a \/ p divides b
  # el 100 primes_1000;;
  val it : int = 547
\end{verbatim}
}

\SEEALSO
checkpoint, startup_banner.

\ENDDOC
\DOC{SEMIRING{\_}NORMALIZERS{\_}CONV}

\TYPE {\small\verb%SEMIRING_NORMALIZERS_CONV : thm -> thm -> (term -> bool) * conv * conv * conv -> (term -> term -> bool) -> (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm)%}\egroup

\SYNOPSIS
Produces normalizer functions over a ring or even a semiring.

\DESCRIBE
The function {\small\verb%SEMIRING_NORMALIZERS_CONV%} should be given two theorems about
some binary operators that we write as infix `{\small\verb%+%}', `{\small\verb%*%}' and `{\small\verb%^%}' and
ground terms `{\small\verb%ZERO%}' and `{\small\verb%ONE%}'. (The conventional symbols make the import of
the theorem easier to grasp, but they are essentially arbitrary.) The first
theorem is of the following form, essentially stating that the operators form a
semiring structure with `{\small\verb%^%}' as the ``power'' operator:
{\par\samepage\setseps\small
\begin{verbatim}
  |- (!x y z. x + (y + z) = (x + y) + z) /\
     (!x y. x + y = y + x) /\
     (!x. ZERO + x = x) /\
     (!x y z. x * (y * z) = (x * y) * z) /\
     (!x y. x * y = y * x) /\
     (!x. ONE * x = x) /\
     (!x. ZERO * x = ZERO) /\
     (!x y z. x * (y + z) = x * y + x * z) /\
     (!x. x^0 = ONE) /\
     (!x n. x^(SUC n) = x * x^n)
\end{verbatim}
}
The second theorem may just be {\small\verb%TRUTH = |- T%}, in which case it will be assumed
that the structure is just a semiring. Otherwise, it may be of the following
form for ``negation'' ({\small\verb%neg%}) and ``subtraction'' functions, plus a
ground term {\small\verb%MINUS1%} thought of as {\small\verb%-1%}:
{\par\samepage\setseps\small
\begin{verbatim}
  |- (!x. neg x = MINUS1 * x) /\
     (!x y. x - y = x + MINUS1 * y)
\end{verbatim}
}
If the second theorem is provided, the eventual normalizer will also handle the
negation and subtraction operations. Generally this is beneficial, but is
impossible on structures like {\small\verb%:num%} with no negative numbers.

The remaining arguments are a tuple. The first is an ordering on terms, used to
determine the polynomial form. Normally, the default OCaml ordering is fine.
The rest are intended to be functions for operating on `constants' (e.g.
numerals), which should handle at least `{\small\verb%ZERO%}', `{\small\verb%ONE%}' and, in the case of a
ring, `{\small\verb%MINUS1%}'. The functions are: (i) a test for membership in the set of
`constants', (ii) an addition conversion on constants, (iii) a multiplication
conversion on constants, and (iv) a conversion to raise a constant to a numeral
power. Note that no subtraction or negation operations are needed explicitly
because this is subsumed in the presence of {\small\verb%-1%} as a constant.

The function then returns conversions for putting terms of the structure into a
canonical form, essentially multiplied-out polynomials with a particular
ordering. The functions respectively negate, add, subtract, multiply,
exponentiate terms already in the canonical form, putting the result back in
canonical form. The final return value is an overall normalization function.

\FAILURE
Fails if the theorems are malformed.

\EXAMPLE
There are already instantiations of the main normalizer for natural numbers
({\small\verb%NUM_NORMALIZE_CONV%}) and real numbers ({\small\verb%REAL_POLY_CONV%}). Here is how the
latter is first constructed (it is later enhanced to handle some additional
functions more effectively, so use the inbuilt definition, not this one):
{\par\samepage\setseps\small
\begin{verbatim}
  # let REAL_POLY_NEG_CONV,REAL_POLY_ADD_CONV,REAL_POLY_SUB_CONV,
        REAL_POLY_MUL_CONV,REAL_POLY_POW_CONV,REAL_POLY_CONV =
      SEMIRING_NORMALIZERS_CONV REAL_POLY_CLAUSES REAL_POLY_NEG_CLAUSES
       (is_ratconst,
        REAL_RAT_ADD_CONV,REAL_RAT_MUL_CONV,REAL_RAT_POW_CONV)
       (<);;
  val ( REAL_POLY_NEG_CONV ) : term -> thm = <fun>
  val ( REAL_POLY_ADD_CONV ) : term -> thm = <fun>
  val ( REAL_POLY_SUB_CONV ) : term -> thm = <fun>
  val ( REAL_POLY_MUL_CONV ) : term -> thm = <fun>
  val ( REAL_POLY_POW_CONV ) : term -> thm = <fun>
  val ( REAL_POLY_CONV ) : term -> thm = <fun>
\end{verbatim}
}
For examples of the resulting main function in action, see {\small\verb%REAL_POLY_CONV%}.

\USES
This is a highly generic function, intended only for occasional use by experts.
Users reasoning in any sort of ring structure may find it a useful
building-block for a decision procedure.

\COMMENTS
This is a subcomponent of more powerful generic decision procedures such as
{\small\verb%RING%}. These can handle more sophisticated reasoning that direct equality
through normalization.

\SEEALSO
ideal_cofactors, NUM_NORMALIZE_CONV, REAL_POLY_CONV, RING_AND_IDEAL_CONV.

\ENDDOC
\DOC{SEQ{\_}IMP{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%SEQ_IMP_REWRITE_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Performs sequential implicational rewriting, adding new assumptions if
necessary.

\DESCRIBE
This tactic is closely related to {\small\verb%IMP_REWRITE_TAC%} but uses the provided
theorems sequentially instead of simultaneously: given a list of theorems
{\small\verb%[th_1;...;th_k]%}, the tactic call {\small\verb%SEQ_IMP_REWRITE_TAC [th_1;...;th_k]%}
applies as many implicational rewriting as it can with {\small\verb%th_1%}, then with
{\small\verb%th_2%}, etc. When {\small\verb%th_k%} is reached, start over from {\small\verb%th_1%}. Repeat till no
more rewrite can be achieved.

\FAILURE
Fails if no rewrite can be achieved. If the usual behavior of leaving the goal unchanged
is desired, one can wrap the coal in {\small\verb%TRY_TAC%}.

\EXAMPLE
This uses the basic {\small\verb%IMP_REWRITE_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a b c. a < b ==> (a - b) / (a - b) * c = c`;;
  val it : goalstack = 1 subgoal (1 total)

  `!a b c. a < b ==> (a - b) / (a - b) * c = c`

  # e(IMP_REWRITE_TAC[REAL_DIV_REFL;REAL_MUL_LID;REAL_SUB_0; REAL_LT_IMP_NE]);;
  val it : goalstack = 1 subgoal (1 total)

  `!a b. ~(a < b)`
\end{verbatim}
}
But with {\small\verb%SEQ_IMP_REWRITE_TAC%}, the same sequence of theorems solves the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SEQ_IMP_REWRITE_TAC[REAL_DIV_REFL;REAL_MUL_LID;REAL_SUB_0; REAL_LT_IMP_NE]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
This addresses a problem which happens already with {\small\verb%REWRITE_TAC%} or
{\small\verb%SIMP_TAC%}: one generally rewrites with one theorem, then with another, etc.
and, in the end, once every step is done, (s)he packs everything in a list and
provides this list to {\small\verb%IMP_REWRITE_TAC%}; but it then happens that some
surprises happen at this point because the simultaneous use of all theorems
does not yield the same result as their subsequent use. A usual solution is
simply to decompose the call into two calls by identifying manually which
theorems are the source of the unexpected behavior when used together. Or one
can simply use {\small\verb%SEQ_IMP_REWRITE_TAC%}. Note that this is however a lot slower
than {\small\verb%IMP_REWRITE_TAC%}. The user may prefer to first use {\small\verb%IMP_REWRITE_TAC%} and
if it does not work like the sequential use of single implicational rewrites
then use {\small\verb%SEQ_IMP_REWRITE_TAC%}.

\SEEALSO
IMP_REWRITE_TAC, REWRITE_TAC, SIMP_TAC.

\ENDDOC
\DOC{setify}

\TYPE {\small\verb%setify : 'a list -> 'a list%}\egroup

\SYNOPSIS
Removes repeated elements from a list. Makes a list into a `set'.

\DESCRIBE
{\small\verb%setify l%} removes repeated elements from {\small\verb%l%}, leaving the last occurrence of
each duplicate in the list.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # setify [1;2;3;1;4;3];;
  val it : int list = [1; 2; 3; 4]
\end{verbatim}
}

\COMMENTS
The current implementation will in fact return a sorted list according to the
basic OCaml polymorphic ordering.

\SEEALSO
uniq.

\ENDDOC
\DOC{set{\_}basic{\_}congs}

\TYPE {\small\verb%set_basic_congs : thm list -> unit%}\egroup

\SYNOPSIS
Change the set of basic congruences used by the simplifier.

\DESCRIBE
The HOL Light simplifier (as invoked by {\small\verb%SIMP_TAC%} etc.) uses congruence rules
to determine how it uses context when descending through a term. These are
essentially theorems showing how to decompose one equality to a series of other
inequalities in context. A call to {\small\verb%set_basic_congs thl%} sets the congruence
rules to the list of theorems {\small\verb%thl%}.

\FAILURE
Never fails.

\COMMENTS
Normally, users only need to extend the congruences; for an example of how to
do that see {\small\verb%extend_basic_congs%}.

\SEEALSO
basic_congs, extend_basic_congs, SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{set{\_}basic{\_}convs}

\TYPE {\small\verb%set_basic_convs : (string * (term * conv)) list -> unit%}\egroup

\SYNOPSIS
Assign the set of default conversions.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. The latter are normally
term transformations that cannot be expressed as single (conditional or
unconditional) rewrite rules. A call to {\small\verb%set_basic_convs l%} where {\small\verb%l%} is a list
of items ("name",(`pat`,conv)) will make the default conversions just that set,
using the name {\small\verb%name%} to refer to each one and restricting it to subterms
encountered that match {\small\verb%pat%}.

\FAILURE
Never fails.

\COMMENTS
Normally, users will only want to extend the existing set of conversions using
{\small\verb%extend_basic_convs%}.

\SEEALSO
basic_convs, extend_basic_convs, set_basic_rewrites, REWRITE_TAC, SIMP_TAC.

\ENDDOC
\DOC{set{\_}basic{\_}rewrites}

\TYPE {\small\verb%set_basic_rewrites : thm list -> unit%}\egroup

\SYNOPSIS
Assign the set of default rewrites used by rewriting and simplification.

\DESCRIBE
The HOL Light rewriter ({\small\verb%REWRITE_TAC%} etc.) and simplifier ({\small\verb%SIMP_TAC%} etc.)
have default sets of (conditional) equations and other conversions that are
applied by default, except in the {\small\verb%PURE_%} variants. A call to
{\small\verb%extend_basic_rewrites thl%} sets this to be the list of theorems {\small\verb%thl%} (after
processing into rewrite rules by {\small\verb%mk_rewrites%}).

\FAILURE
Never fails.

\COMMENTS
Users will most likely want to extend the existing set by
{\small\verb%extend_basic_rewrites%} rather than completely change it like this.

\SEEALSO
basic_rewrites, extend_basic_convs, set_basic_convs.

\ENDDOC
\DOC{set{\_}color{\_}printer}

\TYPE {\small\verb%set_color_printer : bool -> unit%}\egroup

\SYNOPSIS
Installs or uninstalls color printers.

\DESCRIBE
The call {\small\verb%set_color_printer b%} installs color pretty printers
{\small\verb%pp_print_colored_qterm%}, {\small\verb%pp_print_colored_qtype%}, {\small\verb%pp_print_colored_thm%},
{\small\verb%pp_print_colored_goal%} and {\small\verb%pp_print_colored_goalstack%} if {\small\verb%b%} is {\small\verb%true%}.
If {\small\verb%b%} is {\small\verb%false%}, it installs pretty printers that do not use colors.

\FAILURE
Should never fail.

\ENDDOC
\DOC{set{\_}eq}

\TYPE {\small\verb%set_eq : 'a list -> 'a list -> bool%}\egroup

\SYNOPSIS
Tests two `sets' for equality.

\DESCRIBE
{\small\verb%set_eq l1 l2%} returns {\small\verb%true%} if every element of {\small\verb%l1%} appears in {\small\verb%l2%} and
every element of {\small\verb%l2%} appears in {\small\verb%l1%}. Otherwise it returns {\small\verb%false%}. In other
words, it tests if the lists are the same considered as sets, i.e. ignoring
duplicates.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # set_eq [1;2] [2;1;2];;
  val it : bool = true
  # set_eq [1;2] [1;3];;
  val it : bool = false
\end{verbatim}
}

\SEEALSO
setify, union, intersect, subtract.

\ENDDOC
\DOC{set{\_}goal}

\TYPE {\small\verb%set_goal : term list * term -> goalstack%}\egroup

\SYNOPSIS
Initializes the subgoal package with a new goal.

\DESCRIBE
The function {\small\verb%set_goal%} initializes the subgoal management package. A  proof
state of the package consists of either a goal stack and a justification stack
if a proof is in progress, or a theorem if a proof has just been completed.
{\small\verb%set_goal%} sets a new proof state consisting of an empty justification stack
and a goal stack with the given goal as its sole goal. The goal is printed.

\FAILURE
Fails unless all terms in the goal are of type {\small\verb%bool%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # set_goal([], `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`);;
  val it : goalstack = 1 subgoal (1 total)

  `HD [1; 2; 3] = 1 /\ TL [1; 2; 3] = [2; 3]`
\end{verbatim}
}

\USES
Starting an interactive proof session with the subgoal package.

The subgoal package implements a simple framework for interactive goal-directed
proof.  When conducting a proof that involves many subgoals and tactics, the
user must keep track of all the justifications and compose them in the correct
order.  While this is feasible even in large proofs, it is tedious.  The
subgoal package provides a way of building and traversing the tree of subgoals
top-down, stacking the justifications and applying them properly.

The package maintains a proof state consisting of either a goal stack of
outstanding goals and a justification stack, or a theorem.  Tactics are used to
expand the current goal (the one on the top of the goal stack) into subgoals
and justifications. These are pushed onto the goal stack and justification
stack, respectively, to form a new proof state. All preceding proof states are
saved and can be returned to if a mistake is made in the proof.  The goal stack
is divided into levels, a new level being created each time a tactic is
successfully applied to give new subgoals.  The subgoals of the current level
may be considered in any order.

\SEEALSO
b, e, g, p, r, top_goal, top_thm.

\ENDDOC
\DOC{SET{\_}RULE}

\TYPE {\small\verb%SET_RULE : term -> thm%}\egroup

\SYNOPSIS
Attempt to prove elementary set-theoretic lemma.

\DESCRIBE
The function {\small\verb%SET_RULE%} is a crude automated prover for set-theoretic facts.
When applied to a term, it expands various set-theoretic definitions explicitly
and then attempts to solve the result using {\small\verb%MESON%}.

\FAILURE
Fails if the simple translation does not suffice, or the resulting goal is too
deep for {\small\verb%MESON%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SET_RULE `{x | ~(x IN s <=> x IN t)} = (s DIFF t) UNION (t DIFF s)`;;
  ...
  val it : thm = |- {x | ~(x IN s <=> x IN t)} = s DIFF t UNION t DIFF s

  # SET_RULE
     `UNIONS {t y | y IN x INSERT s} = t x UNION UNIONS {t y | y IN s}`;;
  val it : thm =
    |- UNIONS {t y | y IN x INSERT s} = t x UNION UNIONS {t y | y IN s}
\end{verbatim}
}

\SEEALSO
MESON, MESON_TAC[], SET_TAC.

\ENDDOC
\DOC{SET{\_}TAC}

\TYPE {\small\verb%SET_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Attempt to prove goal using basic set-theoretic reasoning.

\DESCRIBE
When applied to a goal and a list of lemmas to use, the tactic {\small\verb%SET_TAC%} puts
the lemmas into the goal as antecedents, expands various set-theoretic
definitions explicitly and then attempts to solve the result using {\small\verb%MESON%}. It
does not by default use the assumption list of the goal, but this can be done
using {\small\verb%ASM SET_TAC%} in place of plain {\small\verb%SET_TAC%}.

\FAILURE
Fails if the simple translation does not suffice, or the resulting goal is too
deep for {\small\verb%MESON%}.

\EXAMPLE
Given the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!s. (UNIONS s = {}) <=> !t. t IN s ==> t = {}`;;
\end{verbatim}
}
\noindent the following solves it:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SET_TAC[]);;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
ASM, MESON, MESON_TAC, SET_RULE.

\ENDDOC
\DOC{set{\_}verbose{\_}symbols}

\TYPE {\small\verb%set_verbose_symbols : unit -> unit%}\egroup

\SYNOPSIS
Enables more verbose descriptive names for quantifiers and logical constants

\DESCRIBE
A call to {\small\verb%set_verbose_symbols()%} enables a more verbose syntax for the logical
quantifiers and constants. These are all just interface mappings, the
underlying constant names in the abstract syntax of the logic being unchanged.
But the more descriptive names are applied by default when printing and
are accepted when parsing terms as synonyms of the symbolic names. The new
names are:

\begin{itemize}

\item The universal quantifier `{\small\verb%!%}' is now parsed and printed as `{\small\verb%forall%}'

\item The existential quantifier `{\small\verb%?%}' is now parsed and printed as `{\small\verb%exists%}'

\item The exists-unique quantifier `{\small\verb%?!%}' is now parsed and printed as
`{\small\verb%existsunique%}'

\item The logical constant `{\small\verb%T%}' is now parsed and printed as `{\small\verb%true%}'

\item The logical constant `{\small\verb%F%}' is now parsed and printed as `{\small\verb%false%}'

\end{itemize}

The effect can be reverse by a call to the dual function
{\small\verb%unset_verbose_symbols()%}.

\EXAMPLE
Notice how the printing of theorems changes from using the symbolic names for
quantifiers
{\par\samepage\setseps\small
\begin{verbatim}
  # unset_verbose_symbols();;
  val it : unit = ()
  # num_Axiom;;
  val it : thm = |- !e f. ?!fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
\end{verbatim}
}
\noindent to the more verbose and descriptive names:
{\par\samepage\setseps\small
\begin{verbatim}
  # set_verbose_symbols();;
  val it : unit = ()
  # num_Axiom;;
  val it : thm =
    |- forall e f.
           existsunique fn. fn 0 = e /\ (forall n. fn (SUC n) = f (fn n) n)
\end{verbatim}
}

\FAILURE
Only fails if some of the names have already been used for incompatible
constants.

\SEEALSO
overload_interface, override_interface, remove_interface,
the_interface, unset_verbose_symbols.

\ENDDOC
\DOC{shareout}

\TYPE {\small\verb%shareout : 'a list list -> 'b list -> 'b list list%}\egroup

\SYNOPSIS
Shares out the elements of the second list according to pattern in first.

\DESCRIBE
The call {\small\verb%shareout pat l%} shares out the elements of {\small\verb%l%} into the same groups
as the pattern list {\small\verb%pat%}, while keeping them in the same order. If there are
more elements in {\small\verb%l%} than needed, they will be discarded, but if there are
fewer, failure will occur.

\FAILURE
Fails if there are too few elements in the second list.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # shareout [[1;2;3]; [4;5]; [6]; [7;8;9]] (explode "abcdefghijklmnopq");;
  val it : string list list =
    [["a"; "b"; "c"]; ["d"; "e"]; ["f"]; ["g"; "h"; "i"]]
\end{verbatim}
}

\SEEALSO
chop_list.

\ENDDOC
\DOC{SIMPLE{\_}CHOOSE}

\TYPE {\small\verb%SIMPLE_CHOOSE : term -> thm -> thm%}\egroup

\SYNOPSIS
Existentially quantifies a hypothesis of a theorem.

\DESCRIBE
A call {\small\verb%SIMPLE_CHOOSE `v` th%} existentially quantifies a hypothesis of the
theorem over the variable {\small\verb%v%}. It is intended for use when there is only one
hypothesis so that the choice of assumption is unambiguous. In general, it
picks the one that happens to be first in the list.

\FAILURE
Fails if {\small\verb%v%} is not a variable or if it is free in the conclusion of the
theorem {\small\verb%th%}.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = SYM(ASSUME `x:num = y`);;
  val th : thm = x = y |- y = x
  # SIMPLE_EXISTS `x:num` th;;
  val it : thm = x = y |- ?x. y = x

  # SIMPLE_CHOOSE `x:num` it;;
  val it : thm = ?x. x = y |- ?x. y = x
\end{verbatim}
}

\COMMENTS
The more general function is {\small\verb%CHOOSE%}, but this is simpler in the special case.

\SEEALSO
CHOOSE, EXISTS, SIMPLE_EXISTS.

\ENDDOC
\DOC{SIMPLE{\_}DISJ{\_}CASES}

\TYPE {\small\verb%SIMPLE_DISJ_CASES : thm -> thm -> thm%}\egroup

\SYNOPSIS
Disjoins hypotheses of two theorems with same conclusion.

\DESCRIBE
The rule {\small\verb%SIMPLE_DISJ_CASES%} takes two `case' theorems with alpha-equivalent
conclusions and returns a theorem with the first hypotheses disjoined:
{\par\samepage\setseps\small
\begin{verbatim}

              A u {p} |- r    B u {q} |- r
         ----------------------------------------- SIMPLE_DISJ_CASES
           (A - {p}) u (B - {q}) u {p \/ q} |- r
\end{verbatim}
}
To avoid dependency on the order of the hypotheses, it is only recommended when
each theorem has exactly one hypothesis:
{\par\samepage\setseps\small
\begin{verbatim}
         {p} |- r    {q} |- r
      ---------------------------- SIMPLE_DISJ_CASES
              {p \/ q} |- r
\end{verbatim}
}
For more sophisticated or-elimination, use {\small\verb%DISJ_CASES%}.

\FAILURE
Fails if the conclusions of the theorems are not alpha-equivalent.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let [th1; th2] = map (UNDISCH o TAUT)
      [`~p ==> p ==> q`; `q ==> p ==> q`];;
  ...
  val th1 : thm = ~p |- p ==> q
  val th2 : thm = q |- p ==> q

  # SIMPLE_DISJ_CASES th1 th2;;
  val it : thm = ~p \/ q |- p ==> q
\end{verbatim}
}

\SEEALSO
DISJ_CASES, DISJ_CASES_TAC, DISJ_CASES_THEN, DISJ_CASES_THEN2, DISJ1, DISJ2.

\ENDDOC
\DOC{SIMPLE{\_}EXISTS}

\TYPE {\small\verb%SIMPLE_EXISTS : term -> thm -> thm%}\egroup

\SYNOPSIS
Introduces an existential quantifier over a variable in a theorem.

\DESCRIBE
When applied to a pair consisting of a variable {\small\verb%v%} and a theorem {\small\verb%|- p%},
{\small\verb%SIMPLE_EXISTS%} returns the theorem {\small\verb%|- ?v. p%}. It is not compulsory for {\small\verb%v%} to
appear free in {\small\verb%p%}, but otherwise the quantification is vacuous.

\FAILURE
Fails only if {\small\verb%v%} is not a variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SIMPLE_EXISTS `x:num` (REFL `x:num`);;
  val it : thm = |- ?x. x = x
\end{verbatim}
}

\COMMENTS
The {\small\verb%EXISTS%} function is more general: it can introduce an existentially
quantified variable to replace chosen instances of any term in the theorem.
However, {\small\verb%SIMPLE_EXISTS%} is easier to use when the simple case is needed.

\SEEALSO
CHOOSE, EXISTS.

\ENDDOC
\DOC{SIMPLIFY{\_}CONV}

\TYPE {\small\verb%SIMPLIFY_CONV : simpset -> thm list -> conv%}\egroup

\SYNOPSIS
General simplification at depth with arbitrary simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset'. Given a simpset {\small\verb%ss%} and an
additional list of theorems {\small\verb%thl%} to be used as (conditional or unconditional)
rewrite rules, {\small\verb%SIMPLIFY_CONV ss thl%} gives a simplification conversion with a
repeated top-down traversal strategy ({\small\verb%TOP_DEPTH_SQCONV%}) and a nesting limit
of 3 for the recursive solution of subconditions by further simplification.

\FAILURE
Never fails.

\USES
Usually some other interface to the simplifier is more convenient, but you may
want to use this to employ a customized simpset.

\SEEALSO
GEN_SIMPLIFY_CONV, ONCE_SIMPLIFY_CONV, SIMP_CONV, SIMP_RULE, SIMP_TAC,
TOP_DEPTH_SQCONV.

\ENDDOC
\DOC{SIMP{\_}CONV}

\TYPE {\small\verb%SIMP_CONV : thm list -> conv%}\egroup

\SYNOPSIS
Simplify a term repeatedly by conditional contextual rewriting.

\DESCRIBE
A call {\small\verb%SIMP_CONV thl tm%} will return {\small\verb%|- tm = tm'%} where {\small\verb%tm'%} results from
applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules, as well as
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}).

The theorems are first split up into individual rewrite rules, either
conditional ({\small\verb%|- c ==> l = r%}) or unconditional ({\small\verb%|- l = r%}), as described in
the documentation for {\small\verb%mk_rewrites%}. These are then applied repeatedly to
replace subterms in the goal that are instances {\small\verb%l'%} of the left-hand side with
a corresponding {\small\verb%r'%}. Rewrite rules that are permutative, with each side an
instance of the other, have an ordering imposed on them so that they tend to
force terms into canonical form rather than looping (see {\small\verb%ORDERED_REWR_CONV%}).
In the case of applying a conditional rewrite, the condition {\small\verb%c%} needs to be
eliminated before the rewrite can be applied. This is attempted by recursively
applying the same simplifications to {\small\verb%c%} in the hope of reducing it to {\small\verb%T%}. If
this can be done, the conditional rewrite is applied, otherwise not. To add
additional provers to dispose of side-conditions beyond application of the
basic rewrites, see {\small\verb%mk_prover%} and {\small\verb%ss_of_provers%}.

\FAILURE
Never fails, but may return a reflexive theorem {\small\verb%|- tm = tm%} if no
simplifications can be made.

\EXAMPLE
Here we use the conditional and contextual facilities:
{\par\samepage\setseps\small
\begin{verbatim}
  # SIMP_CONV[SUB_ADD; ARITH_RULE `0 < n ==> 1 <= n`]
        `0 < n ==> (n - 1) + 1 = n + f(k + 1)`;;
  val it : thm =
  |- 0 < n ==> n - 1 + 1 = n + f (k + 1) <=> 0 < n ==> n = n + f (k + 1)
\end{verbatim}
}
\noindent and here we show how a permutative rewrite achieves normalization
(the same would work with plain {\small\verb%REWRITE_CONV%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_CONV[ADD_AC] `(a + c + e) + ((b + a + d) + e):num`;;
  val it : thm = |- (a + c + e) + (b + a + d) + e = a + a + b + c + d + e + e
\end{verbatim}
}

\COMMENTS
For simply rewriting with unconditional equations, {\small\verb%REWRITE_CONV%} and relatives
are simpler and more efficient.

\SEEALSO
ASM_SIMP_TAC, ONCE_SIMP_CONV, SIMP_RULE, SIMP_TAC.

\ENDDOC
\DOC{SIMP{\_}RULE}

\TYPE {\small\verb%SIMP_RULE : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Simplify conclusion of a theorem repeatedly by conditional contextual
rewriting.

\DESCRIBE
A call {\small\verb%SIMP_CONV thl (|- tm)%} will return {\small\verb%|- tm'%} where {\small\verb%tm'%} results from
applying the theorems in {\small\verb%thl%} as (conditional) rewrite rules, as well as
built-in simplifications (see {\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more
details on this kind of conditional rewriting, see {\small\verb%SIMP_CONV%}.

\FAILURE
Never fails, but may return the input theorem unchanged if no simplifications
were applicable.

\SEEALSO
ONCE_SIMP_RULE, SIMP_CONV, SIMP_TAC.

\ENDDOC
\DOC{SIMP{\_}TAC}

\TYPE {\small\verb%SIMP_TAC : thm list -> tactic%}\egroup

\SYNOPSIS
Simplify a goal repeatedly by conditional contextual rewriting.

\DESCRIBE
When applied to a goal {\small\verb%A ?- g%}, the tactic {\small\verb%SIMP_TAC thl%} returns a new
goal {\small\verb%A ?- g'%} where {\small\verb%g'%} results from applying the theorems in {\small\verb%thl%} as
(conditional) rewrite rules, as well as built-in simplifications (see
{\small\verb%basic_rewrites%} and {\small\verb%basic_convs%}). For more details, see {\small\verb%SIMP_CONV%}.

\FAILURE
Never fails, though may not change the goal if no simplifications are
applicable.

\COMMENTS
To add the assumptions of the goal to the rewrites, use {\small\verb%ASM_SIMP_TAC%} (or just
{\small\verb%ASM SIMP_TAC%}).

\SEEALSO
ASM, ASM_SIMP_TAC, IMP_REWRITE_TAC, mk_rewrites, ONCE_SIMP_CONV, REWRITE_TAC,
SIMP_CONV, SIMP_RULE, TARGET_REWRITE_TAC.

\ENDDOC
\DOC{SKOLEM{\_}CONV}

\TYPE {\small\verb%SKOLEM_CONV : conv%}\egroup

\SYNOPSIS
Completely Skolemize a term already in negation normal form.

\DESCRIBE
Skolemization amounts to rewriting with the equivalence
{\par\samepage\setseps\small
\begin{verbatim}
  # SKOLEM_THM;;
  val it : thm = |- !P. (!x. ?y. P x y) <=> (?y. !x. P x (y x))
\end{verbatim}
}
The conversion {\small\verb%SKOLEM_CONV%} will apply this transformation and pull out
quantifiers to give a form with all existential quantifiers pulled to the
outside. However, it assumes that the input is in negation
normal form, i.e. built up by conjunction and disjunction from possibly negated
atomic formulas.

\FAILURE
Never fails.

\EXAMPLE
Here is a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # SKOLEM_CONV `(!x. ?y. P x y) \/ (?u. !v. ?z. P (f u v) z)`;;
  Warning: inventing type variables
  val it : thm =
    |- (!x. ?y. P x y) \/ (?u. !v. ?z. P (f u v) z) <=>
       (?y u z. (!x. P x (y x)) \/ (!v. P (f u v) (z v)))
\end{verbatim}
}
However, note that it doesn't work properly when the input involves
implication, and hence is not in NNF:
{\par\samepage\setseps\small
\begin{verbatim}
  # SKOLEM_CONV `(!x. ?y. P x y) ==> (?u. !v. ?z. P (f u v) z)`;;
  Warning: inventing type variables
   val it : thm =
    |- (!x. ?y. P x y) ==> (?u. !v. ?z. P (f u v) z) <=>
       (?y. !x. P x (y x)) ==> (?u z. !v. P (f u v) (z v))
\end{verbatim}
}

\USES
A useful component in decision procedures, to simplify the class of formulas
that need to be considered. Used internally in several such procedures like
{\small\verb%MESON_TAC%}.

\SEEALSO
NNF_CONV, NNFC_CONV, PRENEX_CONV.

\ENDDOC
\DOC{some}

\TYPE {\small\verb%some : ('a -> bool) -> 'a list -> 'a * 'a list%}\egroup

\SYNOPSIS
Parses any single item satisfying a predicate.

\DESCRIBE
If {\small\verb%p%} is a predicate on input tokens of some kind, {\small\verb%some p%} is a parser that
parses and returns any first token satisfying the predicate {\small\verb%p%}, and raises
{\small\verb%Noparse%} on a first token not satisfying {\small\verb%p%}.

\FAILURE
The call {\small\verb%some p%} never fails.

\COMMENTS
This is one of a suite of combinators for manipulating ``parsers''. A parser is
simply a function whose OCaml type is some instance of
{\small\verb%:('a)list -> 'b * ('a)list%}. The function should take a list of objects of
type {\small\verb%:'a%} (e.g. characters or tokens), parse as much of it as possible from
left to right, and return a pair consisting of the object derived from parsing
(e.g. a term or a special syntax tree) and the list of elements that were not
processed.

\SEEALSO
++, |||, >>, a, atleast, elistof, finished, fix, leftbin, listof, many, nothing,
possibly, rightbin.

\ENDDOC
\DOC{sort}

\TYPE {\small\verb%sort : ('a -> 'a -> bool) -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Sorts a list using a given transitive `ordering' relation.

\DESCRIBE
The call
{\par\samepage\setseps\small
\begin{verbatim}
   sort op list
\end{verbatim}
}
\noindent where {\small\verb%op%} is a transitive relation on the elements of {\small\verb%list%}, will
topologically sort the list, i.e. will permute it such that if {\small\verb%x op y%} but not
{\small\verb%y op x%} then {\small\verb%x%} will occur to the left of {\small\verb%y%} in the sorted list. In
particular if {\small\verb%op%} is a total order, the list will be sorted in the usual sense
of the word.

\FAILURE
Never fails.

\EXAMPLE
A simple example is:
{\par\samepage\setseps\small
\begin{verbatim}
  # sort (<) [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5; 8; 9; 7; 9];;
  val it : int list = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 7; 8; 9; 9; 9]
\end{verbatim}
}
\noindent The following example is a little more complicated, and shows how a
topological sorting under the relation `is free in' can be achieved. This is
actually sometimes useful to consider subterms of a term in an appropriate
order:
{\par\samepage\setseps\small
\begin{verbatim}
  # sort free_in [`(x + 1) + 2`; `x + 2`; `x:num`; `x + 1`; `1`];;
  val it : term list = [`1`; `x`; `x + 1`; `x + 2`; `(x + 1) + 2`]
\end{verbatim}
}

\COMMENTS
This function uses the Quicksort algorithm internally, which has good
typical-case performance and will sort topologically. However, its worst-case
performance is quadratic. By contrast {\small\verb%mergesort%} gives a good worst-case
performance but requires a total order. Note that any comparison-based
topological sorting function must have quadratic behaviour in the worst case.
For an $n$-element list, there are $n (n - 1) / 2$ pairs. For any topological
sorting algorithm, we can make sure the first $n (n - 1) / 2 - 1$ pairs
compared are unrelated in either direction, while still leaving the option of
choosing for the last pair $(a,b)$ either $a < b$ or $b < a$, eventually giving
a partial order. So at least $n (n - 1) / 2$ comparisons are needed to
distinguish these two partial orders correctly.

\SEEALSO
mergesort.

\ENDDOC
\DOC{SPEC}

\TYPE {\small\verb%SPEC : term -> thm -> thm%}\egroup

\SYNOPSIS
Specializes the conclusion of a theorem.

\DESCRIBE
When applied to a term {\small\verb%u%} and a theorem {\small\verb%A |- !x. t%}, then {\small\verb%SPEC%} returns
the theorem {\small\verb%A |- t[u/x]%}. If necessary, variables will be renamed prior
to the specialization to ensure that {\small\verb%u%} is free for {\small\verb%x%} in {\small\verb%t%}, that is,
no variables free in {\small\verb%u%} become bound after substitution.
{\par\samepage\setseps\small
\begin{verbatim}
     A |- !x. t
   --------------  SPEC `u`
    A |- t[u/x]
\end{verbatim}
}
\FAILURE
Fails if the theorem's conclusion is not universally quantified, or if {\small\verb%x%} and
{\small\verb%u%} have different types.

\EXAMPLE
The following example shows how {\small\verb%SPEC%} renames bound variables if necessary,
prior to substitution: a straightforward substitution would result in the
clearly invalid theorem {\small\verb%|- ~y ==> (!y. y ==> ~y)%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # let xv = `x:bool` and yv = `y:bool` in
         (GEN xv o DISCH xv o GEN yv o DISCH yv) (ASSUME xv);;
  val it : thm = |- !x. x ==> (!y. y ==> x)

  # SPEC `~y` it;;
  val it : thm = |- ~y ==> (!y'. y' ==> ~y)
\end{verbatim}
}

\COMMENTS
In order to specialize variables while also instantiating types of polymorphic
variables, use {\small\verb%ISPEC%} instead.

\SEEALSO
GEN, GENL, GEN_ALL, ISPEC, ISPECL, SPECL, SPEC_ALL, SPEC_VAR.

\ENDDOC
\DOC{SPECL}

\TYPE {\small\verb%SPECL : term list -> thm -> thm%}\egroup

\SYNOPSIS
Specializes zero or more variables in the conclusion of a theorem.

\DESCRIBE
When applied to a term list {\small\verb%[u1;...;un]%} and a theorem
{\small\verb%A |- !x1...xn. t%}, the inference rule {\small\verb%SPECL%} returns the theorem
{\small\verb%A |- t[u1/x1]...[un/xn]%}, where the substitutions are made
sequentially left-to-right in the same way as for {\small\verb%SPEC%}, with the same
sort of alpha-conversions applied to {\small\verb%t%} if necessary to ensure that no
variables which are free in {\small\verb%ui%} become bound after substitution.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- !x1...xn. t
   --------------------------  SPECL [`u1`;...;`un`]
     A |- t[u1/x1]...[un/xn]
\end{verbatim}
}
\noindent It is permissible for the term-list to be empty, in which case
the application of {\small\verb%SPECL%} has no effect.

\FAILURE
Fails unless each of the terms is of the same as that of the
appropriate quantified variable in the original theorem.

\EXAMPLE
The following is a specialization of a theorem from theory {\small\verb%arithmetic%}.
{\par\samepage\setseps\small
\begin{verbatim}
  # let t = ARITH_RULE `!m n p q. m <= p /\ n <= q ==> (m + n) <= (p + q)`;;
  val t : thm = |- !m n p q. m <= p /\ n <= q ==> m + n <= p + q

  # SPECL [`1`; `2`; `3`; `4`] t;;
  val it : thm = |- 1 <= 3 /\ 2 <= 4 ==> 1 + 2 <= 3 + 4
\end{verbatim}
}

\COMMENTS
In order to specialize variables while also instantiating types of polymorphic
variables, use {\small\verb%ISPECL%} instead.

\SEEALSO
GEN, GENL, GEN_ALL, GEN_TAC, SPEC, SPEC_ALL, SPEC_TAC.

\ENDDOC
\DOC{SPEC{\_}ALL}

\TYPE {\small\verb%SPEC_ALL : thm -> thm%}\egroup

\SYNOPSIS
Specializes the conclusion of a theorem with its own quantified variables.

\DESCRIBE
When applied to a theorem {\small\verb%A |- !x1...xn. t%}, the inference rule {\small\verb%SPEC_ALL%}
returns the theorem {\small\verb%A |- t[x1'/x1]...[xn'/xn]%} where the {\small\verb%xi'%} are distinct
variants of the corresponding {\small\verb%xi%}, chosen to avoid clashes with any variables
free in the assumption list. Normally {\small\verb%xi'%} is just {\small\verb%xi%}, in which case
{\small\verb%SPEC_ALL%} simply removes all universal quantifiers.
{\par\samepage\setseps\small
\begin{verbatim}
       A |- !x1...xn. t
   ---------------------------  SPEC_ALL
    A |- t[x1'/x1]...[xn'/xn]
\end{verbatim}
}
\FAILURE
Never fails.

\EXAMPLE
The following example shows how variables are also renamed to avoid clashing
with those in assumptions.
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ADD_ASSUM `m = 1` ADD_SYM;;
  val th : thm = m = 1 |- !m n. m + n = n + m

  # SPEC_ALL th;;
  val it : thm = m = 1 |- m' + n = n + m'
\end{verbatim}
}
\SEEALSO
GEN, GENL, GEN_ALL, GEN_TAC, SPEC, SPECL, SPEC_ALL, SPEC_TAC.

\ENDDOC
\DOC{SPEC{\_}TAC}

\TYPE {\small\verb%SPEC_TAC : term * term -> tactic%}\egroup

\SYNOPSIS
Generalizes a goal.

\DESCRIBE
When applied to a pair of terms {\small\verb%(`u`,`x`)%}, where {\small\verb%x%} is just a variable,
and a goal {\small\verb%A ?- t%}, the tactic {\small\verb%SPEC_TAC%} generalizes the goal to
{\small\verb%A ?- !x. t[x/u]%}, that is, all (free) instances of {\small\verb%u%} are turned into {\small\verb%x%}.
{\par\samepage\setseps\small
\begin{verbatim}
        A ?- t
   =================  SPEC_TAC (`u`,`x`)
    A ?- !x. t[x/u]
\end{verbatim}
}

\FAILURE
Fails unless {\small\verb%x%} is a variable with the same type as {\small\verb%u%}.

\USES
Removing unnecessary speciality in a goal, particularly as a prelude to
an inductive proof.

\SEEALSO
GEN, GENL, GEN_ALL, GEN_TAC, SPEC, SPECL, SPEC_ALL, STRIP_TAC.

\ENDDOC
\DOC{SPEC{\_}VAR}

\TYPE {\small\verb%SPEC_VAR : thm -> term * thm%}\egroup

\SYNOPSIS
Specializes the conclusion of a theorem, returning the chosen variant.

\DESCRIBE
When applied to a theorem {\small\verb%A |- !x. t%}, the inference rule {\small\verb%SPEC_VAR%} returns
the term {\small\verb%x'%} and the theorem {\small\verb%A |- t[x'/x]%}, where {\small\verb%x'%} is a variant
of {\small\verb%x%} chosen to avoid clashing with free variables in assumptions.
{\par\samepage\setseps\small
\begin{verbatim}
     A |- !x. t
   --------------  SPEC_VAR
    A |- t[x'/x]
\end{verbatim}
}
\FAILURE
Fails unless the theorem's conclusion is universally quantified.

\EXAMPLE
Note how the variable is renamed to avoid the free {\small\verb%m%} in the assumptions:
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = ADD_ASSUM `m = 1` ADD_SYM;;
  val th : thm = m = 1 |- !m n. m + n = n + m

  # SPEC_VAR th;;
  val it : term * thm = (`m'`, m = 1 |- !n. m' + n = n + m')
\end{verbatim}
}

\SEEALSO
GEN, GENL, GEN_ALL, GEN_TAC, SPEC, SPECL, SPEC_ALL.

\ENDDOC
\DOC{splitlist}

\TYPE {\small\verb%splitlist : ('a -> 'b * 'a) -> 'a -> 'b list * 'a%}\egroup

\SYNOPSIS
Applies a binary destructor repeatedly in left-associative mode.

\DESCRIBE
If a destructor function {\small\verb%d%} inverts a binary constructor {\small\verb%f%}, for example
{\small\verb%dest_comb%} for {\small\verb%mk_comb%}, and fails when applied to {\small\verb%y%}, then:
{\par\samepage\setseps\small
\begin{verbatim}
  splitlist d (f(x1,f(x2,f(...f(xn,y)))))
\end{verbatim}
}
\noindent returns
{\par\samepage\setseps\small
\begin{verbatim}
  ([x1; ... ; xn],y)
\end{verbatim}
}

\FAILURE
Never fails.

\EXAMPLE
The function {\small\verb%strip_forall%} is actually just defined as
{\small\verb%splitlist dest_forall%}, which acts as follows:
{\par\samepage\setseps\small
\begin{verbatim}
  # splitlist dest_forall `!x y z. x + y = z`;;
  val it : term list * term = ([`x`; `y`; `z`], `x + y = z`)
\end{verbatim}
}

\SEEALSO
itlist, nsplit, rev_splitlist, striplist.

\ENDDOC
\DOC{ss{\_}of{\_}congs}

\TYPE {\small\verb%ss_of_congs : thm list -> simpset -> simpset%}\egroup

\SYNOPSIS
Add congruence rules to a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. A call {\small\verb%ss_of_congs thl ss%} adds {\small\verb%thl%} as new
congruence rules to the simpset {\small\verb%ss%} to yield a new simpset. For an
illustration of how congruence rules can be used, see {\small\verb%extend_basic_congs%}.

\FAILURE
Never fails unless the congruence rules are malformed.

\SEEALSO
mk_rewrites, SIMP_CONV, ss_of_conv, ss_of_maker, ss_of_prover, ss_of_provers,
ss_of_thms.

\ENDDOC
\DOC{ss{\_}of{\_}conv}

\TYPE {\small\verb%ss_of_conv : term -> conv -> simpset -> simpset%}\egroup

\SYNOPSIS
Add a new conversion to a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. A call {\small\verb%ss_of_conv pat cnv ss%} adds the conversion
{\small\verb%cnv%} to the simpset {\small\verb%ss%} to yield a new simpset, restricting the initial
filtering of potential subterms to those matching {\small\verb%pat%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ss_of_conv `x + y:num` NUM_ADD_CONV empty_ss;;
  ...
\end{verbatim}
}

\SEEALSO
mk_rewrites, SIMP_CONV, ss_of_congs, ss_of_maker, ss_of_prover, ss_of_provers,
ss_of_thms.

\ENDDOC
\DOC{ss{\_}of{\_}maker}

\TYPE {\small\verb%ss_of_maker : (thm -> thm list -> thm list) -> simpset -> simpset%}\egroup

\SYNOPSIS
Change the rewrite maker in a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. A call {\small\verb%ss_of_maker maker ss%} changes the ``rewrite
maker'' in {\small\verb%ss%} to yield a new simpset; use of this simpset with additional
theorems will process those theorems using the new rewrite maker. The default
rewrite maker is {\small\verb%mk_rewrites%} with an appropriate flag, and it is unusual to
want to change it.

\FAILURE
Never fails.

\SEEALSO
mk_rewrites, SIMP_CONV, ss_of_congs, ss_of_conv, ss_of_prover, ss_of_provers,
ss_of_thms.

\ENDDOC
\DOC{ss{\_}of{\_}prover}

\TYPE {\small\verb%ss_of_prover : (strategy -> strategy) -> simpset -> simpset%}\egroup

\SYNOPSIS
Change the method of prover application in a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. The default `prover use' method is to first recursively
apply all the simplification to conditions and then try the provers, if any,
one by one until one succeeds. It is unusual to want to change this, but if
desired you can do it with {\small\verb%ss_of_prover str ss%}.

\FAILURE
Never fails.

\SEEALSO
mk_rewrites, SIMP_CONV, ss_of_congs, ss_of_conv, ss_of_maker, ss_of_provers,
ss_of_thms.

\ENDDOC
\DOC{ss{\_}of{\_}provers}

\TYPE {\small\verb%ss_of_provers : prover list -> simpset -> simpset%}\egroup

\SYNOPSIS
Add new provers to a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. A call {\small\verb%ss_of_provers prs ss%} adds the provers in {\small\verb%prs%}
to the simpset {\small\verb%ss%} to yield a new simpset. See {\small\verb%mk_prover%} for more
explanation of how to create something of type {\small\verb%prover%}.

\FAILURE
Never fails.

\SEEALSO
mk_prover, mk_rewrites, SIMP_CONV, ss_of_congs, ss_of_conv, ss_of_maker,
ss_of_prover, ss_of_thms.

\ENDDOC
\DOC{ss{\_}of{\_}thms}

\TYPE {\small\verb%ss_of_thms : thm list -> simpset -> simpset%}\egroup

\SYNOPSIS
Add theorems to a simpset.

\DESCRIBE
In their maximal generality, simplification operations in HOL Light (as invoked
by {\small\verb%SIMP_TAC%}) are controlled by a `simpset', which may contain conditional and
unconditional rewrite rules, conversions and provers for conditions, as well as
a determination of how to use the prover on the conditions and how to process
theorems into rewrites. A call {\small\verb%ss_of_thms thl ss%} processes the theorems {\small\verb%thl%}
according to the rewrite maker in the simpset {\small\verb%ss%} (normally {\small\verb%mk_rewrites%}) and
adds them to the theorems in {\small\verb%ss%} to yield a new simpset.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # ss_of_thms [ADD_CLAUSES] empty_ss;;
  ...
\end{verbatim}
}

\SEEALSO
mk_rewrites, SIMP_CONV, ss_of_congs, ss_of_conv, ss_of_maker, ss_of_prover,
ss_of_provers.

\ENDDOC
\DOC{startup{\_}banner}

\TYPE {\small\verb%startup_banner : string%}\egroup

\SYNOPSIS
The one-line startup banner for HOL Light.

\DESCRIBE
This string is the startup banner for HOL Light, and is displayed when
standalone images (see {\small\verb%self_destruct%}) are started up. It  is only available
in HOL images created using checkpointing (as in the default Linux build
arising from {\small\verb%make all%}), not when the HOL Light sources have simply been
loaded into the OCaml toplevel without checkpointing.

\FAILURE
Not applicable.

\EXAMPLE
On my home computer, the value is currently:
{\par\samepage\setseps\small
\begin{verbatim}
  # startup_banner;;
  val it : string =
    "        HOL Light 2.10, built 16 March 2006 on OCaml 3.08.3"
\end{verbatim}
}

\SEEALSO
self_destruct.

\ENDDOC
\DOC{strings{\_}of{\_}file}

\TYPE {\small\verb%strings_of_file : string -> string list%}\egroup

\SYNOPSIS
Read file and convert content into a list of strings.

\DESCRIBE
When given a filename, the function {\small\verb%strings_of_file%} attempts to open the file
for input, and if this is successful reads and closes it, returning a list of
strings corresponding to the lines in the file.

\FAILURE
Fails if the file cannot be opened (e.g. it does not exist, or the permissions
are wrong).

\EXAMPLE
If the file {\small\verb%/tmp/greeting%} contains the text
{\par\samepage\setseps\small
\begin{verbatim}
Hello world
Goodbye world
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
  # strings_of_file "/tmp/greeting";;
  val it : string list = ["Hello world"; "Goodbye world"]
\end{verbatim}
}

\SEEALSO
file_of_string, string_of_file.

\ENDDOC
\DOC{STRING{\_}EQ{\_}CONV}

\TYPE {\small\verb%STRING_EQ_CONV : term -> thm%}\egroup

\SYNOPSIS
Proves equality or inequality of two HOL string literals.

\DESCRIBE
If {\small\verb%"s"%} and {\small\verb%"t"%} are two string literals in the HOL logic,
{\small\verb%STRING_EQ_CONV `"s" = "t"`%} returns:

{\par\samepage\setseps\small
\begin{verbatim}
   |- "s" = "t" <=> T       or       |- "s" = "t" <=> F
\end{verbatim}
}
\noindent depending on whether the string literals are equal or not equal,
respectively.

\FAILURE
{\small\verb%STRING_EQ_CONV tm%} fails if {\small\verb%tm%} is not of the specified form, an equation
between string literals.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # STRING_EQ_CONV `"same" = "same"`;;
  val it : thm = |- "same" = "same" <=> T

  # STRING_EQ_CONV `"knowledge" = "power"`;;
  val it : thm = |- "knowledge" = "power" <=> F
\end{verbatim}
}

\USES
Performing basic equality reasoning while producing string-related proofs.

\SEEALSO
dest_string, CHAR_EQ_CONV, mk_string, NUM_EQ_CONV.

\ENDDOC
\DOC{string{\_}of{\_}file}

\TYPE {\small\verb%string_of_file : string -> string%}\egroup

\SYNOPSIS
Read file and convert content into a string.

\DESCRIBE
When given a filename, the function {\small\verb%strings_of_file%} attempts to open the file
for input, and if this is successful reads and closes it, returning the
contents as a single string.

\FAILURE
Fails if the file cannot be opened (e.g. it does not exist, or the permissions
are wrong).

\EXAMPLE
If the file {\small\verb%/tmp/greeting%} contains the text
{\par\samepage\setseps\small
\begin{verbatim}
Hello world
Goodbye world
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
  # string_of_file "/tmp/greeting";;
  val it : string = "Hello world\nGoodbye world"
\end{verbatim}
}

\SEEALSO
file_of_string, strings_of_file.

\ENDDOC
\DOC{string{\_}of{\_}term}

\TYPE {\small\verb%string_of_term : term -> string%}\egroup

\SYNOPSIS
Converts a HOL term to a string representation.

\DESCRIBE
The call {\small\verb%string_of_term tm%} produces a textual representation of the term {\small\verb%tm%}
as a string, similar to what is printed automatically at the toplevel, though
without the surrounding quotes.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # string_of_term `x + 1 < 2 <=> x = 0`;;
  val it : string = "x + 1 < 2 <=> x = 0"
\end{verbatim}
}

\COMMENTS
The string may contain newlines for large terms, broken in a similar fashion to
automatic printing.

\SEEALSO
string_of_thm, string_of_type.

\ENDDOC
\DOC{string{\_}of{\_}thm}

\TYPE {\small\verb%string_of_thm : thm -> string%}\egroup

\SYNOPSIS
Converts a HOL theorem to a string representation.

\DESCRIBE
The call {\small\verb%string_of_thm th%} produces a textual representation of the theorem
{\small\verb%th%} as a string, similar to what is printed automatically at the toplevel.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # string_of_thm ADD_CLAUSES;;
  val it : string =
    "|- (!n. 0 + n = n) /\\\n   (!m. m + 0 = m) /\\\n   (!m n. SUC m + n = SUC (m
  + n)) /\\\n   (!m n. m + SUC n = SUC (m + n))"

  # print_string it;;
  |- (!n. 0 + n = n) /\
     (!m. m + 0 = m) /\
     (!m n. SUC m + n = SUC (m + n)) /\
     (!m n. m + SUC n = SUC (m + n))
  val it : unit = ()
\end{verbatim}
}

\COMMENTS
The string may contain newlines for large terms, broken in a similar fashion to
automatic printing.

\SEEALSO
string_of_thm, string_of_type.

\ENDDOC
\DOC{string{\_}of{\_}type}

\TYPE {\small\verb%string_of_type : hol_type -> string%}\egroup

\SYNOPSIS
Converts a HOL type to a string representation.

\DESCRIBE
The call {\small\verb%string_of_type ty%} produces a textual representation of the type {\small\verb%ty%}
as a string, similar to what is printed automatically at the toplevel, though
without the surrounding quotes and colon.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # string_of_type bool_ty;;
  val it : string = "bool"
\end{verbatim}
}

\SEEALSO
string_of_term, string_of_thm.

\ENDDOC
\DOC{striplist}

\TYPE {\small\verb%striplist : ('a -> 'a * 'a) -> 'a -> 'a list%}\egroup

\SYNOPSIS
Applies a binary destructor repeatedly, flattening the construction tree into a
list.

\DESCRIBE
If a destructor function {\small\verb%d%} inverts a binary constructor {\small\verb%f%}, for example
{\small\verb%dest_comb%} for {\small\verb%mk_comb%}, and fails when applied to components {\small\verb%xi%}, then
when applied to any object built up repeatedly by {\small\verb%f%} applied to base values
{\small\verb%xi%} returns the list {\small\verb%[x1;...;xn]%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # striplist dest_conj `(a /\ (b /\ ((c /\ d) /\ e)) /\ f) /\ g`;;
  val it : term list = [`a`; `b`; `c`; `d`; `e`; `f`; `g`]
\end{verbatim}
}

\SEEALSO
nsplit, splitlist, rev_splitlist, end_itlist.

\ENDDOC
\DOC{strip{\_}abs}

\TYPE {\small\verb%strip_abs : term -> term list * term%}\egroup

\SYNOPSIS
Iteratively breaks apart abstractions.

\DESCRIBE
{\small\verb%strip_abs `\x1 ... xn. t`%} returns {\small\verb%([`x1`;...;`xn`],`t`)%}. Note that
{\par\samepage\setseps\small
\begin{verbatim}
   strip_abs(list_mk_abs([`x1`;...;`xn`],`t`))
\end{verbatim}
}
\noindent will not return {\small\verb%([`x1`;...;`xn`],`t`)%} if {\small\verb%t%} is an abstraction.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # strip_abs `\x y z. x /\ y /\ z`;;
  val it : term list * term = ([`x`; `y`; `z`], `x /\ y /\ z`)
\end{verbatim}
}

\SEEALSO
list_mk_abs, dest_abs.

\ENDDOC
\DOC{STRIP{\_}ASSUME{\_}TAC}

\TYPE {\small\verb%STRIP_ASSUME_TAC : thm_tactic%}\egroup

\SYNOPSIS
Splits a theorem into a list of theorems and then adds them to the assumptions.

\DESCRIBE
Given a theorem {\small\verb%th%} and a goal {\small\verb%(A,t)%}, {\small\verb%STRIP_ASSUME_TAC th%} splits {\small\verb%th%} into
a list of theorems. This is done by recursively breaking conjunctions into
separate conjuncts, cases-splitting disjunctions, and eliminating existential
quantifiers by choosing arbitrary variables.  Schematically, the following
rules are applied:
{\par\samepage\setseps\small
\begin{verbatim}
           A ?- t
   ======================  STRIP_ASSUME_TAC (A' |- v1 /\ ... /\ vn)
    A u {v1,...,vn} ?- t

                A ?- t
   =================================  STRIP_ASSUME_TAC (A' |- v1 \/ ... \/ vn)
    A u {v1} ?- t ... A u {vn} ?- t

          A ?- t
   ====================  STRIP_ASSUME_TAC (A' |- ?x.v)
    A u {v[x'/x]} ?- t
\end{verbatim}
}
\noindent where {\small\verb%x'%} is a variant of {\small\verb%x%}.

If the conclusion of {\small\verb%th%} is not a conjunction, a disjunction or an
existentially quantified term, the whole theorem {\small\verb%th%} is added to the
assumptions.

As assumptions are generated, they are examined to see if they solve the goal
(either by being alpha-equivalent to the conclusion of the goal or by deriving
a contradiction).

The assumptions of the theorem being split are not added to the assumptions of
the goal(s), but they are recorded in the proof.  This means that if {\small\verb%A'%} is
not a subset of the assumptions {\small\verb%A%} of the goal (up to alpha-conversion),
{\small\verb%STRIP_ASSUME_TAC (A' |- v)%} results in an invalid tactic.

\FAILURE
Never fails.

\EXAMPLE
When solving the goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `m = 0 + m`;;
\end{verbatim}
}
\noindent assuming the clauses for addition with
{\small\verb%STRIP_ASSUME_TAC ADD_CLAUSES%} results in the goal
{\par\samepage\setseps\small
\begin{verbatim}
  # e(STRIP_ASSUME_TAC ADD_CLAUSES);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`!n. 0 + n = n`]
   1 [`!m. m + 0 = m`]
   2 [`!m n. SUC m + n = SUC (m + n)`]
   3 [`!m n. m + SUC n = SUC (m + n)`]

  `m = 0 + m`
\end{verbatim}
}
\noindent while the same tactic directly solves the goal
{\par\samepage\setseps\small
\begin{verbatim}
   ?- !m. 0 + m = m
\end{verbatim}
}
\USES
{\small\verb%STRIP_ASSUME_TAC%} is used when applying a previously proved theorem to solve a
goal, or when enriching its assumptions so that rewriting with assumptions and
other operations involving assumptions have more to work with.

\SEEALSO
ASSUME_TAC, CHOOSE_TAC, CHOOSE_THEN, CONJUNCTS_THEN, DISJ_CASES_TAC,
DISJ_CASES_THEN.

\ENDDOC
\DOC{strip{\_}comb}

\TYPE {\small\verb%strip_comb : term -> term * term list%}\egroup

\SYNOPSIS
Iteratively breaks apart combinations (function applications).

\DESCRIBE
{\small\verb%strip_comb `t t1 ... tn`%} returns {\small\verb%(`t`,[`t1`;...;`tn`])%}. Note that
{\par\samepage\setseps\small
\begin{verbatim}
   strip_comb(list_mk_comb(`t`,[`t1`;...;`tn`]))
\end{verbatim}
}
\noindent will not return {\small\verb%(`t`,[`t1`;...;`tn`])%} if {\small\verb%t%} is a combination.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # strip_comb `x /\ y`;;
  val it : term * term list = (`(/\)`, [`x`; `y`])

  # strip_comb `T`;;
  val it : term * term list = (`T`, [])
\end{verbatim}
}

\SEEALSO
dest_comb, list_mk_comb, splitlist, striplist.

\ENDDOC
\DOC{strip{\_}exists}

\TYPE {\small\verb%strip_exists : term -> term list * term%}\egroup

\SYNOPSIS
Iteratively breaks apart existential quantifications.

\DESCRIBE
{\small\verb%strip_exists `?x1 ... xn. t`%} returns {\small\verb%([`x1`;...;`xn`],`t`)%}. Note that
{\par\samepage\setseps\small
\begin{verbatim}
   strip_exists(list_mk_exists([`x1`;...;`xn`],`t`))
\end{verbatim}
}
\noindent will not return {\small\verb%([`x1`;...;`xn`],`t`)%} if {\small\verb%t%} is an existential
quantification.

\FAILURE
Never fails.

\SEEALSO
dest_exists, list_mk_exists.

\ENDDOC
\DOC{strip{\_}forall}

\TYPE {\small\verb%strip_forall : term -> term list * term%}\egroup

\SYNOPSIS
Iteratively breaks apart universal quantifications.

\DESCRIBE
{\small\verb%strip_forall `!x1 ... xn. t`%} returns {\small\verb%([`x1`;...;`xn`],`t`)%}. Note that
{\par\samepage\setseps\small
\begin{verbatim}
   strip_forall(list_mk_forall([`x1`;...;`xn`],`t`))
\end{verbatim}
}
\noindent will not return {\small\verb%([`x1`;...;`xn`],`t`)%} if {\small\verb%t%} is a universal
quantification.

\FAILURE
Never fails.

\SEEALSO
dest_forall, list_mk_forall.

\ENDDOC
\DOC{strip{\_}gabs}

\TYPE {\small\verb%strip_gabs : term -> term list * term%}\egroup

\SYNOPSIS
Breaks apart an iterated generalized or basic abstraction.

\DESCRIBE
If the term {\small\verb%t%} is iteratively constructed by basic or generalized
abstractions, i.e. is of the form {\small\verb%\vs1. \vs2. ... \vsn. t%}, then the call
{\small\verb%strip_gabs t%} returns a pair of the list of varstructs and the term
{\small\verb%[vs1; vs2; ...; vsn],t%}.

\FAILURE
Never fails, though the list of varstructs will be empty if the initial term is
no sort of abstraction.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # strip_gabs `\(a,b) c ((d,e),f). (a - b) + c + (d - e) * f`;;
  val it : term list * term =
    ([`a,b`; `c`; `(d,e),f`], `a - b + c + (d - e) * f`)
\end{verbatim}
}

\SEEALSO
dest_gabs, is_gabs, mk_gabs.

\ENDDOC
\DOC{STRIP{\_}GOAL{\_}THEN}

\TYPE {\small\verb%STRIP_GOAL_THEN : thm_tactic -> tactic%}\egroup

\SYNOPSIS
Splits a goal by eliminating one outermost connective, applying the
given theorem-tactic to the antecedents of implications.

\DESCRIBE
Given a theorem-tactic {\small\verb%ttac%} and a goal {\small\verb%(A,t)%}, {\small\verb%STRIP_GOAL_THEN%} removes one
outermost occurrence of one of the connectives {\small\verb%!%}, {\small\verb%==>%}, {\small\verb%~%} or {\small\verb%/\%} from the
conclusion of the goal {\small\verb%t%}.  If {\small\verb%t%} is a universally quantified term, then
{\small\verb%STRIP_GOAL_THEN%} strips off the quantifier:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- !x.u
   ==============  STRIP_GOAL_THEN ttac
     A ?- u[x'/x]
\end{verbatim}
}
\noindent where {\small\verb%x'%} is a primed variant that does not appear free in the
assumptions {\small\verb%A%}.  If {\small\verb%t%} is a conjunction, then {\small\verb%STRIP_GOAL_THEN%} simply splits
the conjunction into two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- v /\ w
   =================  STRIP_GOAL_THEN ttac
    A ?- v   A ?- w
\end{verbatim}
}
\noindent If {\small\verb%t%} is an implication {\small\verb%"u ==> v"%} and if:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- v
  ===============  ttac (u |- u)
     A' ?- v'
\end{verbatim}
}
\noindent then:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- u ==> v
  ====================  STRIP_GOAL_THEN ttac
        A' ?- v'
\end{verbatim}
}
\noindent Finally, a negation {\small\verb%~t%} is treated as the implication {\small\verb%t ==> F%}.

\FAILURE
{\small\verb%STRIP_GOAL_THEN ttac (A,t)%} fails if {\small\verb%t%} is not a universally quantified term,
an implication, a negation or a conjunction.  Failure also occurs if the
application of {\small\verb%ttac%} fails, after stripping the goal.

\EXAMPLE
When solving the goal
{\par\samepage\setseps\small
\begin{verbatim}
  # g `n = 1 ==> n * n = n`;;
  Warning: Free variables in goal: n
  val it : goalstack = 1 subgoal (1 total)

  `n = 1 ==> n * n = n`
\end{verbatim}
}
\noindent a possible initial step is to apply
{\par\samepage\setseps\small
\begin{verbatim}
  # e(STRIP_GOAL_THEN SUBST1_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `1 * 1 = 1`
\end{verbatim}
}
\noindent which is immediate by {\small\verb%ARITH_TAC%}, for example.

\USES
{\small\verb%STRIP_GOAL_THEN%} is used when manipulating intermediate results (obtained by
stripping outer connectives from a goal) directly, rather than as assumptions.

\SEEALSO
CONJ_TAC, DISCH_THEN, GEN_TAC, STRIP_ASSUME_TAC, STRIP_TAC.

\ENDDOC
\DOC{strip{\_}ncomb}

\TYPE {\small\verb%strip_ncomb : int -> term -> term * term list%}\egroup

\SYNOPSIS
Strip away a given number of arguments from a combination.

\DESCRIBE
Given a number {\small\verb%n%} and a combination term {\small\verb%`f a1 ... an`%}, the function
{\small\verb%strip_ncomb%} returns the result of stripping away exactly {\small\verb%n%} arguments:
the pair {\small\verb%`f`,[`a1`;...;`an`]%}. Note that exactly {\small\verb%n%} arguments are stripped
even if {\small\verb%f%} is a combination.

\FAILURE
Fails if there are not {\small\verb%n%} arguments to strip off.

\EXAMPLE
Note how the behaviour is more limited compared with simple {\small\verb%strip_comb%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # strip_ncomb 2 `f u v x y z`;;
  Warning: inventing type variables
  val it : term * term list = (`f u v x`, [`y`; `z`])

  # strip_comb `f u v x y z`;;
  Warning: inventing type variables
  val it : term * term list = (`f`, [`u`; `v`; `x`; `y`; `z`])
\end{verbatim}
}

\USES
Delicate term decompositions.

\SEEALSO
strip_comb.

\ENDDOC
\DOC{STRIP{\_}TAC}

\TYPE {\small\verb%STRIP_TAC : tactic%}\egroup

\SYNOPSIS
Splits a goal by eliminating one outermost connective.

\DESCRIBE
Given a goal {\small\verb%(A,t)%}, {\small\verb%STRIP_TAC%} removes one outermost occurrence of one of
the connectives {\small\verb%!%}, {\small\verb%==>%}, {\small\verb%~%} or {\small\verb%/\%} from the conclusion of the goal {\small\verb%t%}.
If {\small\verb%t%} is a universally quantified term, then {\small\verb%STRIP_TAC%} strips off the
quantifier:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- !x.u
   ==============  STRIP_TAC
     A ?- u[x'/x]
\end{verbatim}
}
\noindent where {\small\verb%x'%} is a primed variant that does not appear free in the
assumptions {\small\verb%A%}.  If {\small\verb%t%} is a conjunction, then {\small\verb%STRIP_TAC%} simply splits the
conjunction into two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- v /\ w
   =================  STRIP_TAC
    A ?- v   A ?- w
\end{verbatim}
}
\noindent If {\small\verb%t%} is an implication, {\small\verb%STRIP_TAC%} moves the antecedent into the
assumptions, stripping conjunctions, disjunctions and existential
quantifiers according to the following rules:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- v1 /\ ... /\ vn ==> v            A ?- v1 \/ ... \/ vn ==> v
   ============================        =================================
       A u {v1,...,vn} ?- v             A u {v1} ?- v ... A u {vn} ?- v

     A ?- ?x.w ==> v
   ====================
    A u {w[x'/x]} ?- v
\end{verbatim}
}
\noindent where {\small\verb%x'%} is a primed variant of {\small\verb%x%} that does not appear free in
{\small\verb%A%}. Finally, a negation {\small\verb%~t%} is treated as the implication {\small\verb%t ==> F%}.

\FAILURE
{\small\verb%STRIP_TAC (A,t)%} fails if {\small\verb%t%} is not a universally quantified term,
an implication, a negation or a conjunction.

\EXAMPLE
Starting with the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m n. m <= n /\ n <= m ==> m = n`;;
\end{verbatim}
}
\noindent the repeated application of {\small\verb%STRIP_TAC%} strips off the universal
quantifiers, breaks apart the antecedent and adds the conjuncts to the
hypotheses:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`m <= n`]
   1 [`n <= m`]

  `m = n`
\end{verbatim}
}

\USES
When trying to solve a goal, often the best thing to do first
is {\small\verb%REPEAT STRIP_TAC%} to split the goal up into manageable pieces.

\SEEALSO
CONJ_TAC, DISCH_TAC, DESTRUCT_TAC, DISCH_THEN, GEN_TAC, INTRO_TAC,
STRIP_ASSUME_TAC, STRIP_GOAL_THEN.

\ENDDOC
\DOC{STRIP{\_}THM{\_}THEN}

\TYPE {\small\verb%STRIP_THM_THEN : thm_tactical%}\egroup

\SYNOPSIS
{\small\verb%STRIP_THM_THEN%} applies the given theorem-tactic using the result of
stripping off one outer connective from the given theorem.

\DESCRIBE
Given a theorem-tactic {\small\verb%ttac%}, a theorem {\small\verb%th%} whose conclusion is a
conjunction, a disjunction or an existentially quantified term, and a goal
{\small\verb%(A,t)%}, {\small\verb%STRIP_THM_THEN ttac th%} first strips apart the conclusion of {\small\verb%th%},
next applies {\small\verb%ttac%} to the theorem(s) resulting from the stripping and then
applies the resulting tactic to the goal.

In particular, when stripping a conjunctive theorem {\small\verb%A' |- u /\ v%}, the tactic
{\par\samepage\setseps\small
\begin{verbatim}
   ttac(u |- u) THEN ttac(v |- v)
\end{verbatim}
}
\noindent resulting from applying {\small\verb%ttac%} to the conjuncts, is applied to the
goal.  When stripping a disjunctive theorem {\small\verb%A' |- u \/ v%}, the tactics
resulting from applying {\small\verb%ttac%} to the disjuncts, are applied to split the goal
into two cases. That is, if
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t                           A ?- t
   =========  ttac (u |- u)    and    =========  ttac (v |- v)
    A ?- t1                          A ?- t2
\end{verbatim}
}
\noindent then:
{\par\samepage\setseps\small
\begin{verbatim}
         A ?- t
   ==================  STRIP_THM_THEN ttac (A' |- u \/ v)
    A ?- t1  A ?- t2
\end{verbatim}
}
\noindent When stripping an existentially quantified theorem {\small\verb%A' |- ?x.u%}, the
tactic {\small\verb%ttac(u |- u)%}, resulting from applying {\small\verb%ttac%} to the body of the
existential quantification, is applied to the goal.  That is, if:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   =========  ttac (u |- u)
    A ?- t1
\end{verbatim}
}
\noindent then:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- t
   =============  STRIP_THM_THEN ttac (A' |- ?x. u)
      A ?- t1
\end{verbatim}
}
The assumptions of the theorem being split are not added to the assumptions of
the goal(s) but are recorded in the proof.  If {\small\verb%A'%} is not a subset of the
assumptions {\small\verb%A%} of the goal (up to alpha-conversion), {\small\verb%STRIP_THM_THEN ttac th%}
results in an invalid tactic.

\FAILURE
{\small\verb%STRIP_THM_THEN ttac th%} fails if the conclusion of {\small\verb%th%} is not a conjunction,
a disjunction or an existentially quantified term.  Failure also occurs if the
application of {\small\verb%ttac%} fails, after stripping the outer connective from the
conclusion of {\small\verb%th%}.

\USES
{\small\verb%STRIP_THM_THEN%} is used enrich the assumptions of a goal with a stripped
version of a previously-proved theorem.

\SEEALSO
CHOOSE_THEN, CONJUNCTS_THEN, DISJ_CASES_THEN, STRIP_ASSUME_TAC.

\ENDDOC
\DOC{STRUCT{\_}CASES{\_}TAC}

\TYPE {\small\verb%STRUCT_CASES_TAC : thm_tactic%}\egroup

\SYNOPSIS
Performs very general structural case analysis.

\DESCRIBE
When it is applied to a theorem of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   th = A' |- ?y11...y1m. x = t1 /\ (B11 /\ ... /\ B1k) \/ ... \/
              ?yn1...ynp. x = tn /\ (Bn1 /\ ... /\ Bnp)
\end{verbatim}
}
\noindent in which there may be no existential quantifiers where a `vector' of
them is shown above, {\small\verb%STRUCT_CASES_TAC th%} splits a goal {\small\verb%A ?- s%} into {\small\verb%n%}
subgoals as follows:
{\par\samepage\setseps\small
\begin{verbatim}
                             A ?- s
   ===============================================================
    A u {B11,...,B1k} ?- s[t1/x] ... A u {Bn1,...,Bnp} ?- s[tn/x]
\end{verbatim}
}
\noindent that is, performs a case split over the possible constructions (the
{\small\verb%ti%}) of a term, providing as assumptions the given constraints, having
split conjoined constraints into separate assumptions. Note that unless {\small\verb%A'%}
is a subset of {\small\verb%A%}, this is an invalid tactic.

\FAILURE
Fails unless the theorem has the above form, namely a conjunction of
(possibly multiply existentially quantified) terms which assert the equality
of the same variable {\small\verb%x%} and the given terms.

\EXAMPLE
Suppose we have the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `~(l:(A)list = []) ==> LENGTH l > 0`;;
\end{verbatim}
}
\noindent then we can get rid of the universal quantifier from the
inbuilt list theorem {\small\verb%list_CASES%}:
{\par\samepage\setseps\small
\begin{verbatim}
   list_CASES = !l. l = [] \/ (?h t. l = CONS h t)
\end{verbatim}
}
\noindent and then use {\small\verb%STRUCT_CASES_TAC%}. This amounts to applying the
following tactic:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(STRUCT_CASES_TAC (SPEC_ALL list_CASES));;
  val it : goalstack = 2 subgoals (2 total)

  `~(CONS h t = []) ==> LENGTH (CONS h t) > 0`

  `~([] = []) ==> LENGTH [] > 0`
\end{verbatim}
}
\noindent and both of these are solvable by {\small\verb%REWRITE_TAC[GT; LENGTH; LT_0]%}.

\USES
Generating a case split from the axioms specifying a structure.

\SEEALSO
ASM_CASES_TAC, BOOL_CASES_TAC, COND_CASES_TAC, DISJ_CASES_TAC,
STRUCT_CASES_THEN.

\ENDDOC
\DOC{STRUCT{\_}CASES{\_}THEN}

\TYPE {\small\verb%STRUCT_CASES_THEN : thm_tactic -> thm_tactic%}\egroup

\SYNOPSIS
Performs structural case analysis, applying theorem-tactic to results.

\DESCRIBE
When it is applied to a theorem-tactic {\small\verb%ttac%} and a theorem {\small\verb%th%} of the form:
{\par\samepage\setseps\small
\begin{verbatim}
   th = A' |- ?y11...y1m. x = t1 /\ (B11 /\ ... /\ B1k) \/ ... \/
              ?yn1...ynp. x = tn /\ (Bn1 /\ ... /\ Bnp)
\end{verbatim}
}
\noindent in which there may be no existential quantifiers where a `vector' of
them is shown above, {\small\verb%STRUCT_CASES_THEN ttac th%} splits a goal {\small\verb%A ?- s%} into
{\small\verb%n%} subgoals, where goal {\small\verb%k%} results the initial goal by applying {\small\verb%ttac%} to the
theorem {\small\verb%x = tn |- x = tn%}. That is, it performs a case split over the possible
constructions (the {\small\verb%ti%}) of a term and applies {\small\verb%ttac%} to the resulting case
assumptions. Note that unless {\small\verb%A'%} is a subset of {\small\verb%A%}, this is an invalid
tactic.

\FAILURE
Fails unless the theorem has the above form, namely a conjunction of
(possibly multiply existentially quantified) terms which assert the equality
of the same variable {\small\verb%x%} and the given terms.

\EXAMPLE
Suppose we have the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `n > 0 ==> PRE(n) + 1 = n`;;
\end{verbatim}
}
\noindent We can use the inbuilt theorem {\small\verb%num_CASES%} to perform a case analysis
on {\small\verb%n%}, adding each case as a new assumption by {\small\verb%ASSUME_TAC%} like this:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(STRUCT_CASES_THEN ASSUME_TAC (SPEC `n:num` num_CASES));;
  val it : goalstack = 2 subgoals (2 total)

    0 [`n = SUC n'`]

  `n > 0 ==> PRE n + 1 = n`

    0 [`n = 0`]

  `n > 0 ==> PRE n + 1 = n`
\end{verbatim}
}

\USES
Generating a case split from the axioms specifying a structure.

\SEEALSO
ASM_CASES_TAC, BOOL_CASES_TAC, COND_CASES_TAC, DISJ_CASES_TAC,
STRUCT_CASES_TAC.

\ENDDOC
\DOC{SUBGOAL{\_}TAC}

\TYPE {\small\verb%SUBGOAL_TAC : string -> term -> tactic list -> tactic%}\egroup

\SYNOPSIS
Encloses the sub-proof of a named lemma.

\DESCRIBE
The call {\small\verb%SUBGOAL_TAC "name" `t` [tac]%} introduces a new subgoal {\small\verb%t%} with the
current assumptions, runs on that subgoal the tactic {\small\verb%tac%}, and attaches the
result as a new hypothesis called {\small\verb%name%} in the current subgoal. The {\small\verb%[tac]%}
argument is always a one-element list, for stylistic reasons. If {\small\verb%tac%} does not
prove the goal, any resulting subgoals from it will appear first.

\FAILURE
Fails if {\small\verb%t%} is not Boolean or if {\small\verb%tac%} fails on it.

\EXAMPLE
If we want to prove
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(n MOD 2) IN {0,1}`;;
\end{verbatim}
}
\noindent we might start by establishing a lemma:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SUBGOAL_TAC "ml2" `n MOD 2 < 2` [SIMP_TAC[DIVISION; ARITH]]);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`n MOD 2 < 2`] (ml2)

  `n MOD 2 IN {0, 1}`
\end{verbatim}
}
\noindent after which, for example, we could finish things with
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REWRITE_TAC[IN_INSERT; NOT_IN_EMPTY] THEN
      POP_ASSUM MP_TAC THEN ARITH_TAC);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Structuring proofs via a sequence of simple lemmas.

\SEEALSO
CLAIM_TAC, SUBGOAL_THEN.

\ENDDOC
\DOC{SUBGOAL{\_}THEN}

\TYPE {\small\verb%SUBGOAL_THEN : term -> thm_tactic -> tactic%}\egroup

\SYNOPSIS
Introduces a lemma as a new subgoal.

\DESCRIBE
The user proposes a lemma and is then invited to prove it under the current
assumptions. The lemma is then used with the {\small\verb%thm_tactic%} to apply to the goal.
That is, if
{\par\samepage\setseps\small
\begin{verbatim}
    A1 ?- t1
   ==========  ttac (t |- t)
    A2 ?- t2
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
         A1 ?- t1
   ====================  SUBGOAL_THEN `t` ttac
    A1 ?- t   A2 ?- t2
\end{verbatim}
}
In the quite common special case where {\small\verb%ttac%} is {\small\verb%ASSUME_TAC%}, the net
behaviour is simply to present the user with two subgoals, one in which the
lemma is to be proved and one in which it may be assumed:
{\par\samepage\setseps\small
\begin{verbatim}
         A1 ?- t1
   ============================  SUBGOAL_THEN `t` ASSUME_TAC
    A1 ?- t   A1 u {t} ?- t2
\end{verbatim}
}

\FAILURE
{\small\verb%SUBGOAL_THEN%} will fail if an attempt is made to use a non-boolean term as a
lemma.

\USES
Introducing lemmas into the same basic proof script without separately binding
them to names. This is often a good structuring technique for large tactic
proofs, where separate lemmas might look artificial because of all the ad-hoc
context in which they occur.

\EXAMPLE
Consider the proof of the Knaster-Tarski fixpoint theorem, to be found in
{\small\verb%Library/card.ml%}. This (in its set-lattice context) states that every
monotonic function has a fixpoint. After setting the initial goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!f. (!s t. s SUBSET t ==> f(s) SUBSET f(t)) ==> ?s:A->bool. f(s) = s`;;
\end{verbatim}
}
\noindent we start off the proof, already proceeding via a series of lemmas
with {\small\verb%SUBGOAL_THEN%}, though we will focus our attention on a later one:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC THEN MAP_EVERY ABBREV_TAC
       [`Y = {b:A->bool | f(b) SUBSET b}`; `a:A->bool = INTERS Y`] THEN
      SUBGOAL_THEN `!b:A->bool. b IN Y <=> f(b) SUBSET b` ASSUME_TAC THENL
       [EXPAND_TAC "Y" THEN REWRITE_TAC[IN_ELIM_THM]; ALL_TAC] THEN
      SUBGOAL_THEN `!b:A->bool. b IN Y ==> f(a:A->bool) SUBSET b`
      ASSUME_TAC THENL
       [ASM_MESON_TAC[SUBSET_TRANS; IN_INTERS; SUBSET]; ALL_TAC]);;
  ...
  val it : goalstack = 1 subgoal (1 total)

   0 [`!s t. s SUBSET t ==> f s SUBSET f t`]
   1 [`{b | f b SUBSET b} = Y`]
   2 [`INTERS Y = a`]
   3 [`!b. b IN Y <=> f b SUBSET b`]
   4 [`!b. b IN Y ==> f a SUBSET b`]

  `?s. f s = s`
\end{verbatim}
}
Now we select a particularly interesting lemma:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(SUBGOAL_THEN `f(a:A->bool) SUBSET a` ASSUME_TAC);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`!s t. s SUBSET t ==> f s SUBSET f t`]
   1 [`{b | f b SUBSET b} = Y`]
   2 [`INTERS Y = a`]
   3 [`!b. b IN Y <=> f b SUBSET b`]
   4 [`!b. b IN Y ==> f a SUBSET b`]
   5 [`f a SUBSET a`]

  `?s. f s = s`

   0 [`!s t. s SUBSET t ==> f s SUBSET f t`]
   1 [`{b | f b SUBSET b} = Y`]
   2 [`INTERS Y = a`]
   3 [`!b. b IN Y <=> f b SUBSET b`]
   4 [`!b. b IN Y ==> f a SUBSET b`]

  `f a SUBSET a`
\end{verbatim}
}
\noindent The lemma is relatively easy to prove by giving {\small\verb%MESON_TAC%} the right
lemmas:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_MESON_TAC[IN_INTERS; SUBSET]);;
  ...
  val it : goalstack = 1 subgoal (1 total)

   0 [`!s t. s SUBSET t ==> f s SUBSET f t`]
   1 [`{b | f b SUBSET b} = Y`]
   2 [`INTERS Y = a`]
   3 [`!b. b IN Y <=> f b SUBSET b`]
   4 [`!b. b IN Y ==> f a SUBSET b`]
   5 [`f a SUBSET a`]

  `?s. f s = s`
\end{verbatim}
}
\noindent and the remaining subgoal is also quite easy for {\small\verb%MESON_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_MESON_TAC[SUBSET_ANTISYM; IN_INTERS]);;
  ...
  val it : goalstack = No subgoals
\end{verbatim}
}
On the other hand, without splitting off the last lemmas, {\small\verb%MESON_TAC%} finds the
automated step rather large. If you step back three steps with
{\par\samepage\setseps\small
\begin{verbatim}
  # b(); b(); b();;
\end{verbatim}
}
\noindent then although the following works, it takes half a minute:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_MESON_TAC[IN_INTERS; SUBSET; SUBSET_ANTISYM]);;
  ....
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
CLAIM_TAC, MATCH_MP_TAC, MP_TAC, SUBGOAL_TAC.

\ENDDOC
\DOC{SUBLET{\_}CONV}

\TYPE {\small\verb%SUBLET_CONV : conv -> term -> thm%}\egroup

\SYNOPSIS
Applies subconversion to RHSs of toplevel let-term

\DESCRIBE
Given a basic conversion {\small\verb%conv%}, the conversion {\small\verb%SUBLET_CONV conv%} applies that
conversion to the right-hand sides of a toplevel let-term of the form
{\par\samepage\setseps\small
\begin{verbatim}
   let v1 = t1 and ... and vn = tn in t
\end{verbatim}
}
\noindent resulting in the following theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (let v1 = t1 and ... and vn = tn in t) =
      (let v1 = t1' and ... and vn = tn' in t)
\noindent where applying {\small\verb%conv%} to {\small\verb%ti%} results in the theorem {\small\verb%|- ti = ti'%}.

\FAILURE
{\small\verb%SUBLET_CONV conv tm%} fails if {\small\verb%tm%} is not a {\small\verb%let%}-term, or if the conversion
{\small\verb%conv%} fails on any of its RHSs.

\EXAMPLE
This applies it to perform numeric addition on the {\small\verb%let%}-term:
{\par\samepage\setseps\small
\begin{verbatim}
  # SUBLET_CONV NUM_ADD_CONV
     `let x = 5 + 2 and y = 8 + 17 and z = 3 + 7 in x + y + z`;;
  val it : thm =
    |- (let x = 5 + 2 and y = 8 + 17 and z = 3 + 7 in x + y + z) =
       (let x = 7 and y = 25 and z = 10 in x + y + z)
\end{verbatim}
}

\SEEALSO
BETA_CONV, GEN_BETA_CONV, let_CONV.

\ENDDOC
\DOC{SUBS}

\TYPE {\small\verb%SUBS : thm list -> thm -> thm%}\egroup

\SYNOPSIS
Makes simple term substitutions in a theorem using a given list of theorems.

\DESCRIBE
Term substitution in HOL is performed by replacing free subterms according to
the transformations specified by a list of equational theorems.  Given a list
of theorems {\small\verb%A1|-t1=v1,...,An|-tn=vn%} and a theorem {\small\verb%A|-t%}, {\small\verb%SUBS%}
simultaneously replaces each free occurrence of {\small\verb%ti%} in {\small\verb%t%} with {\small\verb%vi%}:
{\par\samepage\setseps\small
\begin{verbatim}
          A1|-t1=v1 ... An|-tn=vn    A|-t
   ---------------------------------------------  SUBS[A1|-t1=v1;...;An|-tn=vn]
    A1 u ... u An u A |- t[v1,...,vn/t1,...,tn]       (A|-t)
\end{verbatim}
}
\noindent No matching is involved; the occurrence of each {\small\verb%ti%} being
substituted for must be a free in {\small\verb%t%} (see {\small\verb%SUBST_MATCH%}).  An occurrence which
is not free can be substituted by using rewriting rules such as {\small\verb%REWRITE_RULE%},
{\small\verb%PURE_REWRITE_RULE%} and {\small\verb%ONCE_REWRITE_RULE%}.

\FAILURE
{\small\verb%SUBS [th1;...;thn] (A|-t)%} fails if the conclusion of each theorem in the list
is not an equation.  No change is made to the theorem {\small\verb%A |- t%} if no occurrence
of any left-hand side of the supplied equations appears in {\small\verb%t%}.

\EXAMPLE
Substitutions are made with the theorems
{\par\samepage\setseps\small
\begin{verbatim}
 # let thm1 = SPEC_ALL ADD_SYM
   and thm2 = SPEC_ALL(CONJUNCT1 ADD_CLAUSES);;
  val thm1 : thm = |- m + n = n + m
  val thm2 : thm = |- 0 + n = n
\end{verbatim}
}
\noindent depending on the occurrence of free subterms
{\par\samepage\setseps\small
\begin{verbatim}
  # SUBS [thm1; thm2] (ASSUME `(n + 0) + (0 + m) = m + n`);;
  val it : thm = (n + 0) + 0 + m = m + n |- (n + 0) + 0 + m = n + m

  # SUBS [thm1; thm2] (ASSUME `!n. (n + 0) + (0 + m) = m + n`);;
  val it : thm = !n. (n + 0) + 0 + m = m + n |- !n. (n + 0) + 0 + m = m + n
\end{verbatim}
}
\USES
{\small\verb%SUBS%} can sometimes be used when rewriting (for example, with {\small\verb%REWRITE_RULE%})
would diverge and term instantiation is not needed.  Moreover, applying the
substitution rules is often much faster than using the rewriting rules.

\SEEALSO
ONCE_REWRITE_RULE, PURE_REWRITE_RULE, REWRITE_RULE, SUBS_CONV.

\ENDDOC
\DOC{subset}

\TYPE {\small\verb%subset : 'a list -> 'a list -> bool%}\egroup

\SYNOPSIS
Tests if one list is a subset of another.

\DESCRIBE
The call {\small\verb%subset l1 l2%} returns {\small\verb%true%} if every element of {\small\verb%l1%} also occurs in
{\small\verb%l2%}, regardless of whether an element appears once or more than once in each
list. So when {\small\verb%l1%} and {\small\verb%l2%} are regarded as sets, this is a subset test.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # subset [1;1;2;2] [1;2;3];;
  val it : bool = true
\end{verbatim}
}

\SEEALSO
insert, intersect, set_eq, setify, subtract, union.

\ENDDOC
\DOC{subst}

\TYPE {\small\verb%subst : (term * term) list -> term -> term%}\egroup

\SYNOPSIS
Substitute terms for other terms inside a term.

\DESCRIBE
The call {\small\verb%subst [t1',t1; ...; tn',tn] t%} systematically replaces free instances
of each term {\small\verb%ti%} inside {\small\verb%t%} with the corresponding {\small\verb%ti'%} from the
instantiation list. (A subterm is considered free if none of its free variables
are bound by its context.) Bound variables will be renamed if necessary to
avoid capture.

\FAILURE
Fails if any of the pairs {\small\verb%ti',ti%} in the instantiation list has {\small\verb%ti%} and {\small\verb%ti'%}
with different types. Multiple instances of the same {\small\verb%ti%} in the list are not
trapped, but only the first one will be used consistently.

\EXAMPLE
Here is a relatively simple example
{\par\samepage\setseps\small
\begin{verbatim}
  # subst [`x + 1`,`1 + 2`] `(1 + 2) + 1 + 2 + 3`;;
  val it : term = `(x + 1) + 1 + 2 + 3`
\end{verbatim}
}
\noindent and here is a more complex instance where renaming of bound variables
is needed:
{\par\samepage\setseps\small
\begin{verbatim}
  # subst [`x:num`,`1`] `!x. x > 0 <=> x >= 1`;;
  val it : term = `!x'. x' > 0 <=> x' >= x`
\end{verbatim}
}

\COMMENTS
This is the most general term substitution function, but if all the {\small\verb%ti%} are
variables, the {\small\verb%vsubst%} function is more efficient.

\SEEALSO
inst, vsubst.

\ENDDOC
\DOC{SUBST1{\_}TAC}

\TYPE {\small\verb%SUBST1_TAC : thm_tactic%}\egroup

\SYNOPSIS
Makes a simple term substitution in a goal using a single equational theorem.

\DESCRIBE
Given a theorem {\small\verb%A' |- u = v%} and a goal {\small\verb%(A ?- t)%}, the tactic {\small\verb%SUBST1_TAC (A'
|- u = v)%} rewrites the term {\small\verb%t%} into {\small\verb%t[v/u]%}, by substituting {\small\verb%v%} for each
free occurrence of {\small\verb%u%} in {\small\verb%t%}:
{\par\samepage\setseps\small
\begin{verbatim}
      A ?- t
   =============  SUBST1_TAC (A' |- u = v)
    A ?- t[v/u]
\end{verbatim}
}
\noindent The assumptions of the theorem used to substitute with are not added
to the assumptions of the goal but are recorded in the proof.  If {\small\verb%A'%} is not a
subset of the assumptions {\small\verb%A%} of the goal (up to alpha-conversion), then
{\small\verb%SUBST1_TAC (A' |- u = v)%} results in an invalid tactic. {\small\verb%SUBST1_TAC%}
automatically renames bound variables to prevent free variables in {\small\verb%v%} becoming
bound after substitution. However, by contrast with rewriting tactics such as
{\small\verb%REWRITE_TAC%}, it does not instantiate free or universally quantified variables
in the theorem to make them match the target term. This makes it less powerful
but also more precisely controlled.

\FAILURE
{\small\verb%SUBST1_TAC th (A ?- t)%} fails if the conclusion of {\small\verb%th%} is not an equation.
No change is made to the goal if no free occurrence of the left-hand side
of {\small\verb%th%} appears in {\small\verb%t%}.

\EXAMPLE
Suppose we start with the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!p x y. 1 = x /\ p(1) ==> p(x)`;;
\end{verbatim}
}
We could, of course, solve it immediately with {\small\verb%MESON_TAC[]%}. However, for a
more ``manual'' proof, we might do:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`1 = x`]
   1 [`p 1`]

  `p x`
\end{verbatim}
}
\noindent and then use {\small\verb%SUBST1_TAC%} to substitute:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(FIRST_X_ASSUM(SUBST1_TAC o SYM));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`p 1`]

  `p 1`
\end{verbatim}
}
\noindent after which just {\small\verb%ASM_REWRITE_TAC[]%} will finish.

\USES
{\small\verb%SUBST1_TAC%} can be used when rewriting with a single theorem using tactics
such as {\small\verb%REWRITE_TAC%} is too expensive or would diverge.

\SEEALSO
ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC, SUBS_CONV, SUBST_ALL_TAC.

\ENDDOC
\DOC{SUBST{\_}ALL{\_}TAC}

\TYPE {\small\verb%SUBST_ALL_TAC : thm -> tactic%}\egroup

\SYNOPSIS
Substitutes using a single equation in both the assumptions and conclusion of a
goal.

\DESCRIBE
{\small\verb%SUBST_ALL_TAC%} breaches the style of natural deduction, where the assumptions
are kept fixed.  Given a theorem {\small\verb%A |- u = v%} and a goal {\small\verb%([A1;...;An] ?-  t)%},
{\small\verb%SUBST_ALL_TAC (A |- u = v)%} transforms the assumptions {\small\verb%A1%},...,{\small\verb%An%} and the
term {\small\verb%t%} into {\small\verb%A1[v/u]%},...,{\small\verb%An[v/u]%} and {\small\verb%t[v/u]%} respectively, by
substituting {\small\verb%v%} for each free occurrence of {\small\verb%u%} in both the assumptions and
the conclusion of the goal.
{\par\samepage\setseps\small
\begin{verbatim}
           {A1,...,An} ?- t
   =================================  SUBST_ALL_TAC (A |- u = v)
    {A1[v/u],...,An[v/u]} ?- t[v/u]
\end{verbatim}
}
\noindent The assumptions of the theorem used to substitute with are not added
to the assumptions of the goal, but they are recorded in the proof.  If {\small\verb%A%} is
not a subset of the assumptions of the goal (up to alpha-conversion), then
{\small\verb%SUBST_ALL_TAC (A |- u = v)%} results in an invalid tactic.

{\small\verb%SUBST_ALL_TAC%} automatically renames bound variables to prevent
free variables in {\small\verb%v%} becoming bound after substitution.

\FAILURE
{\small\verb%SUBST_ALL_TAC th (A ?- t)%} fails if the conclusion of {\small\verb%th%} is not an equation.
No change is made to the goal if no occurrence of the left-hand side of
{\small\verb%th%} appears free in {\small\verb%(A ?- t)%}.

\EXAMPLE
Suppose we start with the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!p x y. 1 = x /\ p(x - 1) ==> p(x EXP 2 - x)`;;
\end{verbatim}
}
\noindent and, as often, begin by breaking it down routinely:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`1 = x`]
   1 [`p (x - 1)`]

  `p (x EXP 2 - x)`
\end{verbatim}
}
\noindent Now we can use {\small\verb%SUBST_ALL_TAC%} to substitute {\small\verb%1%} for {\small\verb%x%} in both
assumptions and conclusion:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(FIRST_X_ASSUM(SUBST_ALL_TAC o SYM));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`p (1 - 1)`]

  `p (1 EXP 2 - 1)`
\end{verbatim}
}
One can finish things off in various ways, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # e(POP_ASSUM MP_TAC THEN CONV_TAC NUM_REDUCE_CONV THEN REWRITE_TAC[]);;
\end{verbatim}
}

\SEEALSO
ONCE_REWRITE_TAC, PURE_REWRITE_TAC, REWRITE_TAC, SUBS_CONV, SUBST1_TAC.

\ENDDOC
\DOC{SUBST{\_}VAR{\_}TAC}

\TYPE {\small\verb%SUBST_VAR_TAC : thm -> tactic%}\egroup

\SYNOPSIS
Use an equation to substitute ``safely'' in goal.

\DESCRIBE
When applied to a theorem with an equational hypothesis {\small\verb%A |- s = t%}, {\small\verb%SUBST_
VAR_TAC%} has no effect if {\small\verb%s%} and {\small\verb%t%} are alpha-equivalent. Otherwise, if
either side of the equation is a variable not free in the other side, or a
constant, and the conclusion contains no free variables not free in some
assumption of the goal, then the theorem is used to replace that constant or
variable throughout the goal, assumptions and conclusions. If none of these
cases apply, or the conclusion is not even an equation, the application fails.

\FAILURE
Fails if applied to a non-equation for which none of the cases above hold.

\USES
By some sequence like {\small\verb%REPEAT(FIRST_X_ASSUM SUBST_VAR_TAC)%} one can use all
possible assumptions to substitute ``safely'', in the sense that it will not
change the provability status of the goal. This is sometimes a useful prelude
to other automatic techniques.

\COMMENTS

\SEEALSO
SUBST1_TAC, SUBST_ALL_TAC.

\ENDDOC
\DOC{SUBS{\_}CONV}

\TYPE {\small\verb%SUBS_CONV : thm list -> term -> thm%}\egroup

\SYNOPSIS
Substitution conversion.

\DESCRIBE
The call {\small\verb%SUBS_CONV [th1; ...; th2] t%}, where the theorems in the list are all
equations, will return the theorem {\small\verb%|- t = t'%} where {\small\verb%t'%} results from
substituting any terms that are the same as the left-hand side of some {\small\verb%thi%}
with the corresponding right-hand side. Note that no matching or instantiation
is done, in contrast to rewriting conversions.

\FAILURE
May fail if the theorems are not equational.

\EXAMPLE
Here we substitute with a simplification theorem, but only instances that are
the same as the LHS:
{\par\samepage\setseps\small
\begin{verbatim}
  # SUBS_CONV[ARITH_RULE `x + 0 = x`] `(x + 0) + (y + 0) + (x + 0) + (0 + 0)`;;
  val it : thm =
    |- (x + 0) + (y + 0) + (x + 0) + 0 + 0 = x + (y + 0) + x + 0 + 0
\end{verbatim}
}
\noindent By contrast, the analogous rewriting conversion will treat the
variable {\small\verb%x%} as universally quantified and replace more subterms by matching
the LHS against them:
{\par\samepage\setseps\small
\begin{verbatim}
  # REWRITE_CONV[ARITH_RULE `x + 0 = x`]
     `(x + 0) + (y + 0) + (x + 0) + (0 + 0)`;;
  val it : thm = |- (x + 0) + (y + 0) + (x + 0) + 0 + 0 = x + y + x
\end{verbatim}
}

\SEEALSO
GEN_REWRITE_CONV, REWR_CONV, REWRITE_CONV, PURE_REWRITE_CONV.

\ENDDOC
\DOC{subtract}

\TYPE {\small\verb%subtract : 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Computes the set-theoretic difference of two `sets'.

\DESCRIBE
{\small\verb%subtract l1 l2%} returns a list consisting of those elements of {\small\verb%l1%} that do
not appear in {\small\verb%l2%}. If both lists are initially free of repetitions, this can
be considered a set difference operation.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # subtract [1;2;3] [3;5;4;1];;
  val it : int list = [2]
  # subtract [1;2;4;1] [4;5];;
  val it : int list = [1; 2; 1]
\end{verbatim}
}

\SEEALSO
setify, set_eq, union, intersect.

\ENDDOC
\DOC{subtract'}

\TYPE {\small\verb%subtract' : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Subtraction of sets modulo an equivalence.

\DESCRIBE
The call {\small\verb%subtract' r l1 l2%} removes from the list {\small\verb%l1%} all elements {\small\verb%x%} such
that there is an {\small\verb%x'%} in {\small\verb%l2%} with {\small\verb%r x x'%}. If {\small\verb%l1%} and {\small\verb%l2%} were free of
equivalents under {\small\verb%r%}, the resulting list will be too, so this is a set
operation modulo an equivalence. The function {\small\verb%subtract%} is the special case
where the relation is just equality.

\FAILURE
Fails only if the function {\small\verb%r%} fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # subtract' (fun x y -> abs(x) = abs(y)) [-1; 2; 1] [-2; -3; 4; -4];;
  val it : int list = [-1; 1]
\end{verbatim}
}

\USES
Maintaining sets modulo an equivalence such as alpha-equivalence.

\SEEALSO
insert', mem', union, union', unions'.

\ENDDOC
\DOC{SUB{\_}CONV}

\TYPE {\small\verb%SUB_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion to the top-level subterms of a term.

\DESCRIBE
For any conversion {\small\verb%c%}, the function returned by {\small\verb%SUB_CONV c%} is a conversion
that applies {\small\verb%c%} to all the top-level subterms of a term.  If the conversion
{\small\verb%c%} maps {\small\verb%t%} to {\small\verb%|- t = t'%}, then {\small\verb%SUB_CONV c%} maps an abstraction {\small\verb%`\x. t`%} to
the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (\x. t) = (\x. t')
\end{verbatim}
}
\noindent That is, {\small\verb%SUB_CONV c `\x. t`%} applies {\small\verb%c%} to the body of the
abstraction {\small\verb%`\x. t`%}.  If {\small\verb%c%} is a conversion that maps {\small\verb%`t1`%} to the theorem
{\small\verb%|- t1 = t1'%} and {\small\verb%`t2`%} to the theorem {\small\verb%|- t2 = t2'%}, then the conversion
{\small\verb%SUB_CONV c%} maps an application {\small\verb%`t1 t2`%} to the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- (t1 t2) = (t1' t2')
\end{verbatim}
}
\noindent That is, {\small\verb%SUB_CONV c `t1 t2`%} applies {\small\verb%c%} to the both the operator
{\small\verb%t1%} and the operand {\small\verb%t2%} of the application {\small\verb%`t1 t2`%}.  Finally, for any
conversion {\small\verb%c%}, the function returned by {\small\verb%SUB_CONV c%} acts as the identity
conversion on variables and constants.  That is, if {\small\verb%`t`%} is a variable or
constant, then {\small\verb%SUB_CONV c `t`%} returns {\small\verb%|- t = t%}.

\FAILURE
{\small\verb%SUB_CONV c tm%} fails if {\small\verb%tm%} is an abstraction {\small\verb%`\x. t`%} and the conversion {\small\verb%c%}
fails when applied to {\small\verb%t%}, or if {\small\verb%tm%} is an application {\small\verb%`t1 t2`%} and the
conversion {\small\verb%c%} fails when applied to either {\small\verb%t1%} or {\small\verb%t2%}.  The function
returned by {\small\verb%SUB_CONV c%} may also fail if the ML function {\small\verb%c%} is not, in fact,
a conversion (i.e. a function that maps a term {\small\verb%t%} to a theorem {\small\verb%|- t = t'%}).

\SEEALSO
ABS_CONV, COMB_CONV, RAND_CONV, RATOR_CONV.

\ENDDOC
\DOC{SYM}

\TYPE {\small\verb%SYM : thm -> thm%}\egroup

\SYNOPSIS
Swaps left-hand and right-hand sides of an equation.

\DESCRIBE
When applied to a theorem {\small\verb%A |- t1 = t2%}, the inference rule {\small\verb%SYM%} returns
{\small\verb%A |- t2 = t1%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t1 = t2
   --------------  SYM
    A |- t2 = t1
\end{verbatim}
}

\FAILURE
Fails unless the theorem is equational.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # NUM_REDUCE_CONV `12 * 12`;;
  val it : thm = |- 12 * 12 = 144

  # SYM it;;
  val it : thm = |- 144 = 12 * 12
\end{verbatim}
}

\COMMENTS
The {\small\verb%SYM%} rule requires the input theorem to be a simple equation, without
additional structure such as outer universal quantifiers. To reverse equality
signs deeper inside theorems, you may use {\small\verb%GSYM%} instead.

\SEEALSO
GSYM, REFL, TRANS.

\ENDDOC
\DOC{SYM{\_}CONV}

\TYPE {\small\verb%SYM_CONV : term -> thm%}\egroup

\SYNOPSIS
Interchanges the left and right-hand sides of an equation.

\DESCRIBE
When applied to an equational term {\small\verb%t1 = t2%}, the conversion
{\small\verb%SYM_CONV%} returns the theorem:
{\par\samepage\setseps\small
\begin{verbatim}
   |- t1 = t2 <=> t2 = t1
\end{verbatim}
}

\FAILURE
Fails if applied to a term that is not an equation.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # SYM_CONV `2 = x`;;
  val it : thm = |- 2 = x <=> x = 2
\end{verbatim}
}

\SEEALSO
SYM.

\ENDDOC
\DOC{TAC{\_}PROOF}

\TYPE {\small\verb%TAC_PROOF : goal * tactic -> thm%}\egroup

\SYNOPSIS
Attempts to prove a goal using a given tactic.

\DESCRIBE
When applied to a goal-tactic pair {\small\verb%(A ?- t,tac)%}, the {\small\verb%TAC_PROOF%} function
attempts to prove the goal {\small\verb%A ?- t%}, using the tactic {\small\verb%tac%}. If it succeeds, it
returns the theorem {\small\verb%A' |- t%} corresponding to the goal, where the assumption
list {\small\verb%A'%} may be a proper superset of {\small\verb%A%} unless the tactic is valid; there
is no inbuilt validity checking.

\FAILURE
Fails unless the goal has hypotheses and conclusions all of type {\small\verb%bool%},
and the tactic can solve the goal.

\SEEALSO
prove, VALID.

\ENDDOC
\DOC{TARGET{\_}REWRITE{\_}TAC}

\TYPE {\small\verb%TARGET_REWRITE_TAC : thm list -> thm -> tactic%}\egroup

\SYNOPSIS
Performs target implicational rewriting.

\DESCRIBE
Given a theorem {\small\verb%th%} (the ``support theorem''), and another theorem {\small\verb%uh%} (the
``target theorem''), target rewriting generates all the goals that can be
obtained by rewriting with {\small\verb%th%}, until it becomes possible to rewrite with
{\small\verb%uh%}. Contrarily to standard rewriting techniques, only one position is
rewritten at a time ({\small\verb%REWRITE_TAC%}, {\small\verb%SIMP_TAC%}, {\small\verb%IMP_REWRITE_TAC%}, or even
{\small\verb%ONCE_REWRITE_TAC%} apply rewriting to several parallel positions if
applicable). Therefore only the rewrites that are useful for the application
of the theorem {\small\verb%uh%} are achieved in the end. More precisely, given a list of
theorems {\small\verb%[th_1;...;th_k]%} of the form {\small\verb%!x_1... x_n. P ==> !y_1... y_m. l = r%},
and a theorem {\small\verb%uh%} of the form {\small\verb%!x_1... x_n. Q ==> !y_1... y_m. l' = r'%},
{\small\verb%TARGET_REWRITE_TAC [th_1;...;th_k] uh%} applies target implicational rewriting,
i.e. tries all the possible implicational rewrites with {\small\verb%th_1%}, ..., {\small\verb%th_k%}
until it obtains a goal where implicational rewrite with {\small\verb%uh%} becomes possible.

To understand better the difference with {\small\verb%REWRITE_TAC%} and the need for a
target theorem, consider a goal g where more than one subterm can be rewritten
using {\small\verb%th%}: with {\small\verb%REWRITE_TAC%}, all such subterms are rewritten simultaneously;
whereas, with {\small\verb%TARGET_REWRITE_TAC%}, every of these subterms are rewritten
independently, thus yielding as many goals. If one of these goals can be
rewritten (in one position or more) by {\small\verb%uh%}, then the tactic returns this goal.
Otherwise, the ``one-subterm rewriting'' is applied again on every of the new
goals, iteratively until a goal which can be rewritten by {\small\verb%uh%} is obtained.


\FAILURE
Fails if no rewrite can be achieved using the support theorems.
It may also fail if no path is found to apply the target theorem,
but, most of the time, it does not terminate in this situation.

\EXAMPLE
This is a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_ADD_RINV;;
  val it : thm = |- !x. x + --x = &0
  # g `!x y z. --y + x + y = &0`;;
  Warning: inventing type variables
  val it : goalstack = 1 subgoal (1 total)

  `!x y z. --y + x + y = &0`

  # e(TARGET_REWRITE_TAC[REAL_ADD_AC] REAL_ADD_RINV);;
  val it : goalstack = 1 subgoal (1 total)

  `!x. x + &0 = &0`
\end{verbatim}
}
And a slightly more complex one:
{\par\samepage\setseps\small
\begin{verbatim}
  # REAL_MUL_RINV;;
  val it : thm = |- !x. ~(x = &0) ==> x * inv x = &1
  # g `!x y. inv y * x * y = x`;;
  Warning: inventing type variables
  val it : goalstack = 1 subgoal (1 total)

  `!x y z. inv y * x * y = x`

  # e(TARGET_REWRITE_TAC[REAL_MUL_AC] REAL_MUL_RINV);;
  val it : goalstack = 1 subgoal (1 total)

  `!x y. x * &1 = x / ~(y = &0)`
\end{verbatim}
}
Let us finally consider an example which does not involve associativity and
commutativity. Consider the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!z. norm (cnj z) = norm z`;;
  val it : goalstack = 1 subgoal (1 total)

  `!z. norm (cnj z) = norm z`
\end{verbatim}
}
A preliminary step here is to decompose the left-side z into its polar
coordinates. This can be done by applying the following theorem:
{\par\samepage\setseps\small
\begin{verbatim}
  # ARG;;
  val it : thm =
  |- !z. &0 <= Arg z /\ Arg z < &2 * pi /\ z = Cx (norm z) * cexp (ii * Cx (Arg z))
\end{verbatim}
}
But using standard rewriting would rewrite both sides and would not terminate
(or actually, in the current implementation of {\small\verb%REWRITE_TAC%}, simply would not
apply). Instead we can use {\small\verb%TARGET_REWRITE_TAC%} by noting that we actually plan
to decompose into polar coordinates with the intention of using {\small\verb%CNJ_MUL%}
afterwards, which yields:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(TARGET_REWRITE_TAC[ARG] CNJ_MUL);;
  val it : goalstack = 1 subgoal (1 total)

  `!z. norm (cnj (Cx (norm z)) * cnj (cexp (ii * Cx (Arg z)))) = norm z`
\end{verbatim}
}

\USES
This tactic is useful each time someone does not want to rewrite a theorem
everywhere or if a rewriting diverges. Therefore, it can replace most calls to
{\small\verb%ONCE_REWRITE_TAC%} or {\small\verb%GEN_REWRITE_TAC%}: most of the time, these tactics are
used to control rewriting more precisely than {\small\verb%REWRITE_TAC%}. However, their use
is tedious and time-consuming whereas the corresponding reasoning is not
complex. In addition, even when the user manages to come out with a working
tactic, this tactic is generally very fragile. Instead, with
{\small\verb%TARGET_REWRITE_TAC%}, the user does not have to think about the low-level
control of rewriting but just gives the theorem which corresponds to the next
step in the proof (see examples): this is extremely simple and fast to devise.
Note in addition that, contrarily to an explicit (and therefore fragile) path,
the target theorem represents a reasoning step which has few chances to change
in further refinements of the script.

When using associativity-commutativity theorems as support theorems, this
tactic allows to achieve AC-rewriting.

\SEEALSO
CASE_REWRITE_TAC, IMP_REWRITE_TAC, REWRITE_TAC, SEQ_IMP_REWRITE_TAC, SIMP_TAC.

\ENDDOC
\DOC{TAUT}

\TYPE {\small\verb%TAUT : term -> thm%}\egroup

\SYNOPSIS
Proves a propositional tautology.

\DESCRIBE
The call {\small\verb%TAUT `t`%} where {\small\verb%t%} is a propositional tautology, will prove it
automatically and return {\small\verb%|- t%}. A propositional tautology is
a formula built up using the logical connectives `{\small\verb%~%}', `{\small\verb%/\%}', `{\small\verb%\/%}', `{\small\verb%==>%}'
and `{\small\verb%<=>%}' from terms that can be considered ``atomic'' that is logically
valid whatever truth-values are assigned to the atomic formulas.

\FAILURE
Fails if {\small\verb%t%} is not a propositional tautology.

\EXAMPLE
Here is a simple and potentially useful tautology:
{\par\samepage\setseps\small
\begin{verbatim}
  # TAUT `a \/ b ==> c <=> (a ==> c) /\ (b ==> c)`;;
  val it : thm = |- a \/ b ==> c <=> (a ==> c) /\ (b ==> c)
\end{verbatim}
}
\noindent and here is a more surprising one:
{\par\samepage\setseps\small
\begin{verbatim}
  # TAUT `(p ==> q) \/ (q ==> p)`;;
  val it : thm = |- (p ==> q) \/ (q ==> p)
\end{verbatim}
}
\noindent Note that the ``atomic'' formulas need not just be variables:
{\par\samepage\setseps\small
\begin{verbatim}
  # TAUT `(x > 2 ==> y > 3) \/ (y < 3 ==> x > 2)`;;
  val it : thm = |- (x > 2 ==> y > 3) \/ (y < 3 ==> x > 2)
\end{verbatim}
}

\USES
Solving a tautologous goal completely by {\small\verb%CONV_TAC TAUT%}, or generating a
tautology to massage the goal into a more convenient equivalent form by
{\small\verb%REWRITE_TAC[TAUT `...`]%} or {\small\verb%ONCE_REWRITE_TAC[TAUT `...`]%}.

\COMMENTS
The algorithm used is quite naive, and not efficient on large formulas. For
more general first-order reasoning, with quantifier instantiation, use
MESON-based methods.

\SEEALSO
BOOL_CASES_TAC, ITAUT, ITAUT_TAC, MESON, MESON_TAC.

\ENDDOC
\DOC{temp{\_}path}

\TYPE {\small\verb%temp_path : string ref%}\egroup

\SYNOPSIS
Directory in which to create temporary files.

\DESCRIBE
Some HOL Light derived rules in the libraries (none in the core system) need to
create temporary files. This is the directory in which they do so.

\FAILURE
Not applicable.

\EXAMPLE
On my laptop:
{\par\samepage\setseps\small
\begin{verbatim}
  # !temp_path;;
  val it : string = "/tmp"
\end{verbatim}
}

\SEEALSO
hol_dir.

\ENDDOC
\DOC{term{\_}match}

\TYPE {\small\verb%term_match : term list -> term -> term -> instantiation%}\egroup

\SYNOPSIS
Match one term against another.

\DESCRIBE
The call {\small\verb%term_match lcs t t'%} attempts to find an instantiation for free
variables in {\small\verb%t%}, not permitting assignment of `local constant' variables in
the list {\small\verb%lcs%}, so that it is alpha-equivalent to {\small\verb%t'%}. If it succeeds, the
appropriate instantiation is returned. Otherwise it fails. The matching is
higher-order in a limited sense; see {\small\verb%PART_MATCH%} for more illustrations.

\FAILURE
Fails if terms cannot be matched.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # term_match [] `x + y + 1` `(y + 1) + z + 1`;;
  val it : instantiation = ([], [(`z`, `y`); (`y + 1`, `x`)], [])

  # term_match [] `~(?x:A. P x)` `~(?n. 5 < n /\ n < 6)`;;
  val it : instantiation =
    ([(1, `P`)], [(`\n. 5 < n /\ n < 6`, `P`)], [(`:num`, `:A`)])
\end{verbatim}
}

\COMMENTS
This function can occasionally `succeed' yet produce a match that does not in
fact work. In typical uses, this will be implicitly checked by a subsequent
inference process. However, to get a self-contained matching effect, the user
should check that the instantiation returned does achieve a match, e.g. by
applying {\small\verb%instantiate%}.

\SEEALSO
instantiate, INSTANTIATE, PART_MATCH.

\ENDDOC
\DOC{term{\_}of{\_}preterm}

\TYPE {\small\verb%term_of_preterm : preterm -> term%}\egroup

\SYNOPSIS
Converts a preterm into a term.

\DESCRIBE
HOL Light uses ``pretypes'' and ``preterms'' as intermediate structures for
parsing and typechecking, which are later converted to types and terms. A call
{\small\verb%term_of_preterm ptm%} attempts to convert preterm {\small\verb%ptm%} into a HOL term.

\FAILURE
Fails if some constants used in the preterm have not been defined, or if there
are other inconsistencies in the types so that a consistent typing cannot be
arrived at.

\COMMENTS
Only users seeking to change HOL's parser and typechecker quite radically need
to use this function.

\SEEALSO
preterm_of_term, retypecheck, type_of_pretype.

\ENDDOC
\DOC{term{\_}of{\_}rat}

\TYPE {\small\verb%term_of_rat : num -> term%}\egroup

\SYNOPSIS
Converts OCaml number to canonical rational literal of type {\small\verb%:real%}.

\DESCRIBE
The call {\small\verb%term_of_rat n%}, where {\small\verb%n%} is an OCaml rational number (type {\small\verb%num%}),
returns the canonical rational literal of type {\small\verb%:real%} that represents it. The
canonical literals are integer literals {\small\verb%&n%} for numeral {\small\verb%n%}, {\small\verb%-- &n%} for a
nonzero numeral {\small\verb%n%}, or ratios {\small\verb%&p / &q%} or {\small\verb%-- &p / &q%} where {\small\verb%p%} is nonzero,
{\small\verb%q > 1%} and {\small\verb%p%} and {\small\verb%q%} share no common factor.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # term_of_rat (Int 3 // Int 2);;
  val it : term = `&3 / &2`
\end{verbatim}
}

\SEEALSO
is_ratconst, mk_realintconst, rat_of_term, REAL_RAT_REDUCE_CONV.

\ENDDOC
\DOC{term{\_}order}

\TYPE {\small\verb%term_order : term -> term -> bool%}\egroup

\SYNOPSIS
Term order for use in AC-rewriting.

\DESCRIBE
This binary predicate implements a crude but fairly efficient ordering on terms
that is appropriate for ensuring that ordered rewriting will perform
normalization.

\FAILURE
Never fails.

\EXAMPLE
This example shows how using ordered rewriting with this term ordering can give
normalization under associative and commutative laws given the appropriate
rewrites:
{\par\samepage\setseps\small
\begin{verbatim}
  # ADD_AC;;
  val it : thm =
    |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
\end{verbatim}
}
\noindent
{\par\samepage\setseps\small
\begin{verbatim}
  # TOP_DEPTH_CONV
     (FIRST_CONV(map (ORDERED_REWR_CONV term_order) (CONJUNCTS ADD_AC)))
     `d + (f + a) + b + (c + e):num`;;
  val it : thm = |- d + (f + a) + b + c + e = a + b + c + d + e + f
\end{verbatim}
}

\USES
It is used automatically when applying permutative rewrite rules inside
rewriting and simplification. Users will not normally want to use it
explicitly, though the example above shows roughly what goes on there.

\SEEALSO
ORDERED_IMP_REWR_CONV, ORDERED_REWR_CONV.

\ENDDOC
\DOC{term{\_}type{\_}unify}

\TYPE {\small\verb%term_type_unify : term -> term -> instantiation -> instantiation%}\egroup

\SYNOPSIS
Unify two terms including their type variables

\DESCRIBE
Given two terms {\small\verb%tm1%} and {\small\verb%tm2%} and an existing instantiation {\small\verb%i%} of type and
term variables, a call {\small\verb%term_type_unify tm1 tm2 i%} attempts to find an
augmentation of the instantiation {\small\verb%i%} that makes the terms alpha-equivalent.
The unification is purely first-order.

\FAILURE
Fails if the two terms are not first-order unifiable by instantiating the given
variables and type variables.

\COMMENTS
The more restrictive {\small\verb%term_unify%} does a similar job when the type variables
are already compatible and only terms need to be instantiated.

\SEEALSO
instantiate, term_match, term_unify, type_unify.

\ENDDOC
\DOC{term{\_}unify}

\TYPE {\small\verb%term_unify : term list -> term -> term -> instantiation%}\egroup

\SYNOPSIS
Unify two terms with compatible types

\DESCRIBE
Given two terms {\small\verb%tm1%} and {\small\verb%tm2%}, a call {\small\verb%term_unify vars tm1 tm2%} attempts to
find instantiations of the variables {\small\verb%vars%} in the two terms to make them
alpha-equivalent. The unification is also purely first-order. In these respects
it is less general than {\small\verb%term_match%}, and this may be improved in the future.

\FAILURE
Fails if the two terms are not first-order unifiable by instantiating the given
variables without type instantiation.

\COMMENTS
This function is restricted to terms of the same type, but {\small\verb%term_type_unify%}
offers a similar and more general function that handles type differences.

\SEEALSO
instantiate, term_match, term_type_unify, type_unify.

\ENDDOC
\DOC{term{\_}union}

\TYPE {\small\verb%term_union : term list -> term list -> term list%}\egroup

\SYNOPSIS
Union of two sets of terms up to alpha-equivalence.

\DESCRIBE
The call {\small\verb%term_union l1 l2%} for two lists of terms {\small\verb%l1%} and {\small\verb%l2%} returns a list
including all of {\small\verb%l2%} and all terms of {\small\verb%l1%} for which no alpha-equivalent term
occurs in {\small\verb%l2%} or earlier in {\small\verb%l1%}. If both lists were sets modulo
alpha-conversion, i.e. contained no alpha-equivalent pairs, then so will be the
result.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # term_union [`1`; `2`] [`2`; `3`];;
  val it : term list = [`1`; `2`; `3`]

  # term_union [`!x. x >= 0`; `?u. u > 0`] [`?w. w > 0`; `!u. u >= 0`];;
  val it : term list = [`?w. w > 0`; `!u. u >= 0`]
\end{verbatim}
}

\USES
For combining assumption lists of theorems without duplication of
alpha-equivalent ones.

\SEEALSO
aconv, union, union'.

\ENDDOC
\DOC{THEN}

\TYPE {\small\verb%(THEN) : tactic -> tactic -> tactic%}\egroup

\SYNOPSIS
Applies two tactics in sequence.

\DESCRIBE
If {\small\verb%t1%} and {\small\verb%t2%} are tactics, {\small\verb%t1 THEN t2%} is a tactic which applies {\small\verb%t1%} to a
goal, then applies the tactic {\small\verb%t2%} to all the subgoals generated. If {\small\verb%t1%}
solves the goal then {\small\verb%t2%} is never applied.

\FAILURE
The application of {\small\verb%THEN%} to a pair of tactics never fails.
The resulting tactic fails if {\small\verb%t1%} fails when applied to the goal, or if
{\small\verb%t2%} does when applied to any of the resulting subgoals.

If {\small\verb%unset_then_multiple_subgoals%} is used, {\small\verb%THEN%} is configured to fail
when {\small\verb%t1%} generates more than one subgoal.
This is useful when one wants to check whether a proof written using {\small\verb%THEN%} can
be syntactically converted to the `e` form.

\EXAMPLE
Suppose we want to prove the inbuilt theorem {\small\verb%DELETE_INSERT%} ourselves:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!x y. (x INSERT s) DELETE y =
             if x = y then s DELETE y else x INSERT (s DELETE y)`;;
\end{verbatim}
}
We may wish to perform a case-split using {\small\verb%COND_CASES_TAC%}, but since variables
in the if-then-else construct are bound, this is inapplicable. Thus we want to
first strip off the universally quantified variables:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `(x INSERT s) DELETE y =
   (if x = y then s DELETE y else x INSERT (s DELETE y))`
\end{verbatim}
}
\noindent and then apply {\small\verb%COND_CASES_TAC%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e COND_CASES_TAC;;
  ...
\end{verbatim}
}
A quicker way (starting again from the initial goal) would be to combine the
tactics using {\small\verb%THEN%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN COND_CASES_TAC);;
  ...
\end{verbatim}
}

\COMMENTS
Although normally used to sequence tactics which generate a single subgoal,
it is worth remembering that it is sometimes useful to apply the same tactic
to multiple subgoals; sequences like the following:
{\par\samepage\setseps\small
\begin{verbatim}
   EQ_TAC THENL [ASM_REWRITE_TAC[]; ASM_REWRITE_TAC[]]
\end{verbatim}
}
\noindent can be replaced by the briefer:
{\par\samepage\setseps\small
\begin{verbatim}
   EQ_TAC THEN ASM_REWRITE_TAC[]
\end{verbatim}
}
If using this several times in succession, remember that {\small\verb%THEN%} is
left-associative.

\SEEALSO
EVERY, ORELSE, THENL, unset_then_multiple_subgoals

\ENDDOC
\DOC{THENC}

\TYPE {\small\verb%(THENC) : conv -> conv -> conv%}\egroup

\SYNOPSIS
Applies two conversions in sequence.

\DESCRIBE
If the conversion {\small\verb%c1%} returns {\small\verb%|- t = t'%} when applied to a term {\small\verb%`t`%}, and
{\small\verb%c2%} returns {\small\verb%|- t' = t''%} when applied to {\small\verb%`t'`%}, then the composite
conversion {\small\verb%(c1 THENC c2) `t`%} returns {\small\verb%|- t = t''%}.  That is, {\small\verb%(c1 THENC c2)
`t`%} has the effect of transforming the term {\small\verb%`t`%} first with the conversion
{\small\verb%c1%} and then with the conversion {\small\verb%c2%}.

\FAILURE
{\small\verb%(c1 THENC c2) `t`%} fails if either the conversion {\small\verb%c1%} fails when applied to
{\small\verb%`t`%}, or if {\small\verb%c1 `t`%} succeeds and returns {\small\verb%|- t = t'%} but {\small\verb%c2%} fails when
applied to {\small\verb%`t'`%}.  {\small\verb%(c1 THENC c2) `t`%} may also fail if either of {\small\verb%c1%} or {\small\verb%c2%}
is not, in fact, a conversion (i.e. a function that maps a term {\small\verb%t%} to a
theorem {\small\verb%|- t = t'%}).

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # BETA_CONV `(\x. x + 1) 3`;;
  val it : thm = |- (\x. x + 1) 3 = 3 + 1
  # (BETA_CONV THENC NUM_ADD_CONV) `(\x. x + 1) 3`;;
  val it : thm = |- (\x. x + 1) 3 = 4
\end{verbatim}
}

\SEEALSO
EVERY_CONV, ORELSEC, REPEATC.

\ENDDOC
\DOC{thenc{\_}}

\TYPE {\small\verb%thenc_ : conv -> conv -> conv%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%THENC%}.

\SEEALSO
THENC.

\ENDDOC
\DOC{THENL}

\TYPE {\small\verb%(THENL) : tactic -> tactic list -> tactic%}\egroup

\SYNOPSIS
Applies a list of tactics to the corresponding subgoals generated by a tactic.

\DESCRIBE
If {\small\verb%t,t1,...,tn%} are tactics, {\small\verb%t THENL [t1;...;tn]%} is a tactic which applies
{\small\verb%t%} to a goal, and if it does not fail, applies the tactics {\small\verb%t1,...,tn%} to the
corresponding subgoals, unless {\small\verb%t%} completely solves the goal.

\FAILURE
The application of {\small\verb%THENL%} to a tactic and tactic list never fails.
The resulting tactic fails if {\small\verb%t%} fails when applied to the goal, or if
the goal list is not empty and its length is not the same as that of the
tactic list, or finally if {\small\verb%ti%} fails when applied to the {\small\verb%i%}'th subgoal
generated by {\small\verb%t%}.

\EXAMPLE
If we want to prove the inbuilt theorem {\small\verb%LE_LDIV%} ourselves:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!a b n. ~(a = 0) /\ b <= a * n ==> b DIV a <= n`;;
  ...
\end{verbatim}
}
\noindent we may start by proving a lemma {\small\verb%n = (a * n) DIV a%} from the given
hypotheses. The following step generates two subgoals:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC THEN SUBGOAL_THEN `n = (a * n) DIV a` SUBST1_TAC);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`~(a = 0)`]
   1 [`b <= a * n`]

  `b DIV a <= (a * n) DIV a`

   0 [`~(a = 0)`]
   1 [`b <= a * n`]

  `n = (a * n) DIV a`
\end{verbatim}
}
Each subgoal has a relatively short proof, but these proofs are quite
different. We can combine them with the initial tactic above using {\small\verb%THENL%}, so
the following would solve the initial goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT STRIP_TAC THEN SUBGOAL_THEN `n = (a * n) DIV a` SUBST1_TAC THENL
      [ASM_SIMP_TAC[DIV_MULT]; MATCH_MP_TAC DIV_MONO THEN ASM_REWRITE_TAC[]]);;
\end{verbatim}
}
Note that it is quite a common situation for the same tactic to be applied to
all generated subgoals. In that case, you can just use {\small\verb%THEN%}, e.g. in the
proof of the pre-proved theorem {\small\verb%ADD_0%}:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m. m + 0 = m`;;
  ...
  # e(INDUCT_TAC THEN ASM_REWRITE_TAC[ADD]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Applying different tactics to different subgoals.

\SEEALSO
EVERY, ORELSE, THEN.

\ENDDOC
\DOC{thenl{\_}}

\TYPE {\small\verb%thenl_ : tactic -> tactic list -> tactic%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%THENL%}.

\SEEALSO
THENL.

\ENDDOC
\DOC{then{\_}}

\TYPE {\small\verb%then_ : tactic -> tactic -> tactic%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%THEN%}.

\SEEALSO
THEN.

\ENDDOC
\DOC{THEN{\_}TCL}

\TYPE {\small\verb%(THEN_TCL) : thm_tactical -> thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Composes two theorem-tacticals.

\DESCRIBE
If {\small\verb%ttl1%} and {\small\verb%ttl2%} are two theorem-tacticals, {\small\verb%ttl1 THEN_TCL ttl2%} is
a theorem-tactical which composes their effect; that is, if:
{\par\samepage\setseps\small
\begin{verbatim}
   ttl1 ttac th1 = ttac th2
\end{verbatim}
}
\noindent and
{\par\samepage\setseps\small
\begin{verbatim}
   ttl2 ttac th2 = ttac th3
\end{verbatim}
}
\noindent then
{\par\samepage\setseps\small
\begin{verbatim}
   (ttl1 THEN_TCL ttl2) ttac th1 = ttac th3
\end{verbatim}
}

\FAILURE
The application of {\small\verb%THEN_TCL%} to a pair of theorem-tacticals never fails.

\SEEALSO
EVERY_TCL, FIRST_TCL, ORELSE_TCL.

\ENDDOC
\DOC{then{\_}tcl{\_}}

\TYPE {\small\verb%then_tcl_ : thm_tactical -> thm_tactical -> thm_tactical%}\egroup

\SYNOPSIS
Non-infix version of {\small\verb%THEN_TCL%}.

\SEEALSO
THEN_TCL.

\ENDDOC
\DOC{theorems}

\TYPE {\small\verb%theorems : (string * thm) list ref%}\egroup

\SYNOPSIS
Database of theorems for {\small\verb%search%} tools.

\DESCRIBE
The reference variable {\small\verb%theorems%} holds a list of name-theorem pairs that is
used by {\small\verb%search%} to find theorems according to term patterns or by name.
Initially, this contains all theorems individually bound to OCaml identifiers
in the main system. However, it can be updated by users, and there is a script
in {\small\verb%update_database.ml%} that will automatically update the database
according to the current OCaml bindings.

\FAILURE
Not applicable.

\EXAMPLE
In the initial HOL Light state we see:
{\par\samepage\setseps\small
\begin{verbatim}
  # theorems;;
  val it : (string * thm) list ref =
    {\small\verb%contents =
      [("ABSORPTION", |- !x s. x IN s <=> x INSERT s = s);
       ("ABS_SIMP", |- !t1 t2. (\x. t1) t2 = t1);
       ("ADD", |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n)));
       ("ADD1", |- !m. SUC m = m + 1); ("ADD_0", |- !m. m + 0 = m);
    ...
\end{verbatim}
}

\SEEALSO
search.

\ENDDOC
\DOC{the{\_}definitions}

\TYPE {\small\verb%the_definitions : thm list ref%}\egroup

\SYNOPSIS
List of all definitions introduced so far.

\DESCRIBE
The reference variable {\small\verb%the_definitions%} holds the list of definitions made so
far. Various definitional rules such as {\small\verb%new_definition%} automatically augment
it. Note that in some cases (e.g. {\small\verb%new_inductive_definition%}) the stored form
of the definition may look very different from what the user sees or enters at
the top level.

\FAILURE
Not applicable.

\EXAMPLE
If we examine the list in HOL Light's initial state, we see the most recent
definition at the head ({\small\verb%superadmissible%} is connected with HOL's automated
definitional rule {\small\verb%define%}) and the oldest, logical truth {\small\verb%T%}, at the tail:
{\par\samepage\setseps\small
\begin{verbatim}
  # !the_definitions;;
  val it : thm list =
    [|- !(<<) p s t.
            superadmissible (<<) p s t <=>
            admissible (<<) (\f a. T) s p ==> tailadmissible (<<) p s t;
     ...
     ...
     |- (/\) = (\p q. (\f. f p q) = (\f. f T T)); |- T <=> (\p. p) = (\p. p)]
\end{verbatim}
}
If we make a new definition of any sort, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # new_definition `false <=> F`;;
  val it : thm = |- false <=> F
\end{verbatim}
}
\noindent we will see a new entry at the head:
{\par\samepage\setseps\small
\begin{verbatim}
  # !the_definitions;;
  val it : thm list =
    [|- false <=> F;
     ...
     ...
     |- (/\) = (\p q. (\f. f p q) = (\f. f T T)); |- T <=> (\p. p) = (\p. p)]
\end{verbatim}
}

\USES
This list is not logically necessary and is not part of HOL Light's logical
core, but it is used outside the core so that multiple instances of the same
definition are quietly ``ignored'' rather than rejected. (By contrast, the list
of new constants introduced by definitions is logically necessary to avoid
inconsistent redefinition.) Users may also sometimes find it convenient.

\SEEALSO
axioms, constants, define, definitions, new_definition,
new_inductive_definition, new_recursive_definition, new_specification,
the_inductive_definitions, the_specifications.

\ENDDOC
\DOC{the{\_}implicit{\_}types}

\TYPE {\small\verb%the_implicit_types :  (string * hol_type) list ref%}\egroup

\SYNOPSIS
Restrict variables to a particular type or type scheme.

\DESCRIBE
Normally, the types of variables in term quotations are restricted only by the
context in which they appear and will otherwise have maximally general types
inferred. By associating variable names with type schemes in the list of pairs
{\small\verb%the_implicit_types%}, the types of variables will be suitably restricted. This
can be a convenience in reducing the amount of manual type annotation in terms.
The facility is somewhat analogous to the schemas specified for constants in
{\small\verb%the_overload_skeletons%}.

\FAILURE
Not applicable.

\EXAMPLE
If we parse the following term, in which all names denote variables (assume
neither {\small\verb%mul%} nor {\small\verb%x%} has been declared a constant), then the type of {\small\verb%x%} is
completely unrestricted if {\small\verb%the_implicit_types%} is empty as in HOL Light's
initial state:
{\par\samepage\setseps\small
\begin{verbatim}
  # the_implicit_types := [];;
  val it : unit = ()
  # `mul 1 x`;;
  Warning: inventing type variables
  val it : term = `mul 1 x`
  # map dest_var (frees it);;
  val it : (string * hol_type) list =
    [("mul", `:num->?83058->?83057`); ("x", `:?83058`)]
\end{verbatim}
}
However, if we use the implicit types to require that the variable {\small\verb%mul%} has an
instance of a generic type scheme each time it is parsed, all types follow
implicitly:
{\par\samepage\setseps\small
\begin{verbatim}
  # the_implicit_types := ["mul",`:A->A->A`; "iv",`:A->A`];;
  val it : unit = ()
  # `mul 1 x`;;
  val it : term = `mul 1 x`
  # map dest_var (frees it);;
  val it : (string * hol_type) list =
    [("mul", `:num->num->num`); ("x", `:num`)]
\end{verbatim}
}

\SEEALSO
make_overloadable, overload_interface, override_interface, prioritize_overload,
reduce_interface, remove_interface, the_interface, the_overload_skeletons.

\ENDDOC
\DOC{the{\_}inductive{\_}definitions}

\TYPE {\small\verb%the_inductive_definitions : thm list ref%}\egroup

\SYNOPSIS
List of all definitions introduced so far.

\DESCRIBE
The reference variable {\small\verb%the_inductive_definitions%} holds the list of
inductive definitions made so far using {\small\verb%new_inductive_definition%}, which
automatically augments it.

\FAILURE
Not applicable.

\EXAMPLE
If we examine the list in HOL Light's initial state, we see the most recent
inductive definition is finiteness of a set:
{\par\samepage\setseps\small
\begin{verbatim}
  # !the_inductive_definitions;;
  val it : (thm * thm * thm) list =
    [(|- FINITE {\small\verb%%} /\ (!x s. FINITE s ==> FINITE (x INSERT s)),
      |- !FINITE'. FINITE' {\small\verb%%} /\ (!x s. FINITE' s ==> FINITE' (x INSERT s))
                   ==> (!a. FINITE a ==> FINITE' a),
      |- !a. FINITE a <=> a = {\small\verb%%} \/ (?x s. a = x INSERT s /\ FINITE s));
     ...
     ...]
\end{verbatim}
}

\USES
This list is not logically necessary and is not part of HOL Light's logical
core, but it is used outside the core so that multiple instances of the same
inductive definition are quietly ``ignored'' rather than rejected.
Users may also sometimes find it convenient.

\SEEALSO
axioms, constants, define, definitions, new_definition,
new_inductive_definition, new_recursive_definition, new_specification,
the_definitions, the_specifications.

\ENDDOC
\DOC{the{\_}inductive{\_}types}

\TYPE {\small\verb%the_inductive_types : (string * (thm * thm)) list ref%}\egroup

\SYNOPSIS
List of previously declared inductive types.

\DESCRIBE
This reference variable contains a list of the inductive types, together with
their induction and recursion theorems as returned by {\small\verb%define_type%}. The list
is automatically extended by a call of {\small\verb%define_type%}.

\FAILURE
Not applicable.

\SEEALSO
define_type.

\ENDDOC
\DOC{the{\_}interface}

\TYPE {\small\verb%the_interface : (string * (string * hol_type)) list ref%}\egroup

\SYNOPSIS
List of active interface mappings.

\DESCRIBE
HOL Light allows the same identifier to map to one or more underlying constants
using an overloading mechanism with resolution based on type. The reference
variable {\small\verb%the_interface%} stores the current list of all interface mappings.

\SEEALSO
make_overloadable, overload_interface, override_interface, prioritize_overload,
reduce_interface, remove_interface, the_implicit_types, the_overload_skeletons.

\ENDDOC
\DOC{the{\_}overload{\_}skeletons}

\TYPE {\small\verb%the_overload_skeletons : (string * hol_type) list ref%}\egroup

\SYNOPSIS
List of overload skeletons for all overloadable identifiers.

\DESCRIBE
HOL Light allows the same identifier to denote several different underlying
constants, with the choice being determined by types and/or an order of
priority (see {\small\verb%prioritize_overload%}). The reference variable
{\small\verb%the_overload_skeletons%} contains a list of all the overloadable symbols (you
can add more using {\small\verb%make_overloadable%}) and their type skeletons. All constants
to which an identifier is overloaded must have a type that is an instance of
this skeleton, although you can make it a type variable in which case any type
would be allowed. The variable {\small\verb%the_implicit_types%} offers somewhat analogous
features for variables.

\FAILURE
Not applicable.

\EXAMPLE
In the initial state of HOL Light:
{\par\samepage\setseps\small
\begin{verbatim}
# !the_overload_skeletons;;
val it : (string * hol_type) list =
  [("gcd", `:A#A->A`); ("coprime", `:A#A->bool`); ("mod", `:A->A->A->bool`);
   ("divides", `:A->A->bool`); ("&", `:num->A`); ("min", `:A->A->A`);
   ("max", `:A->A->A`); ("abs", `:A->A`); ("inv", `:A->A`);
   ("pow", `:A->num->A`); ("--", `:A->A`); (">=", `:A->A->bool`);
   (">", `:A->A->bool`); ("<=", `:A->A->bool`); ("<", `:A->A->bool`);
   ("/", `:A->A->A`); ("*", `:A->A->A`); ("-", `:A->A->A`);
   ("+", `:A->A->A`)]
\end{verbatim}
}

\SEEALSO
make_overloadable, overload_interface, override_interface, prioritize_overload,
reduce_interface, remove_interface, the_implicit_types, the_interface.

\ENDDOC
\DOC{the{\_}specifications}

\TYPE {\small\verb%the_specifications : thm list ref%}\egroup

\SYNOPSIS
List of all constant specifications introduced so far.

\DESCRIBE
The reference variable {\small\verb%the_specifications%} holds the list of constant
specifications made so far by {\small\verb%new_specification%}. It is a list of triples,
with the first two components being the list of variables and the existential
theorem used as input, and the last being the returned theorem.

\FAILURE
Not applicable.

\USES
This list is not logically necessary and is not part of HOL Light's logical
core, but it is used outside the core so that multiple instances of the same
specification are quietly ``ignored'' rather than rejected. (By contrast, the
list of new constants introduced by definitions is logically necessary to avoid
inconsistent redefinition.) Users may also sometimes find it convenient.

\SEEALSO
axioms, constants, define, new_definition, new_inductive_definition,
new_recursive_definition, new_specification, the_definitions,
the_inductive_definitions.

\ENDDOC
\DOC{the{\_}type{\_}definitions}

\TYPE {\small\verb%the_type_definitions : ((string * string * string) * (thm * thm)) list ref%}\egroup

\SYNOPSIS
List of type definitions made so far.

\DESCRIBE
The reference variable {\small\verb%the_type_definitions%} holds a list of entries, one for
each type definition made so far with {\small\verb%new_type_definition%}. It is not normally
explicitly manipulated by the user, but is automatically augmented by each call
of {\small\verb%new_type_definition%}. Each entry contains three strings (the type name,
type constructor name and destructor name) and two theorems (the input
nonemptiness theorem and the returned type bijections). That is, for a call:
{\par\samepage\setseps\small
\begin{verbatim}
  bijth = new_type_definition tyname (absname,repname) nonempth;;
\end{verbatim}
}
\noindent the entry created in this list is:
{\par\samepage\setseps\small
\begin{verbatim}
 (tyname,absname,repname),(nonempth,bijth)
\end{verbatim}
}
Note that the entries made using other interfaces to
{\small\verb%new_basic_type_definition%}, such as {\small\verb%define_type%}, are not included in this
list.

\FAILURE
Not applicable.

\USES
This is mainly intended for internal use in {\small\verb%new_type_definition%}, so that
repeated instances of the same definition are ignored rather than rejected.
Some users may find the information useful too.

\SEEALSO
axioms, constants, new_type_definition, the_definitions.

\ENDDOC
\DOC{thm{\_}frees}

\TYPE {\small\verb%thm_frees : thm -> term list%}\egroup

\SYNOPSIS
Returns a list of the variables free in a theorem's assumptions and conclusion.

\DESCRIBE
When applied to a theorem, {\small\verb%A |- t%}, the function {\small\verb%thm_frees%} returns a list,
without repetitions, of those variables which are free either in {\small\verb%t%} or in
some member of the assumption list {\small\verb%A%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let th = CONJUNCT1 (ASSUME `p /\ q`);;
  val th : thm = p /\ q |- p

  # thm_frees th;;
  val it : term list = [`q`; `p`]
\end{verbatim}
}

\SEEALSO
frees, freesl, free_in.

\ENDDOC
\DOC{time}

\TYPE {\small\verb%time : ('a -> 'b) -> 'a -> 'b%}\egroup

\SYNOPSIS
Report CPU time taken by a function.

\DESCRIBE
A call {\small\verb%time f x%} will evaluate {\small\verb%f x%} as usual, but will also (provided the
{\small\verb%report_timing%} flag is {\small\verb%true%} as it is by default) print the CPU time taken by
that function evaluation.

\FAILURE
Never fails in itself, though it propagates any exception generated by the call
{\small\verb%f x%} itself.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # time NUM_REDUCE_CONV `123 EXP 14`;;
  CPU time (user): 0.09
  val it : thm = |- 123 EXP 14 = 181414317867238075368413196009
\end{verbatim}
}

\USES
Monitoring CPU time taken, e.g. to test different algorithms or implementation
optimizations.

\SEEALSO
report_timing.

\ENDDOC
\DOC{tl}

\TYPE {\small\verb%tl : 'a list -> 'a list%}\egroup

\SYNOPSIS
Computes the tail of a list (the original list less the first element).

\DESCRIBE
{\small\verb%tl [x1;...;xn]%} returns {\small\verb%[x2;...;xn]%}.

\FAILURE
Fails with {\small\verb%tl%} if the list is empty.

\SEEALSO
hd, el.

\ENDDOC
\DOC{TOP{\_}DEPTH{\_}CONV}

\TYPE {\small\verb%TOP_DEPTH_CONV : conv -> conv%}\egroup

\SYNOPSIS
Applies a conversion top-down to all subterms, retraversing changed ones.

\DESCRIBE
{\small\verb%TOP_DEPTH_CONV c tm%} repeatedly applies the conversion {\small\verb%c%} to all the subterms
of the term {\small\verb%tm%}, including the term {\small\verb%tm%} itself. The supplied conversion {\small\verb%c%}
is applied to the subterms of {\small\verb%tm%} in top-down order and is applied repeatedly
(zero or more times, as is done by {\small\verb%REPEATC%}) at each subterm until it fails.
If a subterm {\small\verb%t%} is changed (except for alpha-equivalence) by virtue of the
application of {\small\verb%c%} to its own subterms, then the term into which {\small\verb%t%} is
transformed is retraversed by applying {\small\verb%TOP_DEPTH_CONV c%} to it.

\FAILURE
{\small\verb%TOP_DEPTH_CONV c tm%} never fails but can diverge.

\EXAMPLE
Both {\small\verb%TOP_DEPTH_CONV%} and {\small\verb%REDEPTH_CONV%} repeatedly apply a conversion until no
more applications are possible anywhere in the term. For example,
{\small\verb%TOP_DEPTH_CONV BETA_CONV%} or {\small\verb%REDEPTH_CONV BETA_CONV%} will eliminate all beta
redexes:
{\par\samepage\setseps\small
\begin{verbatim}
  # TOP_DEPTH_CONV BETA_CONV `(\x. (\y. (\z. z + y) (y + 1)) (x + 2)) 3`;;
  val it : thm =
    |- (\x. (\y. (\z. z + y) (y + 1)) (x + 2)) 3 = ((3 + 2) + 1) + 3 + 2
\end{verbatim}
}
The main difference is that {\small\verb%TOP_DEPTH_CONV%} proceeds top-down, whereas
{\small\verb%REDEPTH_CONV%} proceeds bottom-up. Reasons for preferring {\small\verb%TOP_DEPTH_CONV%}
might be that a transformation near the top obviates the need for
transformations lower down. For example, this is quick because everything is
done by one top-level rewrite:
{\par\samepage\setseps\small
\begin{verbatim}
  # let conv = GEN_REWRITE_CONV I [MULT_CLAUSES] ORELSEC NUM_RED_CONV;;
  val conv : conv = <fun>

  # time (TOP_DEPTH_CONV conv) `0 * 25 EXP 100`;;
  CPU time (user): 0.
  val it : thm = |- 0 * 25 EXP 100 = 0
\end{verbatim}
}
\noindent whereas the following takes markedly longer:
{\par\samepage\setseps\small
\begin{verbatim}
  # time (REDEPTH_CONV conv) `0 * 25 EXP 100`;;
  CPU time (user): 2.573
  val it : thm = |- 0 * 25 EXP 100 = 0
\end{verbatim}
}

\SEEALSO
DEPTH_CONV, ONCE_DEPTH_CONV, REDEPTH_CONV, TOP_DEPTH_SQCONV, TOP_SWEEP_CONV.

\ENDDOC
\DOC{TOP{\_}DEPTH{\_}SQCONV}

\TYPE {\small\verb%TOP_DEPTH_SQCONV : strategy%}\egroup

\SYNOPSIS
Applies simplification top-down to all subterms, retraversing changed ones.

\DESCRIBE
HOL Light's simplification functions (e.g. {\small\verb%SIMP_TAC%}) have their traversal
algorithm controlled by a ``strategy''. {\small\verb%TOP_DEPTH_SQCONV%} is a strategy
corresponding to {\small\verb%TOP_DEPTH_CONV%} for ordinary conversions: simplification is
applied top-down to all subterms, retraversing changed ones.

\FAILURE
Not applicable.

\SEEALSO
DEPTH_SQCONV, ONCE_DEPTH_SQCONV, REDEPTH_SQCONV, TOP_DEPTH_CONV,
TOP_SWEEP_SQCONV.

\ENDDOC
\DOC{top{\_}goal}

\TYPE {\small\verb%top_goal : unit -> term list * term%}\egroup

\SYNOPSIS
Returns the current goal of the subgoal package.

\DESCRIBE
The function {\small\verb%top_goal%} is part of the subgoal package. It returns the top goal
of the goal stack in the current proof state.  For a description of the subgoal
package, see  {\small\verb%set_goal%}.

\FAILURE
A call to {\small\verb%top_goal%} will fail if there are no unproven goals. This could be
because no goal has been set using {\small\verb%set_goal%} or because the last goal set has
been completely proved.

\USES
Examining the proof state after a proof fails.

\SEEALSO
b, e, g, p, r, set_goal, top_thm.

\ENDDOC
\DOC{top{\_}realgoal}

\TYPE {\small\verb%top_realgoal : unit -> (string * thm) list * term%}\egroup

\SYNOPSIS
Returns the actual internal structure of the current goal.

\DESCRIBE
Returns the actual internal representation of the current goal, including the
labels and the theorems that are the assumptions.

\USES
For users interested in the precise internal structure of the goal, e.g. to
debug subtle free variable problems. Normally the simpler structure returned by
{\small\verb%top_goal%} is entirely adequate.

\SEEALSO
top_goal.

\ENDDOC
\DOC{TOP{\_}SWEEP{\_}CONV}

\TYPE {\small\verb%TOP_SWEEP_CONV : conv -> conv%}\egroup

\SYNOPSIS
Repeatedly applies a conversion top-down at all levels, but after descending to
subterms, does not return to higher ones.

\DESCRIBE
The call {\small\verb%TOP_SWEEP_CONV conv%} applies {\small\verb%conv%} repeatedly at the top level of a
term, and then descends into subterms of the result, recursively doing the same
thing. However, once the subterms are dealt with, it does not, unlike
{\small\verb%TOP_DEPTH_CONV conv%}, return to re-examine them.

\FAILURE
Never fails.

\EXAMPLE
If we create an equation between large tuples:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm =
      let pairup x i t = mk_pair(mk_var(x^string_of_int i,aty),t) in
      let mkpairs x = itlist (pairup x) (1--200) (mk_var(x,aty)) in
    mk_eq(mkpairs "x",mkpairs "y");;
  ...
\end{verbatim}
}
\noindent we can observe that
{\par\samepage\setseps\small
\begin{verbatim}
  # time (TOP_DEPTH_CONV(REWR_CONV PAIR_EQ)); ();;
\end{verbatim}
}
\noindent is a little bit slower than
{\par\samepage\setseps\small
\begin{verbatim}
  # time (TOP_SWEEP_CONV(REWR_CONV PAIR_EQ)); ();;
\end{verbatim}
}

\SEEALSO
DEPTH_CONV, ONCE_DEPTH_CONV, REDEPTH_CONV, TOP_DEPTH_CONV.

\ENDDOC
\DOC{TOP{\_}SWEEP{\_}SQCONV}

\TYPE {\small\verb%TOP_SWEEP_SQCONV : strategy%}\egroup

\SYNOPSIS
Applies simplification top-down at all levels, but after descending to
subterms, does not return to higher ones.

\DESCRIBE
HOL Light's simplification functions (e.g. {\small\verb%SIMP_TAC%}) have their traversal
algorithm controlled by a ``strategy''. {\small\verb%TOP_SWEEP_SQCONV%} is a strategy
corresponding to {\small\verb%TOP_SWEEP_CONV%} for ordinary conversions: simplification is
applied top-down at all levels, but after descending to subterms, does not
return to higher ones.

\FAILURE
Not applicable.

\SEEALSO
DEPTH_SQCONV, ONCE_DEPTH_SQCONV, REDEPTH_SQCONV, TOP_DEPTH_SQCONV,
TOP_SWEEP_CONV.

\ENDDOC
\DOC{top{\_}thm}

\TYPE {\small\verb%top_thm : unit -> thm%}\egroup

\SYNOPSIS
Returns the theorem just proved using the subgoal package.

\DESCRIBE
The function {\small\verb%top_thm%} is part of the subgoal package. A proof state of the
package consists of either  goal and justification stacks if a proof is in
progress or a theorem if a proof has just been completed. If the proof state
consists of a theorem, {\small\verb%top_thm%} returns that theorem. For a description of the
subgoal package, see {\small\verb%set_goal%}.

\FAILURE
{\small\verb%top_thm%} will fail if the proof state does not hold a theorem. This will be
so either because no goal has been set or because a proof is in progress with
unproven subgoals.

\USES
Accessing the result of an interactive proof session with the subgoal package.

\SEEALSO
b, e, g, p, r, set_goal, top_goal.

\ENDDOC
\DOC{TRANS}

\TYPE {\small\verb%TRANS : thm -> thm -> thm%}\egroup

\SYNOPSIS
Uses transitivity of equality on two equational theorems.

\DESCRIBE
When applied to a theorem {\small\verb%A1 |- t1 = t2%} and a theorem {\small\verb%A2 |- t2' = t3%}, where
{\small\verb%t2%} and {\small\verb%t2'%} are alpha-equivalent (in particular, where they are identical),
the inference rule {\small\verb%TRANS%} returns the theorem {\small\verb%A1 u A2 |- t1 = t3%}.
{\par\samepage\setseps\small
\begin{verbatim}
    A1 |- t1 = t2   A2 |- t2' = t3
   --------------------------------  TRANS
         A1 u A2 |- t1 = t3
\end{verbatim}
}
\FAILURE
Fails unless the theorems are equational, with the right side of the first
being the same as the left side of the second, up to alpha-equivalence.

\EXAMPLE
The following shows identical uses of {\small\verb%TRANS%}, one on Boolean equations (shown
as {\small\verb%<=>%}) and one on numerical equations.
{\par\samepage\setseps\small
\begin{verbatim}
  # let t1 = ASSUME `a:bool = b` and t2 = ASSUME `b:bool = c`;;
  val t1 : thm = a <=> b |- a <=> b
  val t2 : thm = b <=> c |- b <=> c
  # TRANS t1 t2;;
  val it : thm = a <=> b, b <=> c |- a <=> c

  # let t1 = ASSUME `x:num = 1` and t2 = num_CONV `1`;;
  val t1 : thm = x = 1 |- x = 1
  val t2 : thm = |- 1 = SUC 0
  # TRANS t1 t2;;
  val it : thm = x = 1 |- x = SUC 0
\end{verbatim}
}

\COMMENTS
This is one of HOL Light's 10 primitive inference rules.

\SEEALSO
EQ_MP, IMP_TRANS, REFL, SYM, TRANS_TAC.

\ENDDOC
\DOC{TRANS{\_}TAC}

\TYPE {\small\verb%TRANS_TAC : thm -> term -> tactic%}\egroup

\SYNOPSIS
Applies transitivity theorem to goal with chosen intermediate term.

\DESCRIBE
When applied to a `transitivity' theorem, i.e. one of the form
{\par\samepage\setseps\small
\begin{verbatim}
   |- !xs. R1 x y /\ R2 y z ==> R3 x z
\end{verbatim}
}
\noindent and a term {\small\verb%t%}, {\small\verb%TRANS_TAC%} produces a tactic that reduces a goal
with conclusion of the form {\small\verb%R3 s u%} to one with conclusion {\small\verb%R1 s t /\ R2 t u%}.
{\par\samepage\setseps\small
\begin{verbatim}
       A ?- R3 s u
  ========================  TRANS_TAC (|- !xs. R1 x y /\ R2 y z ==> R3 x z) `t`
   A ?- R1 s t /\ R2 t u
\end{verbatim}
}

\EXAMPLE
Consider the simple inequality goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `n < (m + 2) * (n + 1)`;;
\end{verbatim}
}
We can use the following transitivity theorem
{\par\samepage\setseps\small
\begin{verbatim}
  # LET_TRANS;;
  val it : thm = |- !m n p. m <= n /\ n < p ==> m < p
\end{verbatim}
}
{\par\samepage\setseps\small
\begin{verbatim}
  # e(TRANS_TAC LET_TRANS `1 * (n + 1)`);;
  val it : goalstack = 1 subgoal (1 total)

  `n <= 1 * (n + 1) /\ 1 * (n + 1) < (m + 2) * (n + 1)`
\end{verbatim}
}

\FAILURE
Fails unless the input theorem is of the expected form (some of the
relations {\small\verb%R1%}, {\small\verb%R2%} and {\small\verb%R3%} may be, and often are, the same) and the
conclusion matches the goal, in the usual sense of higher-order matching.

\COMMENTS
The effect of {\small\verb%TRANS_TAC th t%} can often be replicated by the more primitive
tactic sequence {\small\verb%MATCH_MP_TAC th THEN EXISTS_TAC t%}. The use of {\small\verb%TRANS_TAC%} is
not only less verbose, but it is also more general in that it ensures correct
type-instantiation of the theorem, whereas in highly polymorphic theorems the
use of {\small\verb%MATCH_MP_TAC%} may leave the wrong types for the subsequent {\small\verb%EXISTS_TAC%}
step.

\SEEALSO
MATCH_MP_TAC, TRANS.

\ENDDOC
\DOC{TRY}

\TYPE {\small\verb%TRY : tactic -> tactic%}\egroup

\SYNOPSIS
Makes a tactic have no effect rather than fail.

\DESCRIBE
For any tactic {\small\verb%t%}, the application {\small\verb%TRY t%} gives a new tactic
which has the same effect as {\small\verb%t%} if that succeeds, and otherwise has
no effect.

\FAILURE
The application of {\small\verb%TRY%} to a tactic never fails. The resulting
tactic never fails.

\EXAMPLE
We might want to try a certain tactic ``speculatively'', even if we're not sure
that it will work, for example, to handle the ``easy'' subgoals from breaking
apart a large conjunction. On a small scale, we might want to prove:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(x + 1) EXP 2 = x EXP 2 + 2 * x + 1 /\
       (x EXP 2 = y EXP 2 ==> x = y) /\
       (x < y ==> 2 * x + 1 < 2 * y)`;;
  ...
\end{verbatim}
}
\noindent and just see which conjuncts we can get rid of automatically by
{\small\verb%ARITH_TAC%}. It turns out that it only leaves one subgoal with some nonlinear
reasoning:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT CONJ_TAC THEN TRY ARITH_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `x EXP 2 = y EXP 2 ==> x = y`
\end{verbatim}
}

\SEEALSO
CHANGED_TAC, VALID.

\ENDDOC
\DOC{tryapplyd}

\TYPE {\small\verb%tryapplyd : ('a, 'b) func -> 'a -> 'b -> 'b%}\egroup

\SYNOPSIS
Applies a finite partial function, with a default for undefined points.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. If {\small\verb%f%} is a finite partial function, {\small\verb%x%} an element of its domain type and
{\small\verb%y%} of its range type, the call {\small\verb%tryapplyd f x y%} tries to apply {\small\verb%f%} to the
value {\small\verb%x%}, as with {\small\verb%apply f x%}, but if it is undefined, simply returns {\small\verb%y%}

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # tryapplyd (1 |=> 2) 1 (-1);;
  val it : int = 2

  # tryapplyd undefined 1 (-1);;
  val it : int = -1
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, undefine, undefined.

\ENDDOC
\DOC{tryfind}

\TYPE {\small\verb%tryfind : ('a -> 'b) -> 'a list -> 'b%}\egroup

\SYNOPSIS
Returns the result of the first successful application of a function to the
elements of a list.

\DESCRIBE
{\small\verb%tryfind f [x1;...;xn]%} returns {\small\verb%(f xi)%} for the first {\small\verb%xi%} in the list for
which application of {\small\verb%f%} succeeds.

\FAILURE
Fails with {\small\verb%tryfind%} if the application of the function fails for all elements
in the list. This will always be the case if the list is empty.

\SEEALSO
find, mem, exists, forall, assoc, rev_assoc.

\ENDDOC
\DOC{TRY{\_}CONV}

\TYPE {\small\verb%TRY_CONV : conv -> conv%}\egroup

\SYNOPSIS
Attempts to apply a conversion; applies identity conversion in case of failure.

\DESCRIBE
{\small\verb%TRY_CONV c `t`%} attempts to apply the conversion {\small\verb%c%} to the term {\small\verb%`t`%}; if
this fails, then the identity conversion is applied instead giving the
reflexive theorem {\small\verb%|- t = t%}.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # num_CONV `0`;;
  Exception: Failure "num_CONV".
  # TRY_CONV num_CONV `0`;;
  val it : thm = |- 0 = 0
\end{verbatim}
}

\SEEALSO
ALL_CONV.

\ENDDOC
\DOC{try{\_}user{\_}color{\_}printer}

\TYPE {\small\verb%try_user_color_printer : formatter -> term -> unit%}\egroup

\SYNOPSIS
Try user-defined color printers on a term.

\DESCRIBE
HOL Light allows arbitrary user printers to be inserted into the toplevel
printer so that they are invoked on all applicable subterms (see
{\small\verb%install_user_printer%} and {\small\verb%install_user_color_printer%}).
The call {\small\verb%try_user_color_printer fmt tm%} attempts all
installed user printers on the term {\small\verb%tm%} in an implementation-defined order,
sending output to the formatter {\small\verb%fmt%}. If one succeeds, the call returns {\small\verb%()%},
and otherwise it fails.

\FAILURE
Fails if no user printer is applicable to the given term (e.g. if no user
printers have been installed).

\SEEALSO
delete_user_color_printer, delete_user_printer, install_user_color_printer,
install_user_printer, try_user_printer.

\ENDDOC
\DOC{try{\_}user{\_}parser}

\TYPE {\small\verb%try_user_parser : lexcode list -> preterm * lexcode list%}\egroup

\SYNOPSIS
Try all user parsing functions.

\DESCRIBE
HOL Light allows user parsing functions to be installed, and will try them on
all terms during parsing before the usual parsers. The call
{\small\verb%try_user_parser l%} attempts to parse the list of tokens {\small\verb%l%} using all the user
parsers, taking the results from whichever one succeeds first.

\FAILURE
Fails if all user parsers fail.

\SEEALSO
delete_parser, install_parser, installed_parsers.

\ENDDOC
\DOC{try{\_}user{\_}printer}

\TYPE {\small\verb%try_user_printer : formatter -> term -> unit%}\egroup

\SYNOPSIS
Try user-defined printers on a term.

\DESCRIBE
HOL Light allows arbitrary user printers to be inserted into the toplevel
printer so that they are invoked on all applicable subterms (see
{\small\verb%install_user_printer%}). The call {\small\verb%try_user_printer fmt tm%} attempts all
installed user printers on the term {\small\verb%tm%} in an implementation-defined order,
sending output to the formatter {\small\verb%fmt%}. If one succeeds, the call returns {\small\verb%()%},
and otherwise it fails.

\FAILURE
Fails if no user printer is applicable to the given term (e.g. if no user
printers have been installed).

\EXAMPLE
After installing the printer for variables with types in the example for
{\small\verb%install_user_printer%}, you can try:
{\par\samepage\setseps\small
\begin{verbatim}
  # try_user_printer std_formatter `x:num`;;
  (x:num)val it : unit = ()

  # try_user_printer std_formatter `1`;;
  Exception: Failure "tryfind".
\end{verbatim}
}

\SEEALSO
delete_user_color_printer, delete_user_printer, install_user_color_printer,
install_user_printer, try_user_color_printer.

\ENDDOC
\DOC{types}

\TYPE {\small\verb%types : unit -> (string * int) list%}\egroup

\SYNOPSIS
Lists all the types presently declared.

\DESCRIBE
The function {\small\verb%types%} should be applied to {\small\verb%()%} and returns a list of all the
type constructors declared, in the form of arity-name pairs.

\FAILURE
Never fails.

\EXAMPLE
In the initial state we have:
{\par\samepage\setseps\small
\begin{verbatim}
  # types();;
  val it : (string * int) list =
    [("finite_sum", 2); ("cart", 2); ("finite_image", 1); ("int", 0);
     ("real", 0); ("hreal", 0); ("nadd", 0); ("3", 0); ("2", 0); ("list", 1);
     ("option", 1); ("sum", 2); ("recspace", 1); ("num", 0); ("ind", 0);
     ("prod", 2); ("1", 0); ("bool", 0); ("fun", 2)]
\end{verbatim}
}

\SEEALSO
axioms, constants, new_type, new_type_definition.

\ENDDOC
\DOC{type{\_}abbrevs}

\TYPE {\small\verb%type_abbrevs : unit -> (string * hol_type) list%}\egroup

\SYNOPSIS
Lists all current type abbreviations.

\DESCRIBE
The call {\small\verb%type_abbrevs()%} returns a list of all current type abbreviations,
which are applied when parsing types but have no logical significance.

\FAILURE
Never fails.

\SEEALSO
new_type_abbrev, remove_type_abbrev.

\ENDDOC
\DOC{type{\_}invention{\_}error}

\TYPE {\small\verb%type_invention_error : bool ref%}\egroup

\SYNOPSIS
Determines if invented type variables are treated as an error.

\DESCRIBE
If HOL Light is unable to assign specific types to a term entered in quotation,
it will invent its own type variables to use in the most general type. The flag
{\small\verb%type_invention_error%} determines whether in such cases the term parser treats
it as an error. The default is {\small\verb%false%}, since sometimes the invention of type
variables is immaterial, e.g. in ad-hoc logical lemmas used inside a proof.
However, to enforce a more careful style, set it to {\small\verb%true%}.

\FAILURE
Not applicable.

\EXAMPLE
When the following term is entered, HOL Light invents a type variable to use as
the most general type. In the normal course of events this merely results in a
warning (see {\small\verb%type_invention_warning%} to remove even this warning):
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `x = x`;;
  Warning: inventing type variables
  val tm : term = `x = x`
\end{verbatim}
}
\noindent whereas if {\small\verb%type_invention_error%} is set to {\small\verb%true%}, the term parser
fails with an error message:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_invention_error := true;;
  val it : unit = ()
  # let tm = `x = x`;;
  Exception:
  Failure "typechecking error (cannot infer type of variables): =, x".
\end{verbatim}
}
\noindent You can avoid the error by explicitly giving appropriate types or
type variables yourself:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `(x:int) = x`;;
  val tm : term = `x = x`
\end{verbatim}
}

\SEEALSO
print_types_of_subterms, retypecheck, term_of_preterm, type_invention_warning.

\ENDDOC
\DOC{type{\_}invention{\_}warning}

\TYPE {\small\verb%type_invention_warning : bool ref%}\egroup

\SYNOPSIS
Determined if user is warned about invented type variables.

\DESCRIBE
If HOL Light is unable to assign specific types to a term entered in quotation,
it will invent its own type variables to use in the most general type. The flag
{\small\verb%type_invention_warning%} determines whether the user is warned in such
situations. The default is {\small\verb%true%}, since this can often indicate a user error
(e.g. the user forgot to define a constant before using it in a term or
overlooked more general types than expected). To disable the warnings, set it
to {\small\verb%false%}, while to make the checking even more rigorous and treat it as an
error, set {\small\verb%type_invention_error%} to {\small\verb%true%}.

\FAILURE
Not applicable.

\EXAMPLE
When the following term is entered, HOL Light invents a type variable to use as
the most general type:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `x IN s`;;
  Warning: inventing type variables
  val tm : term = `x IN s`
\end{verbatim}
}
\noindent which are not particularly intuitive, as you can see:
{\par\samepage\setseps\small
\begin{verbatim}
  # map dest_var (frees tm);;
  val it : (string * hol_type) list =
    [("x", `:?47676`); ("s", `:?47676->bool`)]
\end{verbatim}
}
\noindent You can avoid this by explicitly giving appropriate types or type
variables yourself:
{\par\samepage\setseps\small
\begin{verbatim}
  # let tm = `(x:A) IN s`;;
  val tm : term = `x IN s`
\end{verbatim}
}
But if you often want to let HOL Light invent types for itself without warning
you, set
{\par\samepage\setseps\small
\begin{verbatim}
  # type_invention_warning := false;;
  val it : unit = ()
\end{verbatim}
}
One reason why you might find the warning more irritating than helpful is if
you are rewriting with ad-hoc set theory lemmas generated like this:
{\par\samepage\setseps\small
\begin{verbatim}
  # SET_RULE `x IN UNIONS (a INSERT t) <=> x IN UNIONS t \/ x IN a`;;
\end{verbatim}
}

\SEEALSO
print_types_of_subterms, retypecheck, term_of_preterm, type_invention_error.

\ENDDOC
\DOC{type{\_}match}

\TYPE {\small\verb%type_match : hol_type -> hol_type -> (hol_type * hol_type) list -> (hol_type * hol_type) list%}\egroup

\SYNOPSIS
Computes a type instantiation to match one type to another.

\DESCRIBE
The call {\small\verb%type_match vty cty []%} will if possible find an instantiation of the
type variables in {\small\verb%vty%} to make it the same as {\small\verb%cty%}, and will fail if this is
not possible. The instantiation is returned in a list of term-variable pairs as
expected by type instantiation operations like {\small\verb%inst%} and {\small\verb%INST_TYPE%}. More
generally, {\small\verb%type_match vty cty env%} will attempt to find such a match assuming
that the instantiations already in the list {\small\verb%env%} are needed (this is helpful,
for example, in matching multiple pairs of types in parallel).

\FAILURE
Fails if there is no match under the chosen constraints.

\EXAMPLE
Here is a basic example with an empty last argument:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_match `:A->B->bool` `:num->num->bool` [];;
  val it : (hol_type * hol_type) list = [(`:num`, `:A`); (`:num`, `:B`)]
\end{verbatim}
}
\noindent and here is an illustration of how the extra argument can be used to
perform parallel matches.
{\par\samepage\setseps\small
\begin{verbatim}
  # itlist2 type_match
      [`:A->A->bool`; `:B->B->bool`] [`:num->num->bool`; `:bool->bool->bool`]
      [];;
  val it : (hol_type * hol_type) list = [(`:num`, `:A`); (`:bool`, `:B`)]
\end{verbatim}
}

\SEEALSO
inst, INST_TYPE, mk_mconst, term_match.

\ENDDOC
\DOC{type{\_}of}

\TYPE {\small\verb%type_of : term -> hol_type%}\egroup

\SYNOPSIS
Returns the type of a term.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # type_of `T`;;
  val it : hol_type = `:bool`
\end{verbatim}
}
\ENDDOC
\DOC{type{\_}of{\_}pretype}

\TYPE {\small\verb%type_of_pretype : pretype -> hol_type%}\egroup

\SYNOPSIS
Converts a pretype to a type.

\DESCRIBE
HOL Light uses ``pretypes'' and ``preterms'' as intermediate structures for
parsing and typechecking, which are later converted to types and terms. A call
{\small\verb%type_of_pretype pty%} attempts to convert pretype {\small\verb%pty%} into a HOL type.

\FAILURE
Fails if some type constants used in the pretype have not been defined, or if
the arities are wrong.

\COMMENTS
Only users seeking to change HOL's parser and typechecker quite radically need
to use this function.

\SEEALSO
pretype_of_type, retypecheck, term_of_preterm.

\ENDDOC
\DOC{type{\_}subst}

\TYPE {\small\verb%type_subst : (hol_type * hol_type) list -> hol_type -> hol_type%}\egroup

\SYNOPSIS
Substitute chosen types for type variables in a type.

\DESCRIBE
The call {\small\verb%type_subst [ty1,tv1; ... ; tyn,tvn] ty%} where each {\small\verb%tyi%} is a type
and each {\small\verb%tvi%} is a type variable, will systematically replace each instance of
{\small\verb%tvi%} in the type {\small\verb%ty%} by the corresponding type {\small\verb%tyi%}.

\FAILURE
Never fails. If some of the {\small\verb%tvi%} are not type variables they will be ignored,
and if several {\small\verb%tvi%} are the same, the first one in the list will be used to
determine the substitution.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # type_subst [`:num`,`:A`; `:bool`,`:B`] `:A->(B)list->A#B#C`;;
  val it : hol_type = `:num->(bool)list->num#bool#C`
\end{verbatim}
}

\SEEALSO
inst, tysubst.

\ENDDOC
\DOC{type{\_}unify}

\TYPE {\small\verb%type_unify : hol_type -> hol_type -> (hol_type * hol_type) list -> (hol_type * hol_type) list%}\egroup

\SYNOPSIS
Unify two types by instantiating their type variables

\DESCRIBE
Given two types {\small\verb%ty1%} and {\small\verb%ty2%} and an existing instantiation {\small\verb%i%} of type
variables,  a call {\small\verb%type_unify vars ty1 ty2 i%} attempts to find an augmented
instantiation of the type variables to make the two types equal.

\FAILURE
Fails if the two types are not first-order unifiable by instantiating the given
type variables.

\SEEALSO
instantiate, term_match, term_type_unify, term_unify.

\ENDDOC
\DOC{type{\_}vars{\_}in{\_}term}

\TYPE {\small\verb%type_vars_in_term : term -> hol_type list%}\egroup

\SYNOPSIS
Returns the set of type variables used in a term.

\DESCRIBE
The call {\small\verb%type_vars_in_term t%} returns the set of all type variables occurring
anywhere inside any subterm of {\small\verb%t%}.

\FAILURE
Never fails.

\EXAMPLE
Note that the list of types occurring somewhere in the term may be larger than
the set of type variables in the term's toplevel type. For example:
{\par\samepage\setseps\small
\begin{verbatim}
  # type_vars_in_term `!x:A. x = x`;;
  val it : hol_type list = [`:A`]
\end{verbatim}
}
\noindent whereas
{\par\samepage\setseps\small
\begin{verbatim}
  # tyvars(type_of `!x:A. x = x`);;
  val it : hol_type list = []
\end{verbatim}
}

\SEEALSO
frees, tyvars.

\ENDDOC
\DOC{typify{\_}universal{\_}set}

\TYPE {\small\verb%typify_universal_set : bool ref%}\egroup

\SYNOPSIS
Determines whether the universe set on a type is printed just as the type.

\DESCRIBE
The reference variable {\small\verb%typify_universal_set%} is one of several
settable parameters controlling printing of terms by {\small\verb%pp_print_term%}, and hence
the automatic printing of terms and theorems at the toplevel. When it is
{\small\verb%true%}, as it is by default, any universal set {\small\verb%UNIV:A->bool%} ({\small\verb%UNIV%} is a
predefined set constant valid over all types) is printed just as {\small\verb%(:A)%}. When
{\small\verb%typify_universal_set%} is {\small\verb%false%}, it is printed as {\small\verb%UNIV%}, just as for any
other constant.

\FAILURE
Not applicable.

\EXAMPLE
Note that having this setting is quite useful here:
{\par\samepage\setseps\small
\begin{verbatim}
  # CART_EQ;;
  val it : thm =
    |- !x y. x = y <=> (!i. 1 <= i /\ i <= dimindex (:B) ==> x $ i = y $ i)
\end{verbatim}
}

\USES
HOL Light's Cartesian power type (constructor `{\small\verb%^%}') uses a type to index the
power. When this flag is {\small\verb%true%}, formulas often become easier to understand
when printed, as in the above example.

\SEEALSO
pp_print_term, prebroken_binops, print_all_thm,
print_unambiguous_comprehensions, reverse_interface_mapping, unspaced_binops.

\ENDDOC
\DOC{tysubst}

\TYPE {\small\verb%tysubst : (hol_type * hol_type) list -> hol_type -> hol_type%}\egroup

\DESCRIBE
The call {\small\verb%tysubst [ty1',ty1; ... ; tyn',tyn] ty%} will systematically traverse
the type {\small\verb%ty%} and replace the topmost instances of any {\small\verb%tyi%} encountered with
the corresponding {\small\verb%tyi'%}. In the (usual) case where all the {\small\verb%tyi%} are type
variables, this is the same as {\small\verb%type_subst%}, but also works when they are not.

\FAILURE
Never fails. If several {\small\verb%tyi%} are the same, the first one in the list will be
used to determine the substitution.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # tysubst [`:num`,`:A`; `:bool`,`:B`] `:A->(B)list->A#B#C`;;
  val it : hol_type = `:num->(bool)list->num#bool#C`
  # tysubst [`:A`,`:(num)list`] `:num->(num)list->(num)list`;;
  val it : hol_type = `:num->A->A`
\end{verbatim}
}

\SEEALSO
inst, type_subst.

\ENDDOC
\DOC{tyvars}

\TYPE {\small\verb%tyvars : hol_type -> hol_type list%}\egroup

\SYNOPSIS
Returns a list of the type variables in a type.

\DESCRIBE
When applied to a type, {\small\verb%tyvars%} returns a list (possibly empty) of the type
variables that it involves.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # tyvars `:(A->bool)->A`;;
  val it : hol_type list = [`:A`]
\end{verbatim}
}

\SEEALSO
type_vars_in_term.

\ENDDOC
\DOC{uncurry}

\TYPE {\small\verb%uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c%}\egroup

\SYNOPSIS
Converts a function taking two arguments into a function taking a single
paired argument.

\DESCRIBE
The application {\small\verb%uncurry f%} returns {\small\verb%fun (x,y) -> f x y%}, so that
{\par\samepage\setseps\small
\begin{verbatim}
   uncurry f (x,y) = f x y
\end{verbatim}
}
\FAILURE
Never fails.

\SEEALSO
curry.

\ENDDOC
\DOC{undefine}

\TYPE {\small\verb%undefine : 'a -> ('a, 'b) func -> ('a, 'b) func%}\egroup

\SYNOPSIS
Remove definition of a finite partial function on specific domain value.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The call {\small\verb%undefine x f%} removes a definition for the domain value {\small\verb%x%} in
the finite partial function {\small\verb%f%}; if there was none to begin with the function
is unchanged.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let f = itlist I [1 |-> "1"; 2 |-> "2"; 3 |-> "3"] undefined;;
  val f : (int, string) func = <func>
  # dom f;;
  val it : int list = [1; 2; 3]
  # dom(undefine 2 f);;
  val it : int list = [1; 3]
\end{verbatim}
}

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefined.

\ENDDOC
\DOC{undefined}

\TYPE {\small\verb%undefined : ('a, 'b) func%}\egroup

\SYNOPSIS
Completely undefined finite partial function.

\DESCRIBE
This is one of a suite of operations on finite partial functions, type
{\small\verb%('a,'b)func%}. These may sometimes be preferable to ordinary functions since
they permit more operations such as equality comparison, extraction of domain
etc. The value {\small\verb%undefined%} is the `empty' finite partial function that is
nowhere defined.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # (undefined:(string,term)func);;
  val it : (string, term) func = <func>
  # apply it "anything";;
  Exception: Failure "apply".
\end{verbatim}
}

\USES
Starting a function to be augmented pointwise.

\SEEALSO
|->, |=>, apply, applyd, choose, combine, defined, dom, foldl, foldr,
graph, is_undefined, mapf, ran, tryapplyd, undefine.

\ENDDOC
\DOC{UNDISCH}

\TYPE {\small\verb%UNDISCH : thm -> thm%}\egroup

\SYNOPSIS
Undischarges the antecedent of an implicative theorem.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t1 ==> t2
   ----------------  UNDISCH
     A, t1 |- t2
\end{verbatim}
}

\FAILURE
{\small\verb%UNDISCH%} will fail on theorems which are not implications.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # UNDISCH(TAUT `p /\ q ==> p`);;
  val it : thm = p /\ q |- p
\end{verbatim}
}

\SEEALSO
DISCH, DISCH_ALL, DISCH_TAC, DISCH_THEN, STRIP_TAC, UNDISCH_ALL, UNDISCH_TAC.

\ENDDOC
\DOC{UNDISCH{\_}ALL}

\TYPE {\small\verb%UNDISCH_ALL : thm -> thm%}\egroup

\SYNOPSIS
Iteratively undischarges antecedents in a chain of implications.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
    A |- t1 ==> ... ==> tn ==> t
   ------------------------------  UNDISCH_ALL
        A, t1, ..., tn |- t
\end{verbatim}
}

\FAILURE
Unlike {\small\verb%UNDISCH%}, {\small\verb%UNDISCH_ALL%} will, when called on something other than an
implication, return its argument unchanged rather than failing.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # UNDISCH_ALL(TAUT `p ==> q ==> r ==> p /\ q /\ r`);;
  val it : thm = p, q, r |- p /\ q /\ r
\end{verbatim}
}

\SEEALSO
DISCH, DISCH_ALL, DISCH_TAC, DISCH_THEN, STRIP_TAC, UNDISCH, UNDISCH_TAC.

\ENDDOC
\DOC{UNDISCH{\_}TAC}

\TYPE {\small\verb%UNDISCH_TAC : term -> tactic%}\egroup

\SYNOPSIS
Undischarges an assumption.

\DESCRIBE
{\par\samepage\setseps\small
\begin{verbatim}
          A ?- t
   ====================  UNDISCH_TAC `v`
    A - {v} ?- v ==> t
\end{verbatim}
}

\FAILURE
{\small\verb%UNDISCH_TAC%} will fail if {\small\verb%`v`%} is not an assumption.

\COMMENTS
{\small\verb%UNDISCH%}arging {\small\verb%`v`%} will remove all assumptions that are alpha-equivalent to
{\small\verb%`v`%}.

\SEEALSO
DISCH, DISCH_ALL, DISCH_TAC, DISCH_THEN, STRIP_TAC, UNDISCH, UNDISCH_ALL,
UNDISCH_THEN.

\ENDDOC
\DOC{UNDISCH{\_}THEN}

\TYPE {\small\verb%UNDISCH_THEN : term -> thm_tactic -> tactic%}\egroup

\SYNOPSIS
Undischarges an assumption and applies theorem-tactic to it.

\DESCRIBE
The tactic {\small\verb%UNDISCH_THEN `a` ttac%} applied to a goal {\small\verb%A |- t%} takes {\small\verb%a%} out of
the assumptions to give a goal {\small\verb%A - {a} |- t%}, and applies the theorem-tactic
{\small\verb%ttac%} to the assumption {\small\verb%.. |- a%} and that new goal.

\FAILURE
Fails if {\small\verb%a%} is not an assumption; when applied to the goal it fails exactly if
the theorem-tactic fails on the modified goal.

\COMMENTS
The tactic {\small\verb%UNDISCH_TAC `t`%} can be considered the special case of
{\small\verb%UNDISCH_THEN `t` MP_TAC%}.

\SEEALSO
FIND_ASSUM, FIRST_X_ASSUM, UNDISCH_TAC.

\ENDDOC
\DOC{unhide{\_}constant}

\TYPE {\small\verb%unhide_constant : string -> unit%}\egroup

\SYNOPSIS
Restores recognition of a constant by the quotation parser.

\DESCRIBE
A call {\small\verb%unhide_constant "c"%}, where {\small\verb%c%} is a hidden constant, will unhide the
constant, that is, will make the quotation parser recognize it as such rather
than parsing it as a variable. It reverses the effect of the call
{\small\verb%hide_constant name%}.

\FAILURE
Fails unless the given name is a hidden constant in the current theory.

\COMMENTS
The hiding of a constant only affects the quotation parser; the constant is
still there in a theory, and may not be redefined.

\SEEALSO
hide_constant, is_hidden.

\ENDDOC
\DOC{UNIFY{\_}ACCEPT{\_}TAC}

\TYPE {\small\verb%UNIFY_ACCEPT_TAC : term list -> thm -> 'a * term -> ('b list * instantiation) * 'c list * (instantiation -> 'd list -> thm)%}\egroup

\SYNOPSIS
Unify free variables in theorem and metavariables in goal to accept theorem.

\DESCRIBE
Given a list {\small\verb%l%} of assignable metavariables, a theorem {\small\verb%th%} of the form {\small\verb%A |-
t%} and a goal {\small\verb%A' ?- t'%}, the tactic {\small\verb%UNIFY_ACCEPT_TAC%} attempts to unify {\small\verb%t%}
and {\small\verb%t'%} by instantiating free variables in {\small\verb%t%} and metavariables in the list
{\small\verb%l%} in the goal {\small\verb%t'%} so that they match, then accepts the theorem as the
solution of the goal.

\FAILURE
Fails if no unification will work. In fact, type instantiation is not at
present included in the unification.

\EXAMPLE
An inherently uninteresting but instructive example is the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(?x:num. p(x) /\ q(x) /\ r(x)) ==> ?y. p(y) /\ (q(y) <=> r(y))`;;
\end{verbatim}
}
\noindent which could of course be solved directly by {\small\verb%MESON_TAC[]%} or
{\small\verb%ITAUT_TAC%}. In fact, the process we will outline is close to what {\small\verb%ITAUT_TAC%}
does automatically. Let's start with:
{\par\samepage\setseps\small
\begin{verbatim}
  # e STRIP_TAC;;
  val it : goalstack = 1 subgoal (1 total)

   0 [`p x`]
   1 [`q x`]
   2 [`r x`]

  `?y. p y /\ (q y <=> r y)`
\end{verbatim}
}
\noindent and defer the actual choice of existential witness by introducing a
metavariable:
{\par\samepage\setseps\small
\begin{verbatim}
  # e (X_META_EXISTS_TAC `n:num` THEN CONJ_TAC);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`p x`]
   1 [`q x`]
   2 [`r x`]

  `q n <=> r n`

   0 [`p x`]
   1 [`q x`]
   2 [`r x`]

  `p n`
\end{verbatim}
}
\noindent Now we finally fix the metavariable to match our assumption:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(FIRST_X_ASSUM(UNIFY_ACCEPT_TAC [`n:num`]));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`p x`]
   1 [`q x`]
   2 [`r x`]


  `q x <=> r x`
\end{verbatim}
}
\noindent Note that the metavariable has also been correspondingly instantiated
in the remaining goal, which we can solve easily:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_REWRITE_TAC[]);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\USES
Terminating proof search when using metavariables. Used in {\small\verb%ITAUT_TAC%}

\SEEALSO
ACCEPT_TAC, ITAUT, ITAUT_TAC, MATCH_ACCEPT_TAC.

\ENDDOC
\DOC{union}

\TYPE {\small\verb%union : 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Computes the union of two `sets'.

\DESCRIBE
{\small\verb%union l1 l2%} returns a list consisting of the elements of {\small\verb%l1%} not already in
{\small\verb%l2%} concatenated with {\small\verb%l2%}. If {\small\verb%l1%} and {\small\verb%l2%} are initially free from
duplicates, this gives a set-theoretic union operation.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # union [1;2;3] [1;5;4;3];;
  val it : int list = [2; 1; 5; 4; 3]
  # union [1;1;1] [1;2;3;2];;
  val it : int list = [1; 2; 3; 2]
\end{verbatim}
}

\SEEALSO
setify, set_equal, intersect, subtract.

\ENDDOC
\DOC{unions}

\TYPE {\small\verb%unions : 'a list list -> 'a list%}\egroup

\SYNOPSIS
Performs the union of a set of sets.

\DESCRIBE
Applied to a list of lists, {\small\verb%union%} returns a list of all the elements of them,
in some unspecified order, with no repetitions. It can be considered as the
union of the family of `sets'.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # unions [[1;2]; [2;2;2;]; [2;3;4;5]];;
  val it : int list = [1; 2; 3; 4; 5]
\end{verbatim}
}

\SEEALSO
intersect, subtract.

\ENDDOC
\DOC{unions'}

\TYPE {\small\verb%unions' : ('a -> 'a -> bool) -> 'a list list -> 'a list%}\egroup

\SYNOPSIS
Compute union of a family of sets modulo an equivalence.

\DESCRIBE
If {\small\verb%r%} is an equivalence relation an {\small\verb%l%} a list of lists, the call
{\small\verb%unions' r l%} returns a list with one representative of each {\small\verb%r%}-equivalence
class occurring in any of the members. It thus gives a union of a family of
sets with no duplicates under the equivalence {\small\verb%r%}.

\FAILURE
Fails only if the relation {\small\verb%r%} fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # unions' (fun x y -> abs(x) = abs(y))
     [[-1; 2; 3]; [-2; -3; -4]; [4; 5; -6]];;
  val it : int list = [-1; -2; -3; 4; 5; -6]
\end{verbatim}
}

\SEEALSO
insert', mem', subtract', union', unions.

\ENDDOC
\DOC{union'}

\TYPE {\small\verb%union' : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list%}\egroup

\SYNOPSIS
Union of sets modulo an equivalence.

\DESCRIBE
The call {\small\verb%union' r l1 l2%} appends to the list {\small\verb%l2%} all those elements {\small\verb%x%} of
{\small\verb%l1%} for which there is not already an equivalent {\small\verb%x'%} with {\small\verb%r x x'%} in {\small\verb%l2%} or
earlier in {\small\verb%l1%}. If {\small\verb%l1%} and {\small\verb%l2%} were free of equivalents under {\small\verb%r%}, the
resulting list will be too, so this is a set operation modulo an equivalence.
The function {\small\verb%union%} is the special case where the relation is just equality.

\FAILURE
Fails only if the function {\small\verb%r%} fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # union' (fun x y -> abs(x) = abs(y)) [-1; 2; 1] [-2; -3; 4; -4];;
  val it : int list = [1; -2; -3; 4; -4]
\end{verbatim}
}

\USES
Maintaining sets modulo an equivalence such as alpha-equivalence.

\SEEALSO
insert', mem', subtract', union, unions'.

\ENDDOC
\DOC{uniq}

\TYPE {\small\verb%uniq : 'a list -> 'a list%}\egroup

\SYNOPSIS
Eliminate adjacent identical elements from a list.

\DESCRIBE
When applied to a list, {\small\verb%uniq%} gives a new list that results from coalescing
adjacent (only) elements of the list into one.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # uniq [1;2;3;1;2;3];;
  val it : int list = [1; 2; 3; 1; 2; 3]

  # uniq [1;1;1;2;3;3;3;3;4];;
  val it : int list = [1; 2; 3; 4]
\end{verbatim}
}

\SEEALSO
setify, sort.

\ENDDOC
\DOC{unparse{\_}as{\_}binder}

\TYPE {\small\verb%unparse_as_binder : string -> unit%}\egroup

\SYNOPSIS
Stops the quotation parser from treating a name as a binder.

\DESCRIBE
Certain identifiers {\small\verb%c%} have binder status, meaning that {\small\verb%`c x. y`%} is parsed
as a shorthand for {\small\verb%`(c) (\x. y)'%}. The call {\small\verb%unparse_as_binder "c"%} will
remove {\small\verb%c%} from the list of binders if it is there.

\FAILURE
Never fails, even if the string was not a binder.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # `!x. x < 2`;;
  val it : term = `!x. x < 2`

  # unparse_as_binder "!";;
  val it : unit = ()
  # `!x. x < 2`;;
  Exception: Failure "Unexpected junk after term".
\end{verbatim}
}

\COMMENTS
Removing binder status for the pre-existing binders like the quantifiers should
only be done with great care, since it can cause other parser invocations to
break.

\SEEALSO
binders, parses_as_binder, parse_as_binder.

\ENDDOC
\DOC{unparse{\_}as{\_}infix}

\TYPE {\small\verb%unparse_as_infix : string -> unit%}\egroup

\SYNOPSIS
Removes string from the list of infix operators.

\DESCRIBE
Certain identifiers are treated as infix operators with a given precedence and
associativity (left or right). The call {\small\verb%unparse_as_infix "op"%} removes {\small\verb%op%}
from the list of infix identifiers, if it was indeed there.

\FAILURE
Never fails, even if the given string did not originally have infix status.

\COMMENTS
Take care with applying this to some of the built-in operators, or parsing may
fail in existing libraries.

\SEEALSO
get_infix_status, infixes, parse_as_infix.

\ENDDOC
\DOC{unparse{\_}as{\_}prefix}

\TYPE {\small\verb%unparse_as_prefix : string -> unit%}\egroup

\SYNOPSIS
Removes prefix status for an identifier.

\DESCRIBE
Certain identifiers {\small\verb%c%} have prefix status, meaning that combinations of the
form {\small\verb%c f x%} will be parsed as {\small\verb%c (f x)%} rather than the usual {\small\verb%(c f) x%}. The
call {\small\verb%unparse_as_prefix "c"%} removes {\small\verb%c%} from the list of such identifiers.

\FAILURE
Never fails, regardless of whether {\small\verb%c%} originally did have prefix status.

\SEEALSO
is_prefix, parse_as_prefix, prefixes.

\ENDDOC
\DOC{unreserve{\_}words}

\TYPE {\small\verb%unreserve_words : string list -> unit%}\egroup

\SYNOPSIS
Remove given strings from the set of reserved words.

\DESCRIBE
Certain identifiers in HOL are reserved, e.g. `{\small\verb%if%}', `{\small\verb%let%}' and `{\small\verb%|%}',
meaning that they are special to the parser and cannot be used as ordinary
identifiers. The call {\small\verb%unreserve_words l%} removes all strings in {\small\verb%l%} from the
list of reserved identifiers.

\FAILURE
Never fails, regardless of whether the given strings were in fact reserved.

\COMMENTS
The initial set of reserved words in HOL Light should be unreserved only with
great care, since then various elementary constructs may fail to parse.

\SEEALSO
is_reserved_word, reserved_words, reserve_words.

\ENDDOC
\DOC{unset{\_}jrh{\_}lexer}

\TYPE {\small\verb%unset_jrh_lexer : (preprocessor keyword)%}\egroup

\SYNOPSIS
Updates the HOL Light preprocessor to respect OCaml's identifier convention.

\DESCRIBE
If a preprocessor reads {\small\verb%unset_jrh_lexer%}, it switches its lexer to
use OCaml's identifier convention. This makes an identifier starting with a
capiter letter unusable as the name of a let binding, but enables using it as a
module constructor.
Modulo this side effect, {\small\verb%unset_jrh_lexer%} is simply identical to {\small\verb%false%}.
The lexer can be enabled again using {\small\verb%set_jrh_lexer%}, which is identical to
{\small\verb%true%} after preprocessing.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # module OrdInt = struct type t = int let compare = (-) end;;
  Toplevel input:
  # module OrdInt = struct type t = int let compare = (-) end;;
          ^^^^^^
  Parse error: 'type' or [ext_attributes] expected after 'module' (in
    [str_item])
  # unset_jrh_lexer;;
  val it : bool = false
  # module OrdInt = struct type t = int let compare = (-) end;;
  module OrdInt : sig type t = int val compare : int -> int -> int end
\end{verbatim}
}

\FAILURE
Never fails.

\ENDDOC
\DOC{unset{\_}then{\_}multiple{\_}subgoals}

\TYPE {\small\verb%unset_then_multiple_subgoals : (preprocessor keyword)%}\egroup

\SYNOPSIS
Updates the HOL Light preprocessor to read {\small\verb%THEN%} as an alternative operator
which fails if the first tactic creates more than one subgoal.

\DESCRIBE
If a preprocessor reads {\small\verb%unset_then_multiple_subgoals%}, it starts to translate
{\small\verb%t1 THEN t2%} into {\small\verb%then1_ t1 t2%} which fails when {\small\verb%t1%} generates more than one
subgoal.
This is useful when one wants to check whether a proof written using {\small\verb%THEN%} can
be syntactically converted to the `e`-`g` form.
If this setting is on, {\small\verb%t1 THEN t2 THEN ..%} and {\small\verb%e(t1);; e(t2);; ...%}
have the same meaning (modulo the validity check).
After preprocessing, {\small\verb%unset_then_multiple_subgoals%} is identical to the {\small\verb%false%}
constant in OCaml.
To roll back the behavior of {\small\verb%THEN%}, use {\small\verb%set_then_multiple_subgoals%},
which is identical to {\small\verb%true%} modulo its side effect.

This command is only available for OCaml 4.xx and above.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # prove(`x + 1 = 1 + x /\ x + 2 = 2 + x`, CONJ_TAC THEN ARITH_TAC);;
  val it : thm = |- x + 1 = 1 + x /\ x + 2 = 2 + x

  # unset_then_multiple_subgoals;;
  val it : bool = false
  # prove(`x + 1 = 1 + x /\ x + 2 = 2 + x`, CONJ_TAC THEN ARITH_TAC);;
  Exception: Failure "seqapply: Length mismatch".
  # prove(`x + 1 = 1 + x /\ x + 2 = 2 + x`, CONJ_TAC THENL [ARITH_TAC; ARITH_TAC]);;
  val it : thm = |- x + 1 = 1 + x /\ x + 2 = 2 + x
  # prove(`x + 1 = 1 + x /\ x + 2 = 2 + x`, CONJ_TAC THENL (replicate ARITH_TAC 2));;
  val it : thm = |- x + 1 = 1 + x /\ x + 2 = 2 + x
\end{verbatim}
}

\FAILURE
Never fails.

\SEEALSO
e, er, THEN, VALID.

\ENDDOC
\DOC{unset{\_}verbose{\_}symbols}

\TYPE {\small\verb%unset_verbose_symbols : unit -> unit%}\egroup

\SYNOPSIS
Disables more verbose descriptive names for quantifiers and logical constants

\DESCRIBE
A call to {\small\verb%unset_verbose_symbols()%} disables the more verbose syntax for the
logical quantifiers and constants that is set up by default and can be
explicitly enabled by the dual function {\small\verb%set_verbose_symbols()%}.

\EXAMPLE
Notice how the printing of theorems changes from using the verbose descriptive
names for quantifiers by default:
{\par\samepage\setseps\small
\begin{verbatim}
  # num_Axiom;;
  val it : thm =
    |- forall e f.
           existsunique fn. fn 0 = e /\ (forall n. fn (SUC n) = f (fn n) n)
\end{verbatim}
}
\noindent to using the more concise symbolic names
{\par\samepage\setseps\small
\begin{verbatim}
  # unset_verbose_symbols();;
  val it : unit = ()
  # num_Axiom;;
  val it : thm = |- !e f. ?!fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
\end{verbatim}
}

\FAILURE
Only fails if some of the names have already been used for incompatible
constants.

\SEEALSO
overload_interface, override_interface, remove_interface, set_verbose_symbols,
the_interface.

\ENDDOC
\DOC{unspaced{\_}binops}

\TYPE {\small\verb%unspaced_binops : string list ref%}\egroup

\SYNOPSIS
Determines which binary operators are printed with surrounding spaces.

\DESCRIBE
The reference variable {\small\verb%unspaced_binops%} is one of several settable parameters
controlling printing of terms by {\small\verb%pp_print_term%}, and hence the automatic
printing of terms and theorems at the toplevel. It holds a list of the names of
infix binary operators that are printed without surrounding spaces. By default,
it contains just the pairing operation `{\small\verb%,%}', the numeric range `{\small\verb%..%}' and the
cartesian power indexing `{\small\verb%$%}'.

\FAILURE
Not applicable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # `x + 1`;;
  val it : term = `x + 1`

  # unspaced_binops := "+"::(!unspaced_binops);;
  val it : unit = ()
  # `x + 1`;;
  val it : term = `x+1`
\end{verbatim}
}

\SEEALSO
pp_print_term, prebroken_binops, print_all_thm,
print_unambiguous_comprehensions, reverse_interface_mapping,
typify_universal_set.

\ENDDOC
\DOC{UNWIND{\_}CONV}

\TYPE {\small\verb%UNWIND_CONV : term -> thm%}\egroup

\SYNOPSIS
Eliminates existentially quantified variables that are equated to something.

\DESCRIBE
The conversion {\small\verb%UNWIND_CONV%}, applied to a formula with one or more existential
quantifiers, eliminates any existential quantifiers where the body contains a
conjunct equating its variable to some other term (with that variable not free
in it).

\FAILURE
{\small\verb%UNWIND_CONV tm%} fails if {\small\verb%tm%} is not reducible according to that description.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # UNWIND_CONV `?a b c d. b = 7 /\ 2 = d /\ a + b + c + d = 97`;;
  val it : thm =
    |- (?a b c d. b = 7 /\ 2 = d /\ a + b + c + d = 97) <=>
       (?a c. a + 7 + c + 2 = 97)

  # UNWIND_CONV `?w x y z. w = z /\ x = 1 /\ x + y = z /\ y = 42`;;
  val it : thm = |- (?w x y z. w = z /\ x = 1 /\ x + y = z /\ y = 42) <=> T

  # UNWIND_CONV `x = 2`;;
  Exception: Failure "CHANGED_CONV".
\end{verbatim}
}

\SEEALSO
FORALL_UNWIND_CONV.

\ENDDOC
\DOC{unzip}

\TYPE {\small\verb%unzip : ('a * 'b) list -> 'a list * 'b list%}\egroup

\SYNOPSIS
Converts a list of pairs into a pair of lists.

\DESCRIBE
{\small\verb%unzip [(x1,y1);...;(xn,yn)]%} returns {\small\verb%([x1;...;xn],[y1;...;yn])%}.

\FAILURE
Never fails.

\SEEALSO
zip.

\ENDDOC
\DOC{use{\_}file}

\TYPE {\small\verb%use_file : string -> unit%}\egroup

\SYNOPSIS
Load a file, much like OCaml's {\small\verb%#use%} directive.

\DESCRIBE
Essentially the same as OCaml's {\small\verb%#use%} directive, but a regular OCaml function
and therefore easier to exploit programmatically.

\FAILURE
Only fails if the included file causes failure.

\SEEALSO
loads, loadt.

\ENDDOC
\DOC{use{\_}file{\_}raise{\_}failure}

\TYPE {\small\verb%use_file_raise_failure : bool ref%}\egroup

\SYNOPSIS
Flag determining whether unsuccessful loading of an OCaml file must raise
{\small\verb%Failure%}.

\DESCRIBE
The reference variable {\small\verb%use_file_raise_failure%} is used by the function
{\small\verb%use_file%} to determine whether an unsuccessful loading of a source file must
raise {\small\verb%Failure%} or simply print an error message on the screen.
The default value is {\small\verb%false%}.
The behavior of {\small\verb%loads%} and {\small\verb%loadt%} are also affected by this flag because they
internally invoke {\small\verb%use_file%}.

If this flag is set to {\small\verb%true%}, recursive loading will immediately fail after any
unsuccessful loading of a source file.
This is helpful for pinpointing the failing location from loading multiple source
files.
On the other hand, this will cause Toplevel forget all OCaml bindings
(`{\small\verb%let .. = ..;;%}') that have been made during the load before the erroneous point,
leading to a state whose OCaml definitions and constant definitions in HOL Light
are inconsistent.

If this flag is set to {\small\verb%false%}, unsuccessful loading will simply print a error
message and continue to the next statement.

\FAILURE
Not applicable.

\EXAMPLE
Consider {\small\verb%a.ml%} that has the following text:
{\par\samepage\setseps\small
\begin{verbatim}
   loadt "b.ml";;
   print_endline "b.ml loaded";;
\end{verbatim}
}
\noindent and {\small\verb%b.ml%}:
{\par\samepage\setseps\small
\begin{verbatim}
   undefined_var := 3;; (* Raises a failure *)
\end{verbatim}
}

If {\small\verb%use_file_raise_failure%} is set to {\small\verb%false%} (which is default), the message
in {\small\verb%a.ml%} is printed even if {\small\verb%b.ml%} fails.
{\par\samepage\setseps\small
\begin{verbatim}
   # loadt "a.ml";;
   File "/home/ubuntu/hol-light-aqjune/b.ml", line 1, characters 0-13:
                              1 | undefined_var := 3;; (* Raises a failure *)
                                  ^^^^^^^^^^^^^
                              Error: Unbound value undefined_var
   Error in included file /home/ubuntu/hol-light-aqjune/b.ml
   - : unit = ()
   b.ml loaded
   - : unit = ()
   val it : unit = ()
\end{verbatim}
}
However, if it is set to {\small\verb%true%}, the message is not printed because loading
{\small\verb%a.ml%} also fails immediately after loading {\small\verb%b.ml%}.
Also, the stack trace is printed because the failure reaches to the top level.
{\par\samepage\setseps\small
\begin{verbatim}
   # use_file_raise_failure := true;;
   val it : unit = ()
   # loadt "a.ml";;
   File "/home/ubuntu/hol-light-aqjune/b.ml", line 1, characters 0-13:
   1 | undefined_var := 3;; (* Raises a failure *)
       ^^^^^^^^^^^^^
   Error: Unbound value undefined_var
   Exception:
   Failure "Error in included file /home/ubuntu/hol-light-aqjune/b.ml".
   Exception:
   Failure "Error in included file /home/ubuntu/hol-light-aqjune/a.ml".
\end{verbatim}
}

\SEEALSO
use_file, loads, loadt.

\ENDDOC
\DOC{USE{\_}THEN}

\TYPE {\small\verb%USE_THEN : string -> thm_tactic -> tactic%}\egroup

\SYNOPSIS
Apply a theorem tactic to named assumption.

\DESCRIBE
The tactic {\small\verb%USE_THEN "name" ttac%} applies the theorem-tactic {\small\verb%ttac%} to the
assumption labelled {\small\verb%name%} (or the first in the list if there is more than
one).

\FAILURE
Fails if there is no assumption of that name or if the theorem-tactic fails
when applied to it.

\EXAMPLE
See {\small\verb%LABEL_TAC%} for an extended example.

\USES
Using an assumption identified by name.

\SEEALSO
ASSUME, FIND_ASSUM, HYP, LABEL_TAC, REMOVE_THEN.

\ENDDOC
\DOC{VALID}

\TYPE {\small\verb%VALID : tactic -> tactic%}\egroup

\SYNOPSIS
Tries to ensure that a tactic is valid.

\DESCRIBE
For any tactic {\small\verb%t%}, the application {\small\verb%VALID t%} gives a new tactic that does
exactly the same as {\small\verb%t%} except that it also checks validity of the tactic
and will fail if it is violated. Validity means that the subgoals produced by
{\small\verb%t%} can, if proved, be used by the justification function given by {\small\verb%t%} to
construct a theorem corresponding to the original goal.

This check is performed by actually creating, using {\small\verb%mk_fthm%}, theorems
corresponding to the subgoals, and seeing if the result of applying the
justification function to them gives a theorem corresponding to the original
goal. If it does, then {\small\verb%VALID t%} simply applies {\small\verb%t%}, and if not it fails. In
principle, the extra dummy hypothesis used by {\small\verb%mk_fthm%} (necessary to ensure
logical soundness) could interfere with the mechanism of the tactic, but this
never seems to happen.

\COMMENTS
You can always force validity checking whenever it is applied by using {\small\verb%VALID%}
on a tactic. But if the goal is initially proved by using the subgoal stack
this is probably not necessary since {\small\verb%VALID%} is already implicitly applied in
the {\small\verb%e%} (expand) function.

\SEEALSO
CHANGED_TAC, e, mk_fthm, TRY.

\ENDDOC
\DOC{variables}

\TYPE {\small\verb%variables : term -> term list%}\egroup

\SYNOPSIS
Determines the variables used, free or bound, in a given term.

\DESCRIBE
Given a term argument, {\small\verb%variables%} returns a list of variables that occur free
or bound in that term.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # variables `\a:bool. a`;;
  val it : term list = [`a`]
  # variables `(a:num) + (b:num)`;;
  val it : term list = [`b`; `a`]
\end{verbatim}
}

\SEEALSO
frees, free_in.

\ENDDOC
\DOC{variant}

\TYPE {\small\verb%variant : term list -> term -> term%}\egroup

\SYNOPSIS
Modifies a variable name to avoid clashes.

\DESCRIBE
The call {\small\verb%variant avoid v%} returns a variant of {\small\verb%v%}, with the name changed by
adding primes as much as necessary to avoid clashing with any free variables of
the terms in the list {\small\verb%avoid%}. Usually {\small\verb%avoid%} is just a list of variables, in
which case {\small\verb%v%} is renamed so as to be different from all of them.

The exact form of the variable name should not be relied on, except that the
original variable will be returned unmodified unless it is free in some term in
the {\small\verb%avoid%} list.

\FAILURE
{\small\verb%variant l t%} fails if any term in the list {\small\verb%l%} is not a variable or if
{\small\verb%t%} is neither a variable nor a constant.

\EXAMPLE
The following shows a few typical cases:
{\par\samepage\setseps\small
\begin{verbatim}
  # variant [`y:bool`; `z:bool`] `x:bool`;;
  val it : term = `x`

  # variant [`x:bool`; `x':num`; `x'':num`] `x:bool`;;
  val it : term = `x'`

  # variant [`x:bool`; `x':bool`; `x'':bool`] `x:bool`;;
  val it : term = `x'''`
\end{verbatim}
}

\USES
The function {\small\verb%variant%} is extremely useful for complicated derived rules which
need to rename variables to avoid free variable capture while still making the
role of the variable obvious to the user.

\SEEALSO
genvar, hide_constant.

\ENDDOC
\DOC{variants}

\TYPE {\small\verb%variants : term list -> term list -> term list%}\egroup

\SYNOPSIS
Pick a list of variants of variables, avoiding a list of variables and each
other.

\DESCRIBE
The call {\small\verb%variants av vs%},s where {\small\verb%av%} and {\small\verb%vs%} are both lists of variables,
will return a list {\small\verb%vs'%} of variants of the variables in the list {\small\verb%vs%}, renamed
as necessary by adding primes to avoid clashing with any free variables of the
terms in the list {\small\verb%av%} or with each other.

\FAILURE
Fails if any of the terms in the list is not a variable.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # variants [`x':num`; `x'':num`; `y:bool`] [`x:num`; `x':num`];;
  val it : term list = [`x`; `x'''`]
\end{verbatim}
}

\SEEALSO
genvar, mk_primed_var, variant.

\ENDDOC
\DOC{verbose}

\TYPE {\small\verb%verbose : bool ref%}\egroup

\SYNOPSIS
Flag to control verbosity of informative output.

\DESCRIBE
When the value of {\small\verb%verbose%} is set to {\small\verb%true%}, the function {\small\verb%remark%} will output
its string argument whenever called. This is used for most informative output
in automated rules.

\FAILURE
Not applicable.

\EXAMPLE
Consider this call MESON to prove a first-order formula:
{\par\samepage\setseps\small
\begin{verbatim}
  # MESON[] `!f g:num->num. (?!x. x = g(f(x))) <=> (?!y. y = f(g(y)))`;;
  0..0..1..solved at 4
  CPU time (user): 0.01
  0..0..1..2..6..11..19..28..37..46..94..151..247..366..584..849..solved at 969
  CPU time (user): 0.12
  0..0..1..solved at 4
  CPU time (user): 0.
  0..0..1..2..6..11..19..28..37..46..94..151..247..366..584..849..solved at 969
  CPU time (user): 0.06
  val it : thm = |- !f g. (?!x. x = g (f x)) <=> (?!y. y = f (g y))
\end{verbatim}
}
\noindent By changing the verbosity level, most of the output disappears:
{\par\samepage\setseps\small
\begin{verbatim}
  # verbose := false;;
  val it : unit = ()
  # MESON[] `!f g:num->num. (?!x. x = g(f(x))) <=> (?!y. y = f(g(y)))`;;
  CPU time (user): 0.01
  CPU time (user): 0.13
  CPU time (user): 0.
  CPU time (user): 0.081
  val it : thm = |- !f g. (?!x. x = g (f x)) <=> (?!y. y = f (g y))
\end{verbatim}
}
\noindent and if we also disable timing reporting the action is silent:
{\par\samepage\setseps\small
\begin{verbatim}
  # report_timing := false;;
  val it : unit = ()
  # MESON[] `!f g:num->num. (?!x. x = g(f(x))) <=> (?!y. y = f(g(y)))`;;
  val it : thm = |- !f g. (?!x. x = g (f x)) <=> (?!y. y = f (g y))
\end{verbatim}
}

\SEEALSO
remark, report_timing.

\ENDDOC
\DOC{vfree{\_}in}

\TYPE {\small\verb%vfree_in : term -> term -> bool%}\egroup

\SYNOPSIS
Tests whether a variable (or constant) occurs free in a term.

\DESCRIBE
The call {\small\verb%vfree_in v t%}, where {\small\verb%v%} is a variable (or constant, though this is
not usually exploited) and {\small\verb%t%} any term, tests whether {\small\verb%v%} occurs free in {\small\verb%t%},
and returns {\small\verb%true%} if so, {\small\verb%false%} if not. This is functionally equivalent to
{\small\verb%mem v (frees t)%} but may be more efficient because it never constructs the
list of free variables explicitly.

\FAILURE
Never fails.

\EXAMPLE
Here's a simple example:
{\par\samepage\setseps\small
\begin{verbatim}
  # vfree_in `x:num` `x + y + 1`;;
  val it : bool = true

  # vfree_in `x:num` `x /\ y /\ z`;;
  val it : bool = false
\end{verbatim}
}
To see how using {\small\verb%vfree_in%} can be more efficient than examining the free
variable list explicitly, consider a huge term with one free and one
bound variable:
{\par\samepage\setseps\small
\begin{verbatim}

  # let tm = mk_abs(`p:bool`,funpow 17 (fun s -> mk_conj(s,s)) `p /\ q`);;
  ....
\end{verbatim}
}
\noindent It takes an appreciable time to get the list of free variables:
{\par\samepage\setseps\small
\begin{verbatim}
  # time frees tm;;
  CPU time (user): 0.31
  val it : term list = [`q`]
\end{verbatim}
}
\noindent yet we can test if {\small\verb%p%} or {\small\verb%q%} is free almost instantaneously. Only a
little of the term needs to be traversed to find the answer (just one level in
the case of {\small\verb%p%}, since it is bound at the outer term constructor).
{\par\samepage\setseps\small
\begin{verbatim}
  # time (vfree_in `q:bool`) tm;;
  CPU time (user): 0.
  val it : bool = true
\end{verbatim}
}

\SEEALSO
free_in, frees, freesin.

\ENDDOC
\DOC{vsubst}

\TYPE {\small\verb%vsubst : (term * term) list -> term -> term%}\egroup

\SYNOPSIS
Substitute terms for variables inside a term.

\DESCRIBE
The call {\small\verb%vsubst [t1,x1; ...; tn,xn] t%} systematically replaces free instances
of each variable {\small\verb%xi%} inside {\small\verb%t%} with the corresponding {\small\verb%ti%} from the
instantiation list. Bound variables will be renamed if necessary to avoid
capture.

\FAILURE
Fails if any of the pairs {\small\verb%ti,xi%} in the instantiation list has {\small\verb%xi%} and {\small\verb%ti%}
with different types, or {\small\verb%xi%} a non-variable. Multiple instances of the same
{\small\verb%xi%} in the list are not trapped, but only the first one will be used
consistently.

\EXAMPLE
Here is a relatively simple example
{\par\samepage\setseps\small
\begin{verbatim}
  # vsubst [`1`,`x:num`; `2`,`y:num`] `x + y + 3`;;
  val it : term = `1 + 2 + 3`
\end{verbatim}
}
\noindent and here is a more complex instance where renaming of bound variables
is needed:
{\par\samepage\setseps\small
\begin{verbatim}
  # vsubst [`y:num`,`x:num`] `!y. x + y < x + y + 1`;;
  val it : term = `!y'. y + y' < y + y' + 1`
\end{verbatim}
}

\COMMENTS
An analogous function {\small\verb%subst%} is more general, and will substitute for free
occurrences of any term, not just variables. However, {\small\verb%vsubst%} is generally
much more efficient if you do just need substitution for variables.

\SEEALSO
inst, subst.

\ENDDOC
\DOC{W}

\TYPE {\small\verb%W : ('a -> 'a -> 'b) -> 'a -> 'b%}\egroup

\SYNOPSIS
Duplicates function argument : {\small\verb%W f x%} = {\small\verb%f x x%}.

\FAILURE
Never fails.

\SEEALSO
C, F_F, I, K, o.

\ENDDOC
\DOC{warn}

\TYPE {\small\verb%warn : bool -> string -> unit%}\egroup

\SYNOPSIS
Prints out a warning string

\DESCRIBE
When applied to a boolean value {\small\verb%b%} and a string {\small\verb%s%}, the call {\small\verb%warn b s%}
prints out ``{\small\verb%Warning: s%}'' and a following newline to the terminal if {\small\verb%b%} is
true and otherwise does nothing.

\FAILURE
Never fails.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # let n = 7;;
  val n : int = 7
  # warn (n <> 0) "Nonzero value";;
  Warning: Nonzero value
  val it : unit = ()
\end{verbatim}
}

\SEEALSO
remark, report.

\ENDDOC
\DOC{WEAK{\_}CNF{\_}CONV}

\TYPE {\small\verb%WEAK_CNF_CONV : conv%}\egroup

\SYNOPSIS
Converts a term already in negation normal form into conjunctive normal form.

\DESCRIBE
When applied to a term already in negation normal form (see {\small\verb%NNF_CONV%}),
meaning that all other propositional connectives have been eliminated in favour
of conjunction, disjunction and negation, and negation is only applied to
atomic formulas, {\small\verb%WEAK_CNF_CONV%} puts the term into an equivalent conjunctive
normal form, which is a conjunction of disjunctions.

\FAILURE
Never fails; non-Boolean terms will just yield a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # WEAK_CNF_CONV `(a /\ b) \/ (a /\ b /\ c) \/ d`;;
  val it : thm =
    |- a /\ b \/ a /\ b /\ c \/ d <=>
       ((a \/ a \/ d) /\ (b \/ a \/ d)) /\
       ((a \/ b \/ d) /\ (b \/ b \/ d)) /\
       (a \/ c \/ d) /\
       (b \/ c \/ d)
\end{verbatim}
}

\COMMENTS
The ordering and associativity of the resulting form are not guaranteed, and it
may contain duplicates. See {\small\verb%CNF_CONV%} for a stronger (but somewhat slower)
variant where this is important.

\SEEALSO
CNF_CONV, DNF_CONV, NNF_CONV, WEAK_DNF_CONV.

\ENDDOC
\DOC{WEAK{\_}DNF{\_}CONV}

\TYPE {\small\verb%WEAK_DNF_CONV : conv%}\egroup

\SYNOPSIS
Converts a term already in negation normal form into disjunctive normal form.

\DESCRIBE
When applied to a term already in negation normal form (see {\small\verb%NNF_CONV%}),
meaning that all other propositional connectives have been eliminated in favour
of disjunction, disjunction and negation, and negation is only applied to
atomic formulas, {\small\verb%WEAK_DNF_CONV%} puts the term into an equivalent disjunctive
normal form, which is a disjunction of conjunctions.

\FAILURE
Never fails; non-Boolean terms will just yield a reflexive theorem.

\EXAMPLE
{\par\samepage\setseps\small
\begin{verbatim}
  # WEAK_DNF_CONV `(a \/ b) /\ (a \/ c /\ e)`;;
  val it : thm =
    |- (a \/ b) /\ (a \/ c /\ e) <=>
       (a /\ a \/ b /\ a) \/ a /\ c /\ e \/ b /\ c /\ e
\end{verbatim}
}

\COMMENTS
The ordering and associativity of the resulting form are not guaranteed, and it
may contain duplicates. See {\small\verb%DNF_CONV%} for a stronger (but somewhat slower)
variant where this is important.

\SEEALSO
CNF_CONV, DNF_CONV, NNF_CONV, WEAK_CNF_CONV.

\ENDDOC
\DOC{WF{\_}INDUCT{\_}TAC}

\TYPE {\small\verb%WF_INDUCT_TAC : term -> (string * thm) list * term -> goalstate%}\egroup

\SYNOPSIS
Performs wellfounded induction with respect to a given `measure'.

\DESCRIBE
The tactic {\small\verb%WF_INDUCT_TAC%} is applied to two arguments. The second is a goal to
prove, and the first is an expression to use as a ``measure''. The result is a
new subgoal where the same goal is to be proved but as an assumption it holds
for all smaller values of the measure, universally quantified over the free
variables in the measure term (which should also be free in the goal).

\FAILURE
Never fails.

\EXAMPLE
Suppose we define a Euclidean GCD algorithm:
{\par\samepage\setseps\small
\begin{verbatim}
  # let egcd = define
     `egcd(m,n) = if m = 0 then n
                  else if n = 0 then m
                  else if m <= n then egcd(m,n - m)
                  else egcd(m - n,n)`;;
\end{verbatim}
}
\noindent and after picking up from the library an infix `{\small\verb%divides%}' relation
for divisibility:
{\par\samepage\setseps\small
\begin{verbatim}
  # needs "Library/prime.ml";;
\end{verbatim}
}
\noindent we want to prove something about the result, e.g.
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m n d. d divides egcd(m,n) <=> d divides m /\ d divides n`;;
\end{verbatim}
}
\noindent A natural way to proceed is by induction on the sum of the arguments:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(GEN_TAC THEN GEN_TAC THEN WF_INDUCT_TAC `m + n`);;
  val it : goalstack = 1 subgoal (1 total)

   0 [`!m'' n'.
             m'' + n' < m + n
             ==> (!d. d divides egcd (m'',n') <=> d divides m'' /\ d divides n')`]

  `!d. d divides egcd (m,n) <=> d divides m /\ d divides n`
\end{verbatim}
}
\noindent Note that we have the same goal, but an assumption that it holds for
smaller values of the measure term.

\COMMENTS
Wellfounded induction can always be performed on any relation by using {\small\verb%WF_IND%}
together with an assumption of wellfoundedness such as {\small\verb%num_WF%} or
{\small\verb%WF_MEASURE%}. This tactic is just a slightly more convenient packaging.

\SEEALSO
INDUCT_TAC, LIST_INDUCT_TAC.

\ENDDOC
\DOC{X{\_}CHOOSE{\_}TAC}

\TYPE {\small\verb%X_CHOOSE_TAC : term -> thm_tactic%}\egroup

\SYNOPSIS
Assumes a theorem, with existentially quantified variable replaced by a given
witness.

\DESCRIBE
{\small\verb%X_CHOOSE_TAC%} expects a variable {\small\verb%y%} and theorem with an existentially
quantified conclusion.  When applied to a goal, it adds a new
assumption obtained by introducing the variable {\small\verb%y%} as a witness for
the object {\small\verb%x%} whose existence is asserted in the theorem.
{\par\samepage\setseps\small
\begin{verbatim}
           A ?- t
   ===================  X_CHOOSE_TAC `y` (A1 |- ?x. w)
    A u {w[y/x]} ?- t         (`y` not free anywhere)
\end{verbatim}
}

\FAILURE
Fails if the theorem's conclusion is not existentially quantified, or if
the first argument is not a variable.  Failures may arise in the
tactic-generating function.  An invalid tactic is produced if the
introduced variable is free in {\small\verb%w%} or {\small\verb%t%}, or if the theorem has any
hypothesis which is not alpha-convertible to an assumption of the
goal.

\EXAMPLE
Given a goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `(?y. x = y + 2) ==> x < x * x`;;
\end{verbatim}
}
\noindent the following may be applied:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN(X_CHOOSE_TAC `d:num`));;
  val it : goalstack = 1 subgoal (1 total)

   0 [`x = d + 2`]

  `x < x * x`
\end{verbatim}
}
\noindent after which the following will finish things:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(ASM_REWRITE_TAC[] THEN ARITH_TAC);;
  val it : goalstack = No subgoals
\end{verbatim}
}

\SEEALSO
CHOOSE, CHOOSE_THEN, X_CHOOSE_THEN.

\ENDDOC
\DOC{X{\_}CHOOSE{\_}THEN}

\TYPE {\small\verb%X_CHOOSE_THEN : term -> thm_tactical%}\egroup

\SYNOPSIS
Replaces existentially quantified variable with given witness, and passes it to
a theorem-tactic.

\DESCRIBE
{\small\verb%X_CHOOSE_THEN%} expects a variable {\small\verb%y%}, a tactic-generating function {\small\verb%ttac%},
and a theorem of the form {\small\verb%(A1 |- ?x. w)%} as arguments.  A new theorem is
created by introducing the given variable {\small\verb%y%} as a witness for the object {\small\verb%x%}
whose existence is asserted in the original theorem, {\small\verb%(w[y/x] |- w[y/x])%}.  If
the tactic-generating function {\small\verb%ttac%} applied to this theorem produces results
as follows when applied to a goal {\small\verb%(A ?- t)%}:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   =========  ttac ({w[y/x]} |- w[y/x])
    A ?- t1
\end{verbatim}
}
\noindent then applying {\small\verb%(X_CHOOSE_THEN `y` ttac (A1 |- ?x. w))%} to the
goal {\small\verb%(A ?- t)%} produces the subgoal:
{\par\samepage\setseps\small
\begin{verbatim}
    A ?- t
   =========  X_CHOOSE_THEN `y` ttac (A1 |- ?x. w)
    A ?- t1         (`y` not free anywhere)
\end{verbatim}
}

\FAILURE
Fails if the theorem's conclusion is not existentially quantified, or if
the first argument is not a variable.  Failures may arise in the
tactic-generating function.  An invalid tactic is produced if the
introduced variable is free in {\small\verb%w%} or {\small\verb%t%}, or if the theorem has any
hypothesis which is not alpha-convertible to an assumption of the
goal.

\EXAMPLE
Suppose we have the following goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # g `!m n. m < n ==> m EXP 2 + 2 * m <= n EXP 2`;;
\end{verbatim}
}
\noindent and rewrite with a theorem to get an existential antecedent:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(REPEAT GEN_TAC THEN REWRITE_TAC[LT_EXISTS]);;
  val it : goalstack = 1 subgoal (1 total)

`(?d. n = m + SUC d) ==> m EXP 2 + 2 * m <= n EXP 2`
\end{verbatim}
}
\noindent we may then use {\small\verb%X_CHOOSE_THEN%} to introduce the name {\small\verb%e%} for the
existential variable and immediately substitute it in the goal:
{\par\samepage\setseps\small
\begin{verbatim}
  # e(DISCH_THEN(X_CHOOSE_THEN `e:num` SUBST1_TAC));;
  val it : goalstack = 1 subgoal (1 total)

  `m EXP 2 + 2 * m <= (m + SUC e) EXP 2`
\end{verbatim}
}
\noindent at which point {\small\verb%ARITH_TAC%} will finish it.

\SEEALSO
CHOOSE, CHOOSE_THEN, CONJUNCTS_THEN, CONJUNCTS_THEN2, DISJ_CASES_THEN,
DISJ_CASES_THEN2, STRIP_THM_THEN, X_CHOOSE_TAC.

\ENDDOC
\DOC{X{\_}GEN{\_}TAC}

\TYPE {\small\verb%X_GEN_TAC : term -> tactic%}\egroup

\SYNOPSIS
Specializes a goal with the given variable.

\DESCRIBE
When applied to a term {\small\verb%x'%}, which should be a variable, and a goal
{\small\verb%A ?- !x. t%}, the tactic {\small\verb%X_GEN_TAC%} returns the goal {\small\verb%A ?- t[x'/x]%}.
{\par\samepage\setseps\small
\begin{verbatim}
     A ?- !x. t
   ==============  X_GEN_TAC `x'`
    A ?- t[x'/x]
\end{verbatim}
}

\FAILURE
Fails unless the goal's conclusion is universally quantified and the term a
variable of the appropriate type. It also fails if the variable given is free
in either the assumptions or (initial) conclusion of the goal.

\USES
It is perhaps good practice to use this rather than {\small\verb%GEN_TAC%}, to ensure that
there is no dependency on the bound variable name in the goal, which can
sometimes arise somewhat arbitrarily, e.g. in higher-order matching.

\SEEALSO
FIX_TAC, GEN, GENL, GEN_ALL, GEN_TAC, INTRO_TAC, SPEC, SPECL, SPEC_ALL,
SPEC_TAC, STRIP_TAC.

\ENDDOC
\DOC{X{\_}META{\_}EXISTS{\_}TAC}

\TYPE {\small\verb%X_META_EXISTS_TAC : term -> tactic%}\egroup

\SYNOPSIS
Replaces existentially quantified variable with given metavariables.

\DESCRIBE
Given a variable {\small\verb%v%} and a goal of the form {\small\verb%A ?- ?x. t[x]%}, the tactic
{\small\verb%X_META_EXISTS_TAC%} gives the new goal {\small\verb%A ?- t[v]%} where {\small\verb%v%} is a new
metavariable. In the resulting proof, it is as if the variable has been
assigned here to the later choice for this metavariable, which can be made
through {\small\verb%UNIFY_ACCEPT_TAC%}.

\FAILURE
Fails if the metavariable is not a variable.

\EXAMPLE
See {\small\verb%UNIFY_ACCEPT_TAC%} for an example of using metavariables.

\USES
Delaying instantiations until the correct term becomes clearer.

\COMMENTS
Users should probably steer clear of using metavariables if possible. Note that
the metavariable instantiations apply across the whole fringe of goals, not
just the current goal, and can lead to confusion.

\SEEALSO
EXISTS_TAC, META_EXISTS_TAC, META_SPEC_TAC, UNIFY_ACCEPT_TAC.

\ENDDOC
\DOC{zip}

\TYPE {\small\verb%zip : 'a list -> 'b list -> ('a * 'b) list%}\egroup

\SYNOPSIS
Converts a pair of lists into a list of pairs.

\DESCRIBE
{\small\verb%zip [x1;...;xn] [y1;...;yn]%} returns {\small\verb%[(x1,y1);...;(xn,yn)]%}.

\FAILURE
Fails if the two lists are of different lengths.

\SEEALSO
unzip.

\ENDDOC
